
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model UserRoleMapping
 * 
 */
export type UserRoleMapping = $Result.DefaultSelection<Prisma.$UserRoleMappingPayload>
/**
 * Model Courses
 * 
 */
export type Courses = $Result.DefaultSelection<Prisma.$CoursesPayload>
/**
 * Model Lessons
 * 
 */
export type Lessons = $Result.DefaultSelection<Prisma.$LessonsPayload>
/**
 * Model CourseUserMapper
 * 
 */
export type CourseUserMapper = $Result.DefaultSelection<Prisma.$CourseUserMapperPayload>
/**
 * Model Contest
 * 
 */
export type Contest = $Result.DefaultSelection<Prisma.$ContestPayload>
/**
 * Model ContestQuestion
 * 
 */
export type ContestQuestion = $Result.DefaultSelection<Prisma.$ContestQuestionPayload>
/**
 * Model ContestAttempt
 * 
 */
export type ContestAttempt = $Result.DefaultSelection<Prisma.$ContestAttemptPayload>
/**
 * Model ContestAnswer
 * 
 */
export type ContestAnswer = $Result.DefaultSelection<Prisma.$ContestAnswerPayload>
/**
 * Model Challenge
 * 
 */
export type Challenge = $Result.DefaultSelection<Prisma.$ChallengePayload>
/**
 * Model ChallengeAttempt
 * 
 */
export type ChallengeAttempt = $Result.DefaultSelection<Prisma.$ChallengeAttemptPayload>
/**
 * Model Counselor
 * 
 */
export type Counselor = $Result.DefaultSelection<Prisma.$CounselorPayload>
/**
 * Model ConsultationRequest
 * 
 */
export type ConsultationRequest = $Result.DefaultSelection<Prisma.$ConsultationRequestPayload>
/**
 * Model Meeting
 * 
 */
export type Meeting = $Result.DefaultSelection<Prisma.$MeetingPayload>
/**
 * Model Resource
 * 
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const currenrStudylevel: {
  PRIMARY_SCHOOL: 'PRIMARY_SCHOOL',
  MIDDLE_SCHOOL: 'MIDDLE_SCHOOL',
  HIGH_SCHOOL: 'HIGH_SCHOOL',
  SENIOR_SECONDARY: 'SENIOR_SECONDARY',
  UNDERGRADUATE: 'UNDERGRADUATE',
  POSTGRADUATE: 'POSTGRADUATE',
  DOCTORATE: 'DOCTORATE'
};

export type currenrStudylevel = (typeof currenrStudylevel)[keyof typeof currenrStudylevel]


export const CourseLevel: {
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED'
};

export type CourseLevel = (typeof CourseLevel)[keyof typeof CourseLevel]


export const ChallengeType: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type ChallengeType = (typeof ChallengeType)[keyof typeof ChallengeType]


export const EmploymentType: {
  PART_TIME: 'PART_TIME',
  FULL_TIME: 'FULL_TIME'
};

export type EmploymentType = (typeof EmploymentType)[keyof typeof EmploymentType]


export const ConsultationType: {
  INSTANT: 'INSTANT',
  SCHEDULED: 'SCHEDULED'
};

export type ConsultationType = (typeof ConsultationType)[keyof typeof ConsultationType]


export const ConsultationStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type ConsultationStatus = (typeof ConsultationStatus)[keyof typeof ConsultationStatus]


export const MeetingProvider: {
  AGORA: 'AGORA'
};

export type MeetingProvider = (typeof MeetingProvider)[keyof typeof MeetingProvider]


export const MeetingStatus: {
  ONGOING: 'ONGOING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type MeetingStatus = (typeof MeetingStatus)[keyof typeof MeetingStatus]


export const ResourceCategory: {
  DOCUMENT: 'DOCUMENT',
  VIDEO: 'VIDEO',
  IMAGE: 'IMAGE',
  OTHER: 'OTHER'
};

export type ResourceCategory = (typeof ResourceCategory)[keyof typeof ResourceCategory]

}

export type currenrStudylevel = $Enums.currenrStudylevel

export const currenrStudylevel: typeof $Enums.currenrStudylevel

export type CourseLevel = $Enums.CourseLevel

export const CourseLevel: typeof $Enums.CourseLevel

export type ChallengeType = $Enums.ChallengeType

export const ChallengeType: typeof $Enums.ChallengeType

export type EmploymentType = $Enums.EmploymentType

export const EmploymentType: typeof $Enums.EmploymentType

export type ConsultationType = $Enums.ConsultationType

export const ConsultationType: typeof $Enums.ConsultationType

export type ConsultationStatus = $Enums.ConsultationStatus

export const ConsultationStatus: typeof $Enums.ConsultationStatus

export type MeetingProvider = $Enums.MeetingProvider

export const MeetingProvider: typeof $Enums.MeetingProvider

export type MeetingStatus = $Enums.MeetingStatus

export const MeetingStatus: typeof $Enums.MeetingStatus

export type ResourceCategory = $Enums.ResourceCategory

export const ResourceCategory: typeof $Enums.ResourceCategory

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs>;

  /**
   * `prisma.userRoleMapping`: Exposes CRUD operations for the **UserRoleMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoleMappings
    * const userRoleMappings = await prisma.userRoleMapping.findMany()
    * ```
    */
  get userRoleMapping(): Prisma.UserRoleMappingDelegate<ExtArgs>;

  /**
   * `prisma.courses`: Exposes CRUD operations for the **Courses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.courses.findMany()
    * ```
    */
  get courses(): Prisma.CoursesDelegate<ExtArgs>;

  /**
   * `prisma.lessons`: Exposes CRUD operations for the **Lessons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lessons.findMany()
    * ```
    */
  get lessons(): Prisma.LessonsDelegate<ExtArgs>;

  /**
   * `prisma.courseUserMapper`: Exposes CRUD operations for the **CourseUserMapper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseUserMappers
    * const courseUserMappers = await prisma.courseUserMapper.findMany()
    * ```
    */
  get courseUserMapper(): Prisma.CourseUserMapperDelegate<ExtArgs>;

  /**
   * `prisma.contest`: Exposes CRUD operations for the **Contest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contests
    * const contests = await prisma.contest.findMany()
    * ```
    */
  get contest(): Prisma.ContestDelegate<ExtArgs>;

  /**
   * `prisma.contestQuestion`: Exposes CRUD operations for the **ContestQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContestQuestions
    * const contestQuestions = await prisma.contestQuestion.findMany()
    * ```
    */
  get contestQuestion(): Prisma.ContestQuestionDelegate<ExtArgs>;

  /**
   * `prisma.contestAttempt`: Exposes CRUD operations for the **ContestAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContestAttempts
    * const contestAttempts = await prisma.contestAttempt.findMany()
    * ```
    */
  get contestAttempt(): Prisma.ContestAttemptDelegate<ExtArgs>;

  /**
   * `prisma.contestAnswer`: Exposes CRUD operations for the **ContestAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContestAnswers
    * const contestAnswers = await prisma.contestAnswer.findMany()
    * ```
    */
  get contestAnswer(): Prisma.ContestAnswerDelegate<ExtArgs>;

  /**
   * `prisma.challenge`: Exposes CRUD operations for the **Challenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Challenges
    * const challenges = await prisma.challenge.findMany()
    * ```
    */
  get challenge(): Prisma.ChallengeDelegate<ExtArgs>;

  /**
   * `prisma.challengeAttempt`: Exposes CRUD operations for the **ChallengeAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeAttempts
    * const challengeAttempts = await prisma.challengeAttempt.findMany()
    * ```
    */
  get challengeAttempt(): Prisma.ChallengeAttemptDelegate<ExtArgs>;

  /**
   * `prisma.counselor`: Exposes CRUD operations for the **Counselor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Counselors
    * const counselors = await prisma.counselor.findMany()
    * ```
    */
  get counselor(): Prisma.CounselorDelegate<ExtArgs>;

  /**
   * `prisma.consultationRequest`: Exposes CRUD operations for the **ConsultationRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsultationRequests
    * const consultationRequests = await prisma.consultationRequest.findMany()
    * ```
    */
  get consultationRequest(): Prisma.ConsultationRequestDelegate<ExtArgs>;

  /**
   * `prisma.meeting`: Exposes CRUD operations for the **Meeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meetings
    * const meetings = await prisma.meeting.findMany()
    * ```
    */
  get meeting(): Prisma.MeetingDelegate<ExtArgs>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    roles: 'roles',
    UserRoleMapping: 'UserRoleMapping',
    Courses: 'Courses',
    Lessons: 'Lessons',
    CourseUserMapper: 'CourseUserMapper',
    Contest: 'Contest',
    ContestQuestion: 'ContestQuestion',
    ContestAttempt: 'ContestAttempt',
    ContestAnswer: 'ContestAnswer',
    Challenge: 'Challenge',
    ChallengeAttempt: 'ChallengeAttempt',
    Counselor: 'Counselor',
    ConsultationRequest: 'ConsultationRequest',
    Meeting: 'Meeting',
    Resource: 'Resource'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "roles" | "userRoleMapping" | "courses" | "lessons" | "courseUserMapper" | "contest" | "contestQuestion" | "contestAttempt" | "contestAnswer" | "challenge" | "challengeAttempt" | "counselor" | "consultationRequest" | "meeting" | "resource"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      UserRoleMapping: {
        payload: Prisma.$UserRoleMappingPayload<ExtArgs>
        fields: Prisma.UserRoleMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>
          }
          findFirst: {
            args: Prisma.UserRoleMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>
          }
          findMany: {
            args: Prisma.UserRoleMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>[]
          }
          create: {
            args: Prisma.UserRoleMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>
          }
          createMany: {
            args: Prisma.UserRoleMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>[]
          }
          delete: {
            args: Prisma.UserRoleMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>
          }
          update: {
            args: Prisma.UserRoleMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>
          }
          deleteMany: {
            args: Prisma.UserRoleMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleMappingPayload>
          }
          aggregate: {
            args: Prisma.UserRoleMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRoleMapping>
          }
          groupBy: {
            args: Prisma.UserRoleMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleMappingCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleMappingCountAggregateOutputType> | number
          }
        }
      }
      Courses: {
        payload: Prisma.$CoursesPayload<ExtArgs>
        fields: Prisma.CoursesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoursesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoursesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          findFirst: {
            args: Prisma.CoursesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoursesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          findMany: {
            args: Prisma.CoursesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>[]
          }
          create: {
            args: Prisma.CoursesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          createMany: {
            args: Prisma.CoursesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoursesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>[]
          }
          delete: {
            args: Prisma.CoursesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          update: {
            args: Prisma.CoursesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          deleteMany: {
            args: Prisma.CoursesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoursesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CoursesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          aggregate: {
            args: Prisma.CoursesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourses>
          }
          groupBy: {
            args: Prisma.CoursesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoursesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoursesCountArgs<ExtArgs>
            result: $Utils.Optional<CoursesCountAggregateOutputType> | number
          }
        }
      }
      Lessons: {
        payload: Prisma.$LessonsPayload<ExtArgs>
        fields: Prisma.LessonsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          findFirst: {
            args: Prisma.LessonsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          findMany: {
            args: Prisma.LessonsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>[]
          }
          create: {
            args: Prisma.LessonsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          createMany: {
            args: Prisma.LessonsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>[]
          }
          delete: {
            args: Prisma.LessonsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          update: {
            args: Prisma.LessonsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          deleteMany: {
            args: Prisma.LessonsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LessonsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          aggregate: {
            args: Prisma.LessonsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessons>
          }
          groupBy: {
            args: Prisma.LessonsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonsCountArgs<ExtArgs>
            result: $Utils.Optional<LessonsCountAggregateOutputType> | number
          }
        }
      }
      CourseUserMapper: {
        payload: Prisma.$CourseUserMapperPayload<ExtArgs>
        fields: Prisma.CourseUserMapperFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseUserMapperFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseUserMapperPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseUserMapperFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseUserMapperPayload>
          }
          findFirst: {
            args: Prisma.CourseUserMapperFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseUserMapperPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseUserMapperFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseUserMapperPayload>
          }
          findMany: {
            args: Prisma.CourseUserMapperFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseUserMapperPayload>[]
          }
          create: {
            args: Prisma.CourseUserMapperCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseUserMapperPayload>
          }
          createMany: {
            args: Prisma.CourseUserMapperCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseUserMapperCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseUserMapperPayload>[]
          }
          delete: {
            args: Prisma.CourseUserMapperDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseUserMapperPayload>
          }
          update: {
            args: Prisma.CourseUserMapperUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseUserMapperPayload>
          }
          deleteMany: {
            args: Prisma.CourseUserMapperDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUserMapperUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUserMapperUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseUserMapperPayload>
          }
          aggregate: {
            args: Prisma.CourseUserMapperAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseUserMapper>
          }
          groupBy: {
            args: Prisma.CourseUserMapperGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseUserMapperGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseUserMapperCountArgs<ExtArgs>
            result: $Utils.Optional<CourseUserMapperCountAggregateOutputType> | number
          }
        }
      }
      Contest: {
        payload: Prisma.$ContestPayload<ExtArgs>
        fields: Prisma.ContestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          findFirst: {
            args: Prisma.ContestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          findMany: {
            args: Prisma.ContestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>[]
          }
          create: {
            args: Prisma.ContestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          createMany: {
            args: Prisma.ContestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>[]
          }
          delete: {
            args: Prisma.ContestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          update: {
            args: Prisma.ContestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          deleteMany: {
            args: Prisma.ContestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          aggregate: {
            args: Prisma.ContestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContest>
          }
          groupBy: {
            args: Prisma.ContestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContestCountArgs<ExtArgs>
            result: $Utils.Optional<ContestCountAggregateOutputType> | number
          }
        }
      }
      ContestQuestion: {
        payload: Prisma.$ContestQuestionPayload<ExtArgs>
        fields: Prisma.ContestQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestQuestionPayload>
          }
          findFirst: {
            args: Prisma.ContestQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestQuestionPayload>
          }
          findMany: {
            args: Prisma.ContestQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestQuestionPayload>[]
          }
          create: {
            args: Prisma.ContestQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestQuestionPayload>
          }
          createMany: {
            args: Prisma.ContestQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContestQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestQuestionPayload>[]
          }
          delete: {
            args: Prisma.ContestQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestQuestionPayload>
          }
          update: {
            args: Prisma.ContestQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestQuestionPayload>
          }
          deleteMany: {
            args: Prisma.ContestQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestQuestionPayload>
          }
          aggregate: {
            args: Prisma.ContestQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContestQuestion>
          }
          groupBy: {
            args: Prisma.ContestQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContestQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<ContestQuestionCountAggregateOutputType> | number
          }
        }
      }
      ContestAttempt: {
        payload: Prisma.$ContestAttemptPayload<ExtArgs>
        fields: Prisma.ContestAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAttemptPayload>
          }
          findFirst: {
            args: Prisma.ContestAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAttemptPayload>
          }
          findMany: {
            args: Prisma.ContestAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAttemptPayload>[]
          }
          create: {
            args: Prisma.ContestAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAttemptPayload>
          }
          createMany: {
            args: Prisma.ContestAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContestAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAttemptPayload>[]
          }
          delete: {
            args: Prisma.ContestAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAttemptPayload>
          }
          update: {
            args: Prisma.ContestAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAttemptPayload>
          }
          deleteMany: {
            args: Prisma.ContestAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAttemptPayload>
          }
          aggregate: {
            args: Prisma.ContestAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContestAttempt>
          }
          groupBy: {
            args: Prisma.ContestAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContestAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<ContestAttemptCountAggregateOutputType> | number
          }
        }
      }
      ContestAnswer: {
        payload: Prisma.$ContestAnswerPayload<ExtArgs>
        fields: Prisma.ContestAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAnswerPayload>
          }
          findFirst: {
            args: Prisma.ContestAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAnswerPayload>
          }
          findMany: {
            args: Prisma.ContestAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAnswerPayload>[]
          }
          create: {
            args: Prisma.ContestAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAnswerPayload>
          }
          createMany: {
            args: Prisma.ContestAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContestAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAnswerPayload>[]
          }
          delete: {
            args: Prisma.ContestAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAnswerPayload>
          }
          update: {
            args: Prisma.ContestAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAnswerPayload>
          }
          deleteMany: {
            args: Prisma.ContestAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAnswerPayload>
          }
          aggregate: {
            args: Prisma.ContestAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContestAnswer>
          }
          groupBy: {
            args: Prisma.ContestAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContestAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<ContestAnswerCountAggregateOutputType> | number
          }
        }
      }
      Challenge: {
        payload: Prisma.$ChallengePayload<ExtArgs>
        fields: Prisma.ChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findFirst: {
            args: Prisma.ChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findMany: {
            args: Prisma.ChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          create: {
            args: Prisma.ChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          createMany: {
            args: Prisma.ChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          delete: {
            args: Prisma.ChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          update: {
            args: Prisma.ChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          aggregate: {
            args: Prisma.ChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallenge>
          }
          groupBy: {
            args: Prisma.ChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeCountAggregateOutputType> | number
          }
        }
      }
      ChallengeAttempt: {
        payload: Prisma.$ChallengeAttemptPayload<ExtArgs>
        fields: Prisma.ChallengeAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAttemptPayload>
          }
          findFirst: {
            args: Prisma.ChallengeAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAttemptPayload>
          }
          findMany: {
            args: Prisma.ChallengeAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAttemptPayload>[]
          }
          create: {
            args: Prisma.ChallengeAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAttemptPayload>
          }
          createMany: {
            args: Prisma.ChallengeAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAttemptPayload>[]
          }
          delete: {
            args: Prisma.ChallengeAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAttemptPayload>
          }
          update: {
            args: Prisma.ChallengeAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAttemptPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChallengeAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAttemptPayload>
          }
          aggregate: {
            args: Prisma.ChallengeAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeAttempt>
          }
          groupBy: {
            args: Prisma.ChallengeAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeAttemptCountAggregateOutputType> | number
          }
        }
      }
      Counselor: {
        payload: Prisma.$CounselorPayload<ExtArgs>
        fields: Prisma.CounselorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CounselorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounselorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CounselorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounselorPayload>
          }
          findFirst: {
            args: Prisma.CounselorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounselorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CounselorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounselorPayload>
          }
          findMany: {
            args: Prisma.CounselorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounselorPayload>[]
          }
          create: {
            args: Prisma.CounselorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounselorPayload>
          }
          createMany: {
            args: Prisma.CounselorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CounselorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounselorPayload>[]
          }
          delete: {
            args: Prisma.CounselorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounselorPayload>
          }
          update: {
            args: Prisma.CounselorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounselorPayload>
          }
          deleteMany: {
            args: Prisma.CounselorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CounselorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CounselorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounselorPayload>
          }
          aggregate: {
            args: Prisma.CounselorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCounselor>
          }
          groupBy: {
            args: Prisma.CounselorGroupByArgs<ExtArgs>
            result: $Utils.Optional<CounselorGroupByOutputType>[]
          }
          count: {
            args: Prisma.CounselorCountArgs<ExtArgs>
            result: $Utils.Optional<CounselorCountAggregateOutputType> | number
          }
        }
      }
      ConsultationRequest: {
        payload: Prisma.$ConsultationRequestPayload<ExtArgs>
        fields: Prisma.ConsultationRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsultationRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsultationRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationRequestPayload>
          }
          findFirst: {
            args: Prisma.ConsultationRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsultationRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationRequestPayload>
          }
          findMany: {
            args: Prisma.ConsultationRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationRequestPayload>[]
          }
          create: {
            args: Prisma.ConsultationRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationRequestPayload>
          }
          createMany: {
            args: Prisma.ConsultationRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsultationRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationRequestPayload>[]
          }
          delete: {
            args: Prisma.ConsultationRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationRequestPayload>
          }
          update: {
            args: Prisma.ConsultationRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationRequestPayload>
          }
          deleteMany: {
            args: Prisma.ConsultationRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsultationRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConsultationRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationRequestPayload>
          }
          aggregate: {
            args: Prisma.ConsultationRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultationRequest>
          }
          groupBy: {
            args: Prisma.ConsultationRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultationRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsultationRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultationRequestCountAggregateOutputType> | number
          }
        }
      }
      Meeting: {
        payload: Prisma.$MeetingPayload<ExtArgs>
        fields: Prisma.MeetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findFirst: {
            args: Prisma.MeetingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findMany: {
            args: Prisma.MeetingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          create: {
            args: Prisma.MeetingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          createMany: {
            args: Prisma.MeetingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeetingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          delete: {
            args: Prisma.MeetingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          update: {
            args: Prisma.MeetingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          deleteMany: {
            args: Prisma.MeetingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MeetingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          aggregate: {
            args: Prisma.MeetingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeeting>
          }
          groupBy: {
            args: Prisma.MeetingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    userRoleMappings: number
    ContestAttempt: number
    ChallengeAttempt: number
    consultationRequests: number
    meetings: number
    enrolledCourses: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoleMappings?: boolean | UserCountOutputTypeCountUserRoleMappingsArgs
    ContestAttempt?: boolean | UserCountOutputTypeCountContestAttemptArgs
    ChallengeAttempt?: boolean | UserCountOutputTypeCountChallengeAttemptArgs
    consultationRequests?: boolean | UserCountOutputTypeCountConsultationRequestsArgs
    meetings?: boolean | UserCountOutputTypeCountMeetingsArgs
    enrolledCourses?: boolean | UserCountOutputTypeCountEnrolledCoursesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRoleMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleMappingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContestAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChallengeAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConsultationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnrolledCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseUserMapperWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    userRoleMappings: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoleMappings?: boolean | RolesCountOutputTypeCountUserRoleMappingsArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUserRoleMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleMappingWhereInput
  }


  /**
   * Count Type CoursesCountOutputType
   */

  export type CoursesCountOutputType = {
    lessons: number
    enrolledUsers: number
  }

  export type CoursesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | CoursesCountOutputTypeCountLessonsArgs
    enrolledUsers?: boolean | CoursesCountOutputTypeCountEnrolledUsersArgs
  }

  // Custom InputTypes
  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursesCountOutputType
     */
    select?: CoursesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonsWhereInput
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountEnrolledUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseUserMapperWhereInput
  }


  /**
   * Count Type ContestCountOutputType
   */

  export type ContestCountOutputType = {
    ContestQuestion: number
    ContestAttempt: number
  }

  export type ContestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ContestQuestion?: boolean | ContestCountOutputTypeCountContestQuestionArgs
    ContestAttempt?: boolean | ContestCountOutputTypeCountContestAttemptArgs
  }

  // Custom InputTypes
  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestCountOutputType
     */
    select?: ContestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountContestQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestQuestionWhereInput
  }

  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountContestAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestAttemptWhereInput
  }


  /**
   * Count Type ContestQuestionCountOutputType
   */

  export type ContestQuestionCountOutputType = {
    contestanswer: number
  }

  export type ContestQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contestanswer?: boolean | ContestQuestionCountOutputTypeCountContestanswerArgs
  }

  // Custom InputTypes
  /**
   * ContestQuestionCountOutputType without action
   */
  export type ContestQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestQuestionCountOutputType
     */
    select?: ContestQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContestQuestionCountOutputType without action
   */
  export type ContestQuestionCountOutputTypeCountContestanswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestAnswerWhereInput
  }


  /**
   * Count Type ContestAttemptCountOutputType
   */

  export type ContestAttemptCountOutputType = {
    ContestAnswer: number
  }

  export type ContestAttemptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ContestAnswer?: boolean | ContestAttemptCountOutputTypeCountContestAnswerArgs
  }

  // Custom InputTypes
  /**
   * ContestAttemptCountOutputType without action
   */
  export type ContestAttemptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAttemptCountOutputType
     */
    select?: ContestAttemptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContestAttemptCountOutputType without action
   */
  export type ContestAttemptCountOutputTypeCountContestAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestAnswerWhereInput
  }


  /**
   * Count Type ChallengeCountOutputType
   */

  export type ChallengeCountOutputType = {
    ChallengeAttempt: number
  }

  export type ChallengeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ChallengeAttempt?: boolean | ChallengeCountOutputTypeCountChallengeAttemptArgs
  }

  // Custom InputTypes
  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeCountOutputType
     */
    select?: ChallengeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountChallengeAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeAttemptWhereInput
  }


  /**
   * Count Type CounselorCountOutputType
   */

  export type CounselorCountOutputType = {
    consultationRequests: number
    meetings: number
  }

  export type CounselorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultationRequests?: boolean | CounselorCountOutputTypeCountConsultationRequestsArgs
    meetings?: boolean | CounselorCountOutputTypeCountMeetingsArgs
  }

  // Custom InputTypes
  /**
   * CounselorCountOutputType without action
   */
  export type CounselorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounselorCountOutputType
     */
    select?: CounselorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CounselorCountOutputType without action
   */
  export type CounselorCountOutputTypeCountConsultationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationRequestWhereInput
  }

  /**
   * CounselorCountOutputType without action
   */
  export type CounselorCountOutputTypeCountMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    phoneNo: string | null
    address: string | null
    dateOfBirth: Date | null
    gender: string | null
    state: string | null
    country: string | null
    profileImage: string | null
    currenrStudyLevel: $Enums.currenrStudylevel | null
    email: string | null
    username: string | null
    password: string | null
    isActive: boolean | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    phoneNo: string | null
    address: string | null
    dateOfBirth: Date | null
    gender: string | null
    state: string | null
    country: string | null
    profileImage: string | null
    currenrStudyLevel: $Enums.currenrStudylevel | null
    email: string | null
    username: string | null
    password: string | null
    isActive: boolean | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    phoneNo: number
    address: number
    dateOfBirth: number
    gender: number
    state: number
    country: number
    profileImage: number
    currenrStudyLevel: number
    email: number
    username: number
    password: number
    isActive: number
    isDeleted: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phoneNo?: true
    address?: true
    dateOfBirth?: true
    gender?: true
    state?: true
    country?: true
    profileImage?: true
    currenrStudyLevel?: true
    email?: true
    username?: true
    password?: true
    isActive?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phoneNo?: true
    address?: true
    dateOfBirth?: true
    gender?: true
    state?: true
    country?: true
    profileImage?: true
    currenrStudyLevel?: true
    email?: true
    username?: true
    password?: true
    isActive?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phoneNo?: true
    address?: true
    dateOfBirth?: true
    gender?: true
    state?: true
    country?: true
    profileImage?: true
    currenrStudyLevel?: true
    email?: true
    username?: true
    password?: true
    isActive?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    firstName: string | null
    lastName: string | null
    phoneNo: string | null
    address: string | null
    dateOfBirth: Date | null
    gender: string | null
    state: string | null
    country: string | null
    profileImage: string | null
    currenrStudyLevel: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive: boolean
    isDeleted: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNo?: boolean
    address?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    state?: boolean
    country?: boolean
    profileImage?: boolean
    currenrStudyLevel?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userRoleMappings?: boolean | User$userRoleMappingsArgs<ExtArgs>
    ContestAttempt?: boolean | User$ContestAttemptArgs<ExtArgs>
    ChallengeAttempt?: boolean | User$ChallengeAttemptArgs<ExtArgs>
    consultationRequests?: boolean | User$consultationRequestsArgs<ExtArgs>
    meetings?: boolean | User$meetingsArgs<ExtArgs>
    enrolledCourses?: boolean | User$enrolledCoursesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNo?: boolean
    address?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    state?: boolean
    country?: boolean
    profileImage?: boolean
    currenrStudyLevel?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNo?: boolean
    address?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    state?: boolean
    country?: boolean
    profileImage?: boolean
    currenrStudyLevel?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoleMappings?: boolean | User$userRoleMappingsArgs<ExtArgs>
    ContestAttempt?: boolean | User$ContestAttemptArgs<ExtArgs>
    ChallengeAttempt?: boolean | User$ChallengeAttemptArgs<ExtArgs>
    consultationRequests?: boolean | User$consultationRequestsArgs<ExtArgs>
    meetings?: boolean | User$meetingsArgs<ExtArgs>
    enrolledCourses?: boolean | User$enrolledCoursesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      userRoleMappings: Prisma.$UserRoleMappingPayload<ExtArgs>[]
      ContestAttempt: Prisma.$ContestAttemptPayload<ExtArgs>[]
      ChallengeAttempt: Prisma.$ChallengeAttemptPayload<ExtArgs>[]
      consultationRequests: Prisma.$ConsultationRequestPayload<ExtArgs>[]
      meetings: Prisma.$MeetingPayload<ExtArgs>[]
      enrolledCourses: Prisma.$CourseUserMapperPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstName: string | null
      lastName: string | null
      phoneNo: string | null
      address: string | null
      dateOfBirth: Date | null
      gender: string | null
      state: string | null
      country: string | null
      profileImage: string | null
      currenrStudyLevel: $Enums.currenrStudylevel | null
      email: string
      username: string
      password: string
      isActive: boolean
      isDeleted: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoleMappings<T extends User$userRoleMappingsArgs<ExtArgs> = {}>(args?: Subset<T, User$userRoleMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "findMany"> | Null>
    ContestAttempt<T extends User$ContestAttemptArgs<ExtArgs> = {}>(args?: Subset<T, User$ContestAttemptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    ChallengeAttempt<T extends User$ChallengeAttemptArgs<ExtArgs> = {}>(args?: Subset<T, User$ChallengeAttemptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    consultationRequests<T extends User$consultationRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$consultationRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationRequestPayload<ExtArgs>, T, "findMany"> | Null>
    meetings<T extends User$meetingsArgs<ExtArgs> = {}>(args?: Subset<T, User$meetingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany"> | Null>
    enrolledCourses<T extends User$enrolledCoursesArgs<ExtArgs> = {}>(args?: Subset<T, User$enrolledCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseUserMapperPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phoneNo: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly gender: FieldRef<"User", 'String'>
    readonly state: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly currenrStudyLevel: FieldRef<"User", 'currenrStudylevel'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly isDeleted: FieldRef<"User", 'Boolean'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.userRoleMappings
   */
  export type User$userRoleMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    where?: UserRoleMappingWhereInput
    orderBy?: UserRoleMappingOrderByWithRelationInput | UserRoleMappingOrderByWithRelationInput[]
    cursor?: UserRoleMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleMappingScalarFieldEnum | UserRoleMappingScalarFieldEnum[]
  }

  /**
   * User.ContestAttempt
   */
  export type User$ContestAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAttempt
     */
    select?: ContestAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAttemptInclude<ExtArgs> | null
    where?: ContestAttemptWhereInput
    orderBy?: ContestAttemptOrderByWithRelationInput | ContestAttemptOrderByWithRelationInput[]
    cursor?: ContestAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestAttemptScalarFieldEnum | ContestAttemptScalarFieldEnum[]
  }

  /**
   * User.ChallengeAttempt
   */
  export type User$ChallengeAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAttempt
     */
    select?: ChallengeAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAttemptInclude<ExtArgs> | null
    where?: ChallengeAttemptWhereInput
    orderBy?: ChallengeAttemptOrderByWithRelationInput | ChallengeAttemptOrderByWithRelationInput[]
    cursor?: ChallengeAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeAttemptScalarFieldEnum | ChallengeAttemptScalarFieldEnum[]
  }

  /**
   * User.consultationRequests
   */
  export type User$consultationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationRequest
     */
    select?: ConsultationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationRequestInclude<ExtArgs> | null
    where?: ConsultationRequestWhereInput
    orderBy?: ConsultationRequestOrderByWithRelationInput | ConsultationRequestOrderByWithRelationInput[]
    cursor?: ConsultationRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultationRequestScalarFieldEnum | ConsultationRequestScalarFieldEnum[]
  }

  /**
   * User.meetings
   */
  export type User$meetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    cursor?: MeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * User.enrolledCourses
   */
  export type User$enrolledCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseUserMapper
     */
    select?: CourseUserMapperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseUserMapperInclude<ExtArgs> | null
    where?: CourseUserMapperWhereInput
    orderBy?: CourseUserMapperOrderByWithRelationInput | CourseUserMapperOrderByWithRelationInput[]
    cursor?: CourseUserMapperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseUserMapperScalarFieldEnum | CourseUserMapperScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userRoleMappings?: boolean | roles$userRoleMappingsArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoleMappings?: boolean | roles$userRoleMappingsArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type rolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      userRoleMappings: Prisma.$UserRoleMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {rolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoleMappings<T extends roles$userRoleMappingsArgs<ExtArgs> = {}>(args?: Subset<T, roles$userRoleMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */ 
  interface rolesFieldRefs {
    readonly id: FieldRef<"roles", 'Int'>
    readonly name: FieldRef<"roles", 'String'>
    readonly description: FieldRef<"roles", 'String'>
    readonly createdAt: FieldRef<"roles", 'DateTime'>
    readonly updatedAt: FieldRef<"roles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles createManyAndReturn
   */
  export type rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
  }

  /**
   * roles.userRoleMappings
   */
  export type roles$userRoleMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    where?: UserRoleMappingWhereInput
    orderBy?: UserRoleMappingOrderByWithRelationInput | UserRoleMappingOrderByWithRelationInput[]
    cursor?: UserRoleMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleMappingScalarFieldEnum | UserRoleMappingScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model UserRoleMapping
   */

  export type AggregateUserRoleMapping = {
    _count: UserRoleMappingCountAggregateOutputType | null
    _avg: UserRoleMappingAvgAggregateOutputType | null
    _sum: UserRoleMappingSumAggregateOutputType | null
    _min: UserRoleMappingMinAggregateOutputType | null
    _max: UserRoleMappingMaxAggregateOutputType | null
  }

  export type UserRoleMappingAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    assignedBy: number | null
  }

  export type UserRoleMappingSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    assignedBy: number | null
  }

  export type UserRoleMappingMinAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    assignedAt: Date | null
    assignedBy: number | null
  }

  export type UserRoleMappingMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    assignedAt: Date | null
    assignedBy: number | null
  }

  export type UserRoleMappingCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    assignedAt: number
    assignedBy: number
    _all: number
  }


  export type UserRoleMappingAvgAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedBy?: true
  }

  export type UserRoleMappingSumAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedBy?: true
  }

  export type UserRoleMappingMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type UserRoleMappingMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type UserRoleMappingCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedAt?: true
    assignedBy?: true
    _all?: true
  }

  export type UserRoleMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoleMapping to aggregate.
     */
    where?: UserRoleMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleMappings to fetch.
     */
    orderBy?: UserRoleMappingOrderByWithRelationInput | UserRoleMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoleMappings
    **/
    _count?: true | UserRoleMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleMappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleMappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMappingMaxAggregateInputType
  }

  export type GetUserRoleMappingAggregateType<T extends UserRoleMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRoleMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRoleMapping[P]>
      : GetScalarType<T[P], AggregateUserRoleMapping[P]>
  }




  export type UserRoleMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleMappingWhereInput
    orderBy?: UserRoleMappingOrderByWithAggregationInput | UserRoleMappingOrderByWithAggregationInput[]
    by: UserRoleMappingScalarFieldEnum[] | UserRoleMappingScalarFieldEnum
    having?: UserRoleMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleMappingCountAggregateInputType | true
    _avg?: UserRoleMappingAvgAggregateInputType
    _sum?: UserRoleMappingSumAggregateInputType
    _min?: UserRoleMappingMinAggregateInputType
    _max?: UserRoleMappingMaxAggregateInputType
  }

  export type UserRoleMappingGroupByOutputType = {
    id: number
    userId: number
    roleId: number
    assignedAt: Date
    assignedBy: number | null
    _count: UserRoleMappingCountAggregateOutputType | null
    _avg: UserRoleMappingAvgAggregateOutputType | null
    _sum: UserRoleMappingSumAggregateOutputType | null
    _min: UserRoleMappingMinAggregateOutputType | null
    _max: UserRoleMappingMaxAggregateOutputType | null
  }

  type GetUserRoleMappingGroupByPayload<T extends UserRoleMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleMappingGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleMappingGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRoleMapping"]>

  export type UserRoleMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRoleMapping"]>

  export type UserRoleMappingSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }

  export type UserRoleMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | rolesDefaultArgs<ExtArgs>
  }
  export type UserRoleMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | rolesDefaultArgs<ExtArgs>
  }

  export type $UserRoleMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRoleMapping"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      roleId: number
      assignedAt: Date
      assignedBy: number | null
    }, ExtArgs["result"]["userRoleMapping"]>
    composites: {}
  }

  type UserRoleMappingGetPayload<S extends boolean | null | undefined | UserRoleMappingDefaultArgs> = $Result.GetResult<Prisma.$UserRoleMappingPayload, S>

  type UserRoleMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleMappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleMappingCountAggregateInputType | true
    }

  export interface UserRoleMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRoleMapping'], meta: { name: 'UserRoleMapping' } }
    /**
     * Find zero or one UserRoleMapping that matches the filter.
     * @param {UserRoleMappingFindUniqueArgs} args - Arguments to find a UserRoleMapping
     * @example
     * // Get one UserRoleMapping
     * const userRoleMapping = await prisma.userRoleMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleMappingFindUniqueArgs>(args: SelectSubset<T, UserRoleMappingFindUniqueArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRoleMapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleMappingFindUniqueOrThrowArgs} args - Arguments to find a UserRoleMapping
     * @example
     * // Get one UserRoleMapping
     * const userRoleMapping = await prisma.userRoleMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRoleMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleMappingFindFirstArgs} args - Arguments to find a UserRoleMapping
     * @example
     * // Get one UserRoleMapping
     * const userRoleMapping = await prisma.userRoleMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleMappingFindFirstArgs>(args?: SelectSubset<T, UserRoleMappingFindFirstArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRoleMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleMappingFindFirstOrThrowArgs} args - Arguments to find a UserRoleMapping
     * @example
     * // Get one UserRoleMapping
     * const userRoleMapping = await prisma.userRoleMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoleMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoleMappings
     * const userRoleMappings = await prisma.userRoleMapping.findMany()
     * 
     * // Get first 10 UserRoleMappings
     * const userRoleMappings = await prisma.userRoleMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleMappingWithIdOnly = await prisma.userRoleMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleMappingFindManyArgs>(args?: SelectSubset<T, UserRoleMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRoleMapping.
     * @param {UserRoleMappingCreateArgs} args - Arguments to create a UserRoleMapping.
     * @example
     * // Create one UserRoleMapping
     * const UserRoleMapping = await prisma.userRoleMapping.create({
     *   data: {
     *     // ... data to create a UserRoleMapping
     *   }
     * })
     * 
     */
    create<T extends UserRoleMappingCreateArgs>(args: SelectSubset<T, UserRoleMappingCreateArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoleMappings.
     * @param {UserRoleMappingCreateManyArgs} args - Arguments to create many UserRoleMappings.
     * @example
     * // Create many UserRoleMappings
     * const userRoleMapping = await prisma.userRoleMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleMappingCreateManyArgs>(args?: SelectSubset<T, UserRoleMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoleMappings and returns the data saved in the database.
     * @param {UserRoleMappingCreateManyAndReturnArgs} args - Arguments to create many UserRoleMappings.
     * @example
     * // Create many UserRoleMappings
     * const userRoleMapping = await prisma.userRoleMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoleMappings and only return the `id`
     * const userRoleMappingWithIdOnly = await prisma.userRoleMapping.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserRoleMapping.
     * @param {UserRoleMappingDeleteArgs} args - Arguments to delete one UserRoleMapping.
     * @example
     * // Delete one UserRoleMapping
     * const UserRoleMapping = await prisma.userRoleMapping.delete({
     *   where: {
     *     // ... filter to delete one UserRoleMapping
     *   }
     * })
     * 
     */
    delete<T extends UserRoleMappingDeleteArgs>(args: SelectSubset<T, UserRoleMappingDeleteArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRoleMapping.
     * @param {UserRoleMappingUpdateArgs} args - Arguments to update one UserRoleMapping.
     * @example
     * // Update one UserRoleMapping
     * const userRoleMapping = await prisma.userRoleMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleMappingUpdateArgs>(args: SelectSubset<T, UserRoleMappingUpdateArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoleMappings.
     * @param {UserRoleMappingDeleteManyArgs} args - Arguments to filter UserRoleMappings to delete.
     * @example
     * // Delete a few UserRoleMappings
     * const { count } = await prisma.userRoleMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleMappingDeleteManyArgs>(args?: SelectSubset<T, UserRoleMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoleMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoleMappings
     * const userRoleMapping = await prisma.userRoleMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleMappingUpdateManyArgs>(args: SelectSubset<T, UserRoleMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRoleMapping.
     * @param {UserRoleMappingUpsertArgs} args - Arguments to update or create a UserRoleMapping.
     * @example
     * // Update or create a UserRoleMapping
     * const userRoleMapping = await prisma.userRoleMapping.upsert({
     *   create: {
     *     // ... data to create a UserRoleMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRoleMapping we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleMappingUpsertArgs>(args: SelectSubset<T, UserRoleMappingUpsertArgs<ExtArgs>>): Prisma__UserRoleMappingClient<$Result.GetResult<Prisma.$UserRoleMappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoleMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleMappingCountArgs} args - Arguments to filter UserRoleMappings to count.
     * @example
     * // Count the number of UserRoleMappings
     * const count = await prisma.userRoleMapping.count({
     *   where: {
     *     // ... the filter for the UserRoleMappings we want to count
     *   }
     * })
    **/
    count<T extends UserRoleMappingCountArgs>(
      args?: Subset<T, UserRoleMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRoleMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleMappingAggregateArgs>(args: Subset<T, UserRoleMappingAggregateArgs>): Prisma.PrismaPromise<GetUserRoleMappingAggregateType<T>>

    /**
     * Group by UserRoleMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleMappingGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRoleMapping model
   */
  readonly fields: UserRoleMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRoleMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRoleMapping model
   */ 
  interface UserRoleMappingFieldRefs {
    readonly id: FieldRef<"UserRoleMapping", 'Int'>
    readonly userId: FieldRef<"UserRoleMapping", 'Int'>
    readonly roleId: FieldRef<"UserRoleMapping", 'Int'>
    readonly assignedAt: FieldRef<"UserRoleMapping", 'DateTime'>
    readonly assignedBy: FieldRef<"UserRoleMapping", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserRoleMapping findUnique
   */
  export type UserRoleMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleMapping to fetch.
     */
    where: UserRoleMappingWhereUniqueInput
  }

  /**
   * UserRoleMapping findUniqueOrThrow
   */
  export type UserRoleMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleMapping to fetch.
     */
    where: UserRoleMappingWhereUniqueInput
  }

  /**
   * UserRoleMapping findFirst
   */
  export type UserRoleMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleMapping to fetch.
     */
    where?: UserRoleMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleMappings to fetch.
     */
    orderBy?: UserRoleMappingOrderByWithRelationInput | UserRoleMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoleMappings.
     */
    cursor?: UserRoleMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoleMappings.
     */
    distinct?: UserRoleMappingScalarFieldEnum | UserRoleMappingScalarFieldEnum[]
  }

  /**
   * UserRoleMapping findFirstOrThrow
   */
  export type UserRoleMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleMapping to fetch.
     */
    where?: UserRoleMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleMappings to fetch.
     */
    orderBy?: UserRoleMappingOrderByWithRelationInput | UserRoleMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoleMappings.
     */
    cursor?: UserRoleMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoleMappings.
     */
    distinct?: UserRoleMappingScalarFieldEnum | UserRoleMappingScalarFieldEnum[]
  }

  /**
   * UserRoleMapping findMany
   */
  export type UserRoleMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleMappings to fetch.
     */
    where?: UserRoleMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleMappings to fetch.
     */
    orderBy?: UserRoleMappingOrderByWithRelationInput | UserRoleMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoleMappings.
     */
    cursor?: UserRoleMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleMappings.
     */
    skip?: number
    distinct?: UserRoleMappingScalarFieldEnum | UserRoleMappingScalarFieldEnum[]
  }

  /**
   * UserRoleMapping create
   */
  export type UserRoleMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRoleMapping.
     */
    data: XOR<UserRoleMappingCreateInput, UserRoleMappingUncheckedCreateInput>
  }

  /**
   * UserRoleMapping createMany
   */
  export type UserRoleMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoleMappings.
     */
    data: UserRoleMappingCreateManyInput | UserRoleMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRoleMapping createManyAndReturn
   */
  export type UserRoleMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserRoleMappings.
     */
    data: UserRoleMappingCreateManyInput | UserRoleMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRoleMapping update
   */
  export type UserRoleMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRoleMapping.
     */
    data: XOR<UserRoleMappingUpdateInput, UserRoleMappingUncheckedUpdateInput>
    /**
     * Choose, which UserRoleMapping to update.
     */
    where: UserRoleMappingWhereUniqueInput
  }

  /**
   * UserRoleMapping updateMany
   */
  export type UserRoleMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoleMappings.
     */
    data: XOR<UserRoleMappingUpdateManyMutationInput, UserRoleMappingUncheckedUpdateManyInput>
    /**
     * Filter which UserRoleMappings to update
     */
    where?: UserRoleMappingWhereInput
  }

  /**
   * UserRoleMapping upsert
   */
  export type UserRoleMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRoleMapping to update in case it exists.
     */
    where: UserRoleMappingWhereUniqueInput
    /**
     * In case the UserRoleMapping found by the `where` argument doesn't exist, create a new UserRoleMapping with this data.
     */
    create: XOR<UserRoleMappingCreateInput, UserRoleMappingUncheckedCreateInput>
    /**
     * In case the UserRoleMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleMappingUpdateInput, UserRoleMappingUncheckedUpdateInput>
  }

  /**
   * UserRoleMapping delete
   */
  export type UserRoleMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
    /**
     * Filter which UserRoleMapping to delete.
     */
    where: UserRoleMappingWhereUniqueInput
  }

  /**
   * UserRoleMapping deleteMany
   */
  export type UserRoleMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoleMappings to delete
     */
    where?: UserRoleMappingWhereInput
  }

  /**
   * UserRoleMapping without action
   */
  export type UserRoleMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleMapping
     */
    select?: UserRoleMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleMappingInclude<ExtArgs> | null
  }


  /**
   * Model Courses
   */

  export type AggregateCourses = {
    _count: CoursesCountAggregateOutputType | null
    _avg: CoursesAvgAggregateOutputType | null
    _sum: CoursesSumAggregateOutputType | null
    _min: CoursesMinAggregateOutputType | null
    _max: CoursesMaxAggregateOutputType | null
  }

  export type CoursesAvgAggregateOutputType = {
    id: number | null
    price: number | null
    createdBy: number | null
  }

  export type CoursesSumAggregateOutputType = {
    id: number | null
    price: number | null
    createdBy: number | null
  }

  export type CoursesMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    price: number | null
    thumbnailUrl: string | null
    instructor: string | null
    duration: string | null
    level: $Enums.CourseLevel | null
    category: string | null
    language: string | null
    isPublished: boolean | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type CoursesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    price: number | null
    thumbnailUrl: string | null
    instructor: string | null
    duration: string | null
    level: $Enums.CourseLevel | null
    category: string | null
    language: string | null
    isPublished: boolean | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type CoursesCountAggregateOutputType = {
    id: number
    title: number
    description: number
    price: number
    thumbnailUrl: number
    instructor: number
    duration: number
    level: number
    category: number
    language: number
    isPublished: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type CoursesAvgAggregateInputType = {
    id?: true
    price?: true
    createdBy?: true
  }

  export type CoursesSumAggregateInputType = {
    id?: true
    price?: true
    createdBy?: true
  }

  export type CoursesMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    thumbnailUrl?: true
    instructor?: true
    duration?: true
    level?: true
    category?: true
    language?: true
    isPublished?: true
    createdBy?: true
    createdAt?: true
  }

  export type CoursesMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    thumbnailUrl?: true
    instructor?: true
    duration?: true
    level?: true
    category?: true
    language?: true
    isPublished?: true
    createdBy?: true
    createdAt?: true
  }

  export type CoursesCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    thumbnailUrl?: true
    instructor?: true
    duration?: true
    level?: true
    category?: true
    language?: true
    isPublished?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type CoursesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to aggregate.
     */
    where?: CoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CoursesOrderByWithRelationInput | CoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CoursesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoursesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoursesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoursesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoursesMaxAggregateInputType
  }

  export type GetCoursesAggregateType<T extends CoursesAggregateArgs> = {
        [P in keyof T & keyof AggregateCourses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourses[P]>
      : GetScalarType<T[P], AggregateCourses[P]>
  }




  export type CoursesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursesWhereInput
    orderBy?: CoursesOrderByWithAggregationInput | CoursesOrderByWithAggregationInput[]
    by: CoursesScalarFieldEnum[] | CoursesScalarFieldEnum
    having?: CoursesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoursesCountAggregateInputType | true
    _avg?: CoursesAvgAggregateInputType
    _sum?: CoursesSumAggregateInputType
    _min?: CoursesMinAggregateInputType
    _max?: CoursesMaxAggregateInputType
  }

  export type CoursesGroupByOutputType = {
    id: number
    title: string
    description: string | null
    price: number
    thumbnailUrl: string | null
    instructor: string | null
    duration: string | null
    level: $Enums.CourseLevel
    category: string | null
    language: string | null
    isPublished: boolean
    createdBy: number | null
    createdAt: Date | null
    _count: CoursesCountAggregateOutputType | null
    _avg: CoursesAvgAggregateOutputType | null
    _sum: CoursesSumAggregateOutputType | null
    _min: CoursesMinAggregateOutputType | null
    _max: CoursesMaxAggregateOutputType | null
  }

  type GetCoursesGroupByPayload<T extends CoursesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoursesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoursesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoursesGroupByOutputType[P]>
            : GetScalarType<T[P], CoursesGroupByOutputType[P]>
        }
      >
    >


  export type CoursesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    thumbnailUrl?: boolean
    instructor?: boolean
    duration?: boolean
    level?: boolean
    category?: boolean
    language?: boolean
    isPublished?: boolean
    createdBy?: boolean
    createdAt?: boolean
    lessons?: boolean | Courses$lessonsArgs<ExtArgs>
    enrolledUsers?: boolean | Courses$enrolledUsersArgs<ExtArgs>
    _count?: boolean | CoursesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courses"]>

  export type CoursesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    thumbnailUrl?: boolean
    instructor?: boolean
    duration?: boolean
    level?: boolean
    category?: boolean
    language?: boolean
    isPublished?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["courses"]>

  export type CoursesSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    thumbnailUrl?: boolean
    instructor?: boolean
    duration?: boolean
    level?: boolean
    category?: boolean
    language?: boolean
    isPublished?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type CoursesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | Courses$lessonsArgs<ExtArgs>
    enrolledUsers?: boolean | Courses$enrolledUsersArgs<ExtArgs>
    _count?: boolean | CoursesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CoursesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CoursesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Courses"
    objects: {
      lessons: Prisma.$LessonsPayload<ExtArgs>[]
      enrolledUsers: Prisma.$CourseUserMapperPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      price: number
      thumbnailUrl: string | null
      instructor: string | null
      duration: string | null
      level: $Enums.CourseLevel
      category: string | null
      language: string | null
      isPublished: boolean
      createdBy: number | null
      createdAt: Date | null
    }, ExtArgs["result"]["courses"]>
    composites: {}
  }

  type CoursesGetPayload<S extends boolean | null | undefined | CoursesDefaultArgs> = $Result.GetResult<Prisma.$CoursesPayload, S>

  type CoursesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoursesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoursesCountAggregateInputType | true
    }

  export interface CoursesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Courses'], meta: { name: 'Courses' } }
    /**
     * Find zero or one Courses that matches the filter.
     * @param {CoursesFindUniqueArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoursesFindUniqueArgs>(args: SelectSubset<T, CoursesFindUniqueArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Courses that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CoursesFindUniqueOrThrowArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoursesFindUniqueOrThrowArgs>(args: SelectSubset<T, CoursesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesFindFirstArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoursesFindFirstArgs>(args?: SelectSubset<T, CoursesFindFirstArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Courses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesFindFirstOrThrowArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoursesFindFirstOrThrowArgs>(args?: SelectSubset<T, CoursesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.courses.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.courses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coursesWithIdOnly = await prisma.courses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoursesFindManyArgs>(args?: SelectSubset<T, CoursesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Courses.
     * @param {CoursesCreateArgs} args - Arguments to create a Courses.
     * @example
     * // Create one Courses
     * const Courses = await prisma.courses.create({
     *   data: {
     *     // ... data to create a Courses
     *   }
     * })
     * 
     */
    create<T extends CoursesCreateArgs>(args: SelectSubset<T, CoursesCreateArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {CoursesCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const courses = await prisma.courses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoursesCreateManyArgs>(args?: SelectSubset<T, CoursesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CoursesCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const courses = await prisma.courses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const coursesWithIdOnly = await prisma.courses.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoursesCreateManyAndReturnArgs>(args?: SelectSubset<T, CoursesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Courses.
     * @param {CoursesDeleteArgs} args - Arguments to delete one Courses.
     * @example
     * // Delete one Courses
     * const Courses = await prisma.courses.delete({
     *   where: {
     *     // ... filter to delete one Courses
     *   }
     * })
     * 
     */
    delete<T extends CoursesDeleteArgs>(args: SelectSubset<T, CoursesDeleteArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Courses.
     * @param {CoursesUpdateArgs} args - Arguments to update one Courses.
     * @example
     * // Update one Courses
     * const courses = await prisma.courses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoursesUpdateArgs>(args: SelectSubset<T, CoursesUpdateArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CoursesDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.courses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoursesDeleteManyArgs>(args?: SelectSubset<T, CoursesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const courses = await prisma.courses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoursesUpdateManyArgs>(args: SelectSubset<T, CoursesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Courses.
     * @param {CoursesUpsertArgs} args - Arguments to update or create a Courses.
     * @example
     * // Update or create a Courses
     * const courses = await prisma.courses.upsert({
     *   create: {
     *     // ... data to create a Courses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Courses we want to update
     *   }
     * })
     */
    upsert<T extends CoursesUpsertArgs>(args: SelectSubset<T, CoursesUpsertArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.courses.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CoursesCountArgs>(
      args?: Subset<T, CoursesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoursesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoursesAggregateArgs>(args: Subset<T, CoursesAggregateArgs>): Prisma.PrismaPromise<GetCoursesAggregateType<T>>

    /**
     * Group by Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoursesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoursesGroupByArgs['orderBy'] }
        : { orderBy?: CoursesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoursesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoursesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Courses model
   */
  readonly fields: CoursesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Courses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoursesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lessons<T extends Courses$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Courses$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findMany"> | Null>
    enrolledUsers<T extends Courses$enrolledUsersArgs<ExtArgs> = {}>(args?: Subset<T, Courses$enrolledUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseUserMapperPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Courses model
   */ 
  interface CoursesFieldRefs {
    readonly id: FieldRef<"Courses", 'Int'>
    readonly title: FieldRef<"Courses", 'String'>
    readonly description: FieldRef<"Courses", 'String'>
    readonly price: FieldRef<"Courses", 'Float'>
    readonly thumbnailUrl: FieldRef<"Courses", 'String'>
    readonly instructor: FieldRef<"Courses", 'String'>
    readonly duration: FieldRef<"Courses", 'String'>
    readonly level: FieldRef<"Courses", 'CourseLevel'>
    readonly category: FieldRef<"Courses", 'String'>
    readonly language: FieldRef<"Courses", 'String'>
    readonly isPublished: FieldRef<"Courses", 'Boolean'>
    readonly createdBy: FieldRef<"Courses", 'Int'>
    readonly createdAt: FieldRef<"Courses", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Courses findUnique
   */
  export type CoursesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where: CoursesWhereUniqueInput
  }

  /**
   * Courses findUniqueOrThrow
   */
  export type CoursesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where: CoursesWhereUniqueInput
  }

  /**
   * Courses findFirst
   */
  export type CoursesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CoursesOrderByWithRelationInput | CoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * Courses findFirstOrThrow
   */
  export type CoursesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CoursesOrderByWithRelationInput | CoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * Courses findMany
   */
  export type CoursesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CoursesOrderByWithRelationInput | CoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * Courses create
   */
  export type CoursesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * The data needed to create a Courses.
     */
    data: XOR<CoursesCreateInput, CoursesUncheckedCreateInput>
  }

  /**
   * Courses createMany
   */
  export type CoursesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CoursesCreateManyInput | CoursesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Courses createManyAndReturn
   */
  export type CoursesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CoursesCreateManyInput | CoursesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Courses update
   */
  export type CoursesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * The data needed to update a Courses.
     */
    data: XOR<CoursesUpdateInput, CoursesUncheckedUpdateInput>
    /**
     * Choose, which Courses to update.
     */
    where: CoursesWhereUniqueInput
  }

  /**
   * Courses updateMany
   */
  export type CoursesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CoursesUpdateManyMutationInput, CoursesUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CoursesWhereInput
  }

  /**
   * Courses upsert
   */
  export type CoursesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * The filter to search for the Courses to update in case it exists.
     */
    where: CoursesWhereUniqueInput
    /**
     * In case the Courses found by the `where` argument doesn't exist, create a new Courses with this data.
     */
    create: XOR<CoursesCreateInput, CoursesUncheckedCreateInput>
    /**
     * In case the Courses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoursesUpdateInput, CoursesUncheckedUpdateInput>
  }

  /**
   * Courses delete
   */
  export type CoursesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter which Courses to delete.
     */
    where: CoursesWhereUniqueInput
  }

  /**
   * Courses deleteMany
   */
  export type CoursesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CoursesWhereInput
  }

  /**
   * Courses.lessons
   */
  export type Courses$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    where?: LessonsWhereInput
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    cursor?: LessonsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Courses.enrolledUsers
   */
  export type Courses$enrolledUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseUserMapper
     */
    select?: CourseUserMapperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseUserMapperInclude<ExtArgs> | null
    where?: CourseUserMapperWhereInput
    orderBy?: CourseUserMapperOrderByWithRelationInput | CourseUserMapperOrderByWithRelationInput[]
    cursor?: CourseUserMapperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseUserMapperScalarFieldEnum | CourseUserMapperScalarFieldEnum[]
  }

  /**
   * Courses without action
   */
  export type CoursesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
  }


  /**
   * Model Lessons
   */

  export type AggregateLessons = {
    _count: LessonsCountAggregateOutputType | null
    _avg: LessonsAvgAggregateOutputType | null
    _sum: LessonsSumAggregateOutputType | null
    _min: LessonsMinAggregateOutputType | null
    _max: LessonsMaxAggregateOutputType | null
  }

  export type LessonsAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    duration: number | null
    order: number | null
  }

  export type LessonsSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    duration: number | null
    order: number | null
  }

  export type LessonsMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    description: string | null
    videoType: string | null
    videoId: string | null
    duration: number | null
    order: number | null
    isFreePreview: boolean | null
  }

  export type LessonsMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    description: string | null
    videoType: string | null
    videoId: string | null
    duration: number | null
    order: number | null
    isFreePreview: boolean | null
  }

  export type LessonsCountAggregateOutputType = {
    id: number
    courseId: number
    title: number
    description: number
    videoType: number
    videoId: number
    duration: number
    order: number
    isFreePreview: number
    _all: number
  }


  export type LessonsAvgAggregateInputType = {
    id?: true
    courseId?: true
    duration?: true
    order?: true
  }

  export type LessonsSumAggregateInputType = {
    id?: true
    courseId?: true
    duration?: true
    order?: true
  }

  export type LessonsMinAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    videoType?: true
    videoId?: true
    duration?: true
    order?: true
    isFreePreview?: true
  }

  export type LessonsMaxAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    videoType?: true
    videoId?: true
    duration?: true
    order?: true
    isFreePreview?: true
  }

  export type LessonsCountAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    videoType?: true
    videoId?: true
    duration?: true
    order?: true
    isFreePreview?: true
    _all?: true
  }

  export type LessonsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to aggregate.
     */
    where?: LessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonsMaxAggregateInputType
  }

  export type GetLessonsAggregateType<T extends LessonsAggregateArgs> = {
        [P in keyof T & keyof AggregateLessons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessons[P]>
      : GetScalarType<T[P], AggregateLessons[P]>
  }




  export type LessonsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonsWhereInput
    orderBy?: LessonsOrderByWithAggregationInput | LessonsOrderByWithAggregationInput[]
    by: LessonsScalarFieldEnum[] | LessonsScalarFieldEnum
    having?: LessonsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonsCountAggregateInputType | true
    _avg?: LessonsAvgAggregateInputType
    _sum?: LessonsSumAggregateInputType
    _min?: LessonsMinAggregateInputType
    _max?: LessonsMaxAggregateInputType
  }

  export type LessonsGroupByOutputType = {
    id: number
    courseId: number
    title: string
    description: string | null
    videoType: string
    videoId: string
    duration: number | null
    order: number
    isFreePreview: boolean
    _count: LessonsCountAggregateOutputType | null
    _avg: LessonsAvgAggregateOutputType | null
    _sum: LessonsSumAggregateOutputType | null
    _min: LessonsMinAggregateOutputType | null
    _max: LessonsMaxAggregateOutputType | null
  }

  type GetLessonsGroupByPayload<T extends LessonsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonsGroupByOutputType[P]>
            : GetScalarType<T[P], LessonsGroupByOutputType[P]>
        }
      >
    >


  export type LessonsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    videoType?: boolean
    videoId?: boolean
    duration?: boolean
    order?: boolean
    isFreePreview?: boolean
    course?: boolean | CoursesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessons"]>

  export type LessonsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    videoType?: boolean
    videoId?: boolean
    duration?: boolean
    order?: boolean
    isFreePreview?: boolean
    course?: boolean | CoursesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessons"]>

  export type LessonsSelectScalar = {
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    videoType?: boolean
    videoId?: boolean
    duration?: boolean
    order?: boolean
    isFreePreview?: boolean
  }

  export type LessonsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CoursesDefaultArgs<ExtArgs>
  }
  export type LessonsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CoursesDefaultArgs<ExtArgs>
  }

  export type $LessonsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lessons"
    objects: {
      course: Prisma.$CoursesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      title: string
      description: string | null
      videoType: string
      videoId: string
      duration: number | null
      order: number
      isFreePreview: boolean
    }, ExtArgs["result"]["lessons"]>
    composites: {}
  }

  type LessonsGetPayload<S extends boolean | null | undefined | LessonsDefaultArgs> = $Result.GetResult<Prisma.$LessonsPayload, S>

  type LessonsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LessonsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LessonsCountAggregateInputType | true
    }

  export interface LessonsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lessons'], meta: { name: 'Lessons' } }
    /**
     * Find zero or one Lessons that matches the filter.
     * @param {LessonsFindUniqueArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonsFindUniqueArgs>(args: SelectSubset<T, LessonsFindUniqueArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lessons that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LessonsFindUniqueOrThrowArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonsFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsFindFirstArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonsFindFirstArgs>(args?: SelectSubset<T, LessonsFindFirstArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lessons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsFindFirstOrThrowArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonsFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lessons.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lessons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonsWithIdOnly = await prisma.lessons.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonsFindManyArgs>(args?: SelectSubset<T, LessonsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lessons.
     * @param {LessonsCreateArgs} args - Arguments to create a Lessons.
     * @example
     * // Create one Lessons
     * const Lessons = await prisma.lessons.create({
     *   data: {
     *     // ... data to create a Lessons
     *   }
     * })
     * 
     */
    create<T extends LessonsCreateArgs>(args: SelectSubset<T, LessonsCreateArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lessons.
     * @param {LessonsCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lessons = await prisma.lessons.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonsCreateManyArgs>(args?: SelectSubset<T, LessonsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonsCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lessons = await prisma.lessons.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonsWithIdOnly = await prisma.lessons.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonsCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lessons.
     * @param {LessonsDeleteArgs} args - Arguments to delete one Lessons.
     * @example
     * // Delete one Lessons
     * const Lessons = await prisma.lessons.delete({
     *   where: {
     *     // ... filter to delete one Lessons
     *   }
     * })
     * 
     */
    delete<T extends LessonsDeleteArgs>(args: SelectSubset<T, LessonsDeleteArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lessons.
     * @param {LessonsUpdateArgs} args - Arguments to update one Lessons.
     * @example
     * // Update one Lessons
     * const lessons = await prisma.lessons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonsUpdateArgs>(args: SelectSubset<T, LessonsUpdateArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lessons.
     * @param {LessonsDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lessons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonsDeleteManyArgs>(args?: SelectSubset<T, LessonsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lessons = await prisma.lessons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonsUpdateManyArgs>(args: SelectSubset<T, LessonsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lessons.
     * @param {LessonsUpsertArgs} args - Arguments to update or create a Lessons.
     * @example
     * // Update or create a Lessons
     * const lessons = await prisma.lessons.upsert({
     *   create: {
     *     // ... data to create a Lessons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lessons we want to update
     *   }
     * })
     */
    upsert<T extends LessonsUpsertArgs>(args: SelectSubset<T, LessonsUpsertArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lessons.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonsCountArgs>(
      args?: Subset<T, LessonsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonsAggregateArgs>(args: Subset<T, LessonsAggregateArgs>): Prisma.PrismaPromise<GetLessonsAggregateType<T>>

    /**
     * Group by Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonsGroupByArgs['orderBy'] }
        : { orderBy?: LessonsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lessons model
   */
  readonly fields: LessonsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lessons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CoursesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoursesDefaultArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lessons model
   */ 
  interface LessonsFieldRefs {
    readonly id: FieldRef<"Lessons", 'Int'>
    readonly courseId: FieldRef<"Lessons", 'Int'>
    readonly title: FieldRef<"Lessons", 'String'>
    readonly description: FieldRef<"Lessons", 'String'>
    readonly videoType: FieldRef<"Lessons", 'String'>
    readonly videoId: FieldRef<"Lessons", 'String'>
    readonly duration: FieldRef<"Lessons", 'Int'>
    readonly order: FieldRef<"Lessons", 'Int'>
    readonly isFreePreview: FieldRef<"Lessons", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Lessons findUnique
   */
  export type LessonsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where: LessonsWhereUniqueInput
  }

  /**
   * Lessons findUniqueOrThrow
   */
  export type LessonsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where: LessonsWhereUniqueInput
  }

  /**
   * Lessons findFirst
   */
  export type LessonsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Lessons findFirstOrThrow
   */
  export type LessonsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Lessons findMany
   */
  export type LessonsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Lessons create
   */
  export type LessonsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * The data needed to create a Lessons.
     */
    data: XOR<LessonsCreateInput, LessonsUncheckedCreateInput>
  }

  /**
   * Lessons createMany
   */
  export type LessonsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonsCreateManyInput | LessonsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lessons createManyAndReturn
   */
  export type LessonsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonsCreateManyInput | LessonsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lessons update
   */
  export type LessonsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * The data needed to update a Lessons.
     */
    data: XOR<LessonsUpdateInput, LessonsUncheckedUpdateInput>
    /**
     * Choose, which Lessons to update.
     */
    where: LessonsWhereUniqueInput
  }

  /**
   * Lessons updateMany
   */
  export type LessonsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonsUpdateManyMutationInput, LessonsUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonsWhereInput
  }

  /**
   * Lessons upsert
   */
  export type LessonsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * The filter to search for the Lessons to update in case it exists.
     */
    where: LessonsWhereUniqueInput
    /**
     * In case the Lessons found by the `where` argument doesn't exist, create a new Lessons with this data.
     */
    create: XOR<LessonsCreateInput, LessonsUncheckedCreateInput>
    /**
     * In case the Lessons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonsUpdateInput, LessonsUncheckedUpdateInput>
  }

  /**
   * Lessons delete
   */
  export type LessonsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter which Lessons to delete.
     */
    where: LessonsWhereUniqueInput
  }

  /**
   * Lessons deleteMany
   */
  export type LessonsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonsWhereInput
  }

  /**
   * Lessons without action
   */
  export type LessonsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
  }


  /**
   * Model CourseUserMapper
   */

  export type AggregateCourseUserMapper = {
    _count: CourseUserMapperCountAggregateOutputType | null
    _avg: CourseUserMapperAvgAggregateOutputType | null
    _sum: CourseUserMapperSumAggregateOutputType | null
    _min: CourseUserMapperMinAggregateOutputType | null
    _max: CourseUserMapperMaxAggregateOutputType | null
  }

  export type CourseUserMapperAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    progress: number | null
  }

  export type CourseUserMapperSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    progress: number | null
  }

  export type CourseUserMapperMinAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    enrolledAt: Date | null
    completedAt: Date | null
    progress: number | null
    isCompleted: boolean | null
  }

  export type CourseUserMapperMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    enrolledAt: Date | null
    completedAt: Date | null
    progress: number | null
    isCompleted: boolean | null
  }

  export type CourseUserMapperCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    enrolledAt: number
    completedAt: number
    progress: number
    isCompleted: number
    _all: number
  }


  export type CourseUserMapperAvgAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
  }

  export type CourseUserMapperSumAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
  }

  export type CourseUserMapperMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrolledAt?: true
    completedAt?: true
    progress?: true
    isCompleted?: true
  }

  export type CourseUserMapperMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrolledAt?: true
    completedAt?: true
    progress?: true
    isCompleted?: true
  }

  export type CourseUserMapperCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrolledAt?: true
    completedAt?: true
    progress?: true
    isCompleted?: true
    _all?: true
  }

  export type CourseUserMapperAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseUserMapper to aggregate.
     */
    where?: CourseUserMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseUserMappers to fetch.
     */
    orderBy?: CourseUserMapperOrderByWithRelationInput | CourseUserMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseUserMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseUserMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseUserMappers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseUserMappers
    **/
    _count?: true | CourseUserMapperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseUserMapperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseUserMapperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseUserMapperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseUserMapperMaxAggregateInputType
  }

  export type GetCourseUserMapperAggregateType<T extends CourseUserMapperAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseUserMapper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseUserMapper[P]>
      : GetScalarType<T[P], AggregateCourseUserMapper[P]>
  }




  export type CourseUserMapperGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseUserMapperWhereInput
    orderBy?: CourseUserMapperOrderByWithAggregationInput | CourseUserMapperOrderByWithAggregationInput[]
    by: CourseUserMapperScalarFieldEnum[] | CourseUserMapperScalarFieldEnum
    having?: CourseUserMapperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseUserMapperCountAggregateInputType | true
    _avg?: CourseUserMapperAvgAggregateInputType
    _sum?: CourseUserMapperSumAggregateInputType
    _min?: CourseUserMapperMinAggregateInputType
    _max?: CourseUserMapperMaxAggregateInputType
  }

  export type CourseUserMapperGroupByOutputType = {
    id: number
    userId: number
    courseId: number
    enrolledAt: Date
    completedAt: Date | null
    progress: number
    isCompleted: boolean
    _count: CourseUserMapperCountAggregateOutputType | null
    _avg: CourseUserMapperAvgAggregateOutputType | null
    _sum: CourseUserMapperSumAggregateOutputType | null
    _min: CourseUserMapperMinAggregateOutputType | null
    _max: CourseUserMapperMaxAggregateOutputType | null
  }

  type GetCourseUserMapperGroupByPayload<T extends CourseUserMapperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseUserMapperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseUserMapperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseUserMapperGroupByOutputType[P]>
            : GetScalarType<T[P], CourseUserMapperGroupByOutputType[P]>
        }
      >
    >


  export type CourseUserMapperSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    progress?: boolean
    isCompleted?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CoursesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseUserMapper"]>

  export type CourseUserMapperSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    progress?: boolean
    isCompleted?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CoursesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseUserMapper"]>

  export type CourseUserMapperSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    progress?: boolean
    isCompleted?: boolean
  }

  export type CourseUserMapperInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CoursesDefaultArgs<ExtArgs>
  }
  export type CourseUserMapperIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CoursesDefaultArgs<ExtArgs>
  }

  export type $CourseUserMapperPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseUserMapper"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      courseId: number
      enrolledAt: Date
      completedAt: Date | null
      progress: number
      isCompleted: boolean
    }, ExtArgs["result"]["courseUserMapper"]>
    composites: {}
  }

  type CourseUserMapperGetPayload<S extends boolean | null | undefined | CourseUserMapperDefaultArgs> = $Result.GetResult<Prisma.$CourseUserMapperPayload, S>

  type CourseUserMapperCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseUserMapperFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseUserMapperCountAggregateInputType | true
    }

  export interface CourseUserMapperDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseUserMapper'], meta: { name: 'CourseUserMapper' } }
    /**
     * Find zero or one CourseUserMapper that matches the filter.
     * @param {CourseUserMapperFindUniqueArgs} args - Arguments to find a CourseUserMapper
     * @example
     * // Get one CourseUserMapper
     * const courseUserMapper = await prisma.courseUserMapper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseUserMapperFindUniqueArgs>(args: SelectSubset<T, CourseUserMapperFindUniqueArgs<ExtArgs>>): Prisma__CourseUserMapperClient<$Result.GetResult<Prisma.$CourseUserMapperPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseUserMapper that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseUserMapperFindUniqueOrThrowArgs} args - Arguments to find a CourseUserMapper
     * @example
     * // Get one CourseUserMapper
     * const courseUserMapper = await prisma.courseUserMapper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseUserMapperFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseUserMapperFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseUserMapperClient<$Result.GetResult<Prisma.$CourseUserMapperPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseUserMapper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUserMapperFindFirstArgs} args - Arguments to find a CourseUserMapper
     * @example
     * // Get one CourseUserMapper
     * const courseUserMapper = await prisma.courseUserMapper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseUserMapperFindFirstArgs>(args?: SelectSubset<T, CourseUserMapperFindFirstArgs<ExtArgs>>): Prisma__CourseUserMapperClient<$Result.GetResult<Prisma.$CourseUserMapperPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseUserMapper that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUserMapperFindFirstOrThrowArgs} args - Arguments to find a CourseUserMapper
     * @example
     * // Get one CourseUserMapper
     * const courseUserMapper = await prisma.courseUserMapper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseUserMapperFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseUserMapperFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseUserMapperClient<$Result.GetResult<Prisma.$CourseUserMapperPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseUserMappers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUserMapperFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseUserMappers
     * const courseUserMappers = await prisma.courseUserMapper.findMany()
     * 
     * // Get first 10 CourseUserMappers
     * const courseUserMappers = await prisma.courseUserMapper.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseUserMapperWithIdOnly = await prisma.courseUserMapper.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseUserMapperFindManyArgs>(args?: SelectSubset<T, CourseUserMapperFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseUserMapperPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseUserMapper.
     * @param {CourseUserMapperCreateArgs} args - Arguments to create a CourseUserMapper.
     * @example
     * // Create one CourseUserMapper
     * const CourseUserMapper = await prisma.courseUserMapper.create({
     *   data: {
     *     // ... data to create a CourseUserMapper
     *   }
     * })
     * 
     */
    create<T extends CourseUserMapperCreateArgs>(args: SelectSubset<T, CourseUserMapperCreateArgs<ExtArgs>>): Prisma__CourseUserMapperClient<$Result.GetResult<Prisma.$CourseUserMapperPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseUserMappers.
     * @param {CourseUserMapperCreateManyArgs} args - Arguments to create many CourseUserMappers.
     * @example
     * // Create many CourseUserMappers
     * const courseUserMapper = await prisma.courseUserMapper.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseUserMapperCreateManyArgs>(args?: SelectSubset<T, CourseUserMapperCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseUserMappers and returns the data saved in the database.
     * @param {CourseUserMapperCreateManyAndReturnArgs} args - Arguments to create many CourseUserMappers.
     * @example
     * // Create many CourseUserMappers
     * const courseUserMapper = await prisma.courseUserMapper.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseUserMappers and only return the `id`
     * const courseUserMapperWithIdOnly = await prisma.courseUserMapper.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseUserMapperCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseUserMapperCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseUserMapperPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseUserMapper.
     * @param {CourseUserMapperDeleteArgs} args - Arguments to delete one CourseUserMapper.
     * @example
     * // Delete one CourseUserMapper
     * const CourseUserMapper = await prisma.courseUserMapper.delete({
     *   where: {
     *     // ... filter to delete one CourseUserMapper
     *   }
     * })
     * 
     */
    delete<T extends CourseUserMapperDeleteArgs>(args: SelectSubset<T, CourseUserMapperDeleteArgs<ExtArgs>>): Prisma__CourseUserMapperClient<$Result.GetResult<Prisma.$CourseUserMapperPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseUserMapper.
     * @param {CourseUserMapperUpdateArgs} args - Arguments to update one CourseUserMapper.
     * @example
     * // Update one CourseUserMapper
     * const courseUserMapper = await prisma.courseUserMapper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUserMapperUpdateArgs>(args: SelectSubset<T, CourseUserMapperUpdateArgs<ExtArgs>>): Prisma__CourseUserMapperClient<$Result.GetResult<Prisma.$CourseUserMapperPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseUserMappers.
     * @param {CourseUserMapperDeleteManyArgs} args - Arguments to filter CourseUserMappers to delete.
     * @example
     * // Delete a few CourseUserMappers
     * const { count } = await prisma.courseUserMapper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseUserMapperDeleteManyArgs>(args?: SelectSubset<T, CourseUserMapperDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseUserMappers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUserMapperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseUserMappers
     * const courseUserMapper = await prisma.courseUserMapper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUserMapperUpdateManyArgs>(args: SelectSubset<T, CourseUserMapperUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseUserMapper.
     * @param {CourseUserMapperUpsertArgs} args - Arguments to update or create a CourseUserMapper.
     * @example
     * // Update or create a CourseUserMapper
     * const courseUserMapper = await prisma.courseUserMapper.upsert({
     *   create: {
     *     // ... data to create a CourseUserMapper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseUserMapper we want to update
     *   }
     * })
     */
    upsert<T extends CourseUserMapperUpsertArgs>(args: SelectSubset<T, CourseUserMapperUpsertArgs<ExtArgs>>): Prisma__CourseUserMapperClient<$Result.GetResult<Prisma.$CourseUserMapperPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseUserMappers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUserMapperCountArgs} args - Arguments to filter CourseUserMappers to count.
     * @example
     * // Count the number of CourseUserMappers
     * const count = await prisma.courseUserMapper.count({
     *   where: {
     *     // ... the filter for the CourseUserMappers we want to count
     *   }
     * })
    **/
    count<T extends CourseUserMapperCountArgs>(
      args?: Subset<T, CourseUserMapperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseUserMapperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseUserMapper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUserMapperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseUserMapperAggregateArgs>(args: Subset<T, CourseUserMapperAggregateArgs>): Prisma.PrismaPromise<GetCourseUserMapperAggregateType<T>>

    /**
     * Group by CourseUserMapper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUserMapperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseUserMapperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseUserMapperGroupByArgs['orderBy'] }
        : { orderBy?: CourseUserMapperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseUserMapperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseUserMapperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseUserMapper model
   */
  readonly fields: CourseUserMapperFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseUserMapper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseUserMapperClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CoursesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoursesDefaultArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseUserMapper model
   */ 
  interface CourseUserMapperFieldRefs {
    readonly id: FieldRef<"CourseUserMapper", 'Int'>
    readonly userId: FieldRef<"CourseUserMapper", 'Int'>
    readonly courseId: FieldRef<"CourseUserMapper", 'Int'>
    readonly enrolledAt: FieldRef<"CourseUserMapper", 'DateTime'>
    readonly completedAt: FieldRef<"CourseUserMapper", 'DateTime'>
    readonly progress: FieldRef<"CourseUserMapper", 'Int'>
    readonly isCompleted: FieldRef<"CourseUserMapper", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CourseUserMapper findUnique
   */
  export type CourseUserMapperFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseUserMapper
     */
    select?: CourseUserMapperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseUserMapperInclude<ExtArgs> | null
    /**
     * Filter, which CourseUserMapper to fetch.
     */
    where: CourseUserMapperWhereUniqueInput
  }

  /**
   * CourseUserMapper findUniqueOrThrow
   */
  export type CourseUserMapperFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseUserMapper
     */
    select?: CourseUserMapperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseUserMapperInclude<ExtArgs> | null
    /**
     * Filter, which CourseUserMapper to fetch.
     */
    where: CourseUserMapperWhereUniqueInput
  }

  /**
   * CourseUserMapper findFirst
   */
  export type CourseUserMapperFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseUserMapper
     */
    select?: CourseUserMapperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseUserMapperInclude<ExtArgs> | null
    /**
     * Filter, which CourseUserMapper to fetch.
     */
    where?: CourseUserMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseUserMappers to fetch.
     */
    orderBy?: CourseUserMapperOrderByWithRelationInput | CourseUserMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseUserMappers.
     */
    cursor?: CourseUserMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseUserMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseUserMappers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseUserMappers.
     */
    distinct?: CourseUserMapperScalarFieldEnum | CourseUserMapperScalarFieldEnum[]
  }

  /**
   * CourseUserMapper findFirstOrThrow
   */
  export type CourseUserMapperFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseUserMapper
     */
    select?: CourseUserMapperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseUserMapperInclude<ExtArgs> | null
    /**
     * Filter, which CourseUserMapper to fetch.
     */
    where?: CourseUserMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseUserMappers to fetch.
     */
    orderBy?: CourseUserMapperOrderByWithRelationInput | CourseUserMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseUserMappers.
     */
    cursor?: CourseUserMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseUserMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseUserMappers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseUserMappers.
     */
    distinct?: CourseUserMapperScalarFieldEnum | CourseUserMapperScalarFieldEnum[]
  }

  /**
   * CourseUserMapper findMany
   */
  export type CourseUserMapperFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseUserMapper
     */
    select?: CourseUserMapperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseUserMapperInclude<ExtArgs> | null
    /**
     * Filter, which CourseUserMappers to fetch.
     */
    where?: CourseUserMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseUserMappers to fetch.
     */
    orderBy?: CourseUserMapperOrderByWithRelationInput | CourseUserMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseUserMappers.
     */
    cursor?: CourseUserMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseUserMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseUserMappers.
     */
    skip?: number
    distinct?: CourseUserMapperScalarFieldEnum | CourseUserMapperScalarFieldEnum[]
  }

  /**
   * CourseUserMapper create
   */
  export type CourseUserMapperCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseUserMapper
     */
    select?: CourseUserMapperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseUserMapperInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseUserMapper.
     */
    data: XOR<CourseUserMapperCreateInput, CourseUserMapperUncheckedCreateInput>
  }

  /**
   * CourseUserMapper createMany
   */
  export type CourseUserMapperCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseUserMappers.
     */
    data: CourseUserMapperCreateManyInput | CourseUserMapperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseUserMapper createManyAndReturn
   */
  export type CourseUserMapperCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseUserMapper
     */
    select?: CourseUserMapperSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseUserMappers.
     */
    data: CourseUserMapperCreateManyInput | CourseUserMapperCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseUserMapperIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseUserMapper update
   */
  export type CourseUserMapperUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseUserMapper
     */
    select?: CourseUserMapperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseUserMapperInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseUserMapper.
     */
    data: XOR<CourseUserMapperUpdateInput, CourseUserMapperUncheckedUpdateInput>
    /**
     * Choose, which CourseUserMapper to update.
     */
    where: CourseUserMapperWhereUniqueInput
  }

  /**
   * CourseUserMapper updateMany
   */
  export type CourseUserMapperUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseUserMappers.
     */
    data: XOR<CourseUserMapperUpdateManyMutationInput, CourseUserMapperUncheckedUpdateManyInput>
    /**
     * Filter which CourseUserMappers to update
     */
    where?: CourseUserMapperWhereInput
  }

  /**
   * CourseUserMapper upsert
   */
  export type CourseUserMapperUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseUserMapper
     */
    select?: CourseUserMapperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseUserMapperInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseUserMapper to update in case it exists.
     */
    where: CourseUserMapperWhereUniqueInput
    /**
     * In case the CourseUserMapper found by the `where` argument doesn't exist, create a new CourseUserMapper with this data.
     */
    create: XOR<CourseUserMapperCreateInput, CourseUserMapperUncheckedCreateInput>
    /**
     * In case the CourseUserMapper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUserMapperUpdateInput, CourseUserMapperUncheckedUpdateInput>
  }

  /**
   * CourseUserMapper delete
   */
  export type CourseUserMapperDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseUserMapper
     */
    select?: CourseUserMapperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseUserMapperInclude<ExtArgs> | null
    /**
     * Filter which CourseUserMapper to delete.
     */
    where: CourseUserMapperWhereUniqueInput
  }

  /**
   * CourseUserMapper deleteMany
   */
  export type CourseUserMapperDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseUserMappers to delete
     */
    where?: CourseUserMapperWhereInput
  }

  /**
   * CourseUserMapper without action
   */
  export type CourseUserMapperDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseUserMapper
     */
    select?: CourseUserMapperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseUserMapperInclude<ExtArgs> | null
  }


  /**
   * Model Contest
   */

  export type AggregateContest = {
    _count: ContestCountAggregateOutputType | null
    _avg: ContestAvgAggregateOutputType | null
    _sum: ContestSumAggregateOutputType | null
    _min: ContestMinAggregateOutputType | null
    _max: ContestMaxAggregateOutputType | null
  }

  export type ContestAvgAggregateOutputType = {
    id: number | null
    durationMinutes: number | null
    totalMarks: number | null
    createdByAdminId: number | null
  }

  export type ContestSumAggregateOutputType = {
    id: number | null
    durationMinutes: number | null
    totalMarks: number | null
    createdByAdminId: number | null
  }

  export type ContestMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    category: string | null
    startTime: Date | null
    endTime: Date | null
    isPublished: boolean | null
    durationMinutes: number | null
    totalMarks: number | null
    isActive: boolean | null
    createdByAdminId: number | null
    createdAt: Date | null
  }

  export type ContestMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    category: string | null
    startTime: Date | null
    endTime: Date | null
    isPublished: boolean | null
    durationMinutes: number | null
    totalMarks: number | null
    isActive: boolean | null
    createdByAdminId: number | null
    createdAt: Date | null
  }

  export type ContestCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    startTime: number
    endTime: number
    isPublished: number
    durationMinutes: number
    totalMarks: number
    isActive: number
    createdByAdminId: number
    createdAt: number
    _all: number
  }


  export type ContestAvgAggregateInputType = {
    id?: true
    durationMinutes?: true
    totalMarks?: true
    createdByAdminId?: true
  }

  export type ContestSumAggregateInputType = {
    id?: true
    durationMinutes?: true
    totalMarks?: true
    createdByAdminId?: true
  }

  export type ContestMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    startTime?: true
    endTime?: true
    isPublished?: true
    durationMinutes?: true
    totalMarks?: true
    isActive?: true
    createdByAdminId?: true
    createdAt?: true
  }

  export type ContestMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    startTime?: true
    endTime?: true
    isPublished?: true
    durationMinutes?: true
    totalMarks?: true
    isActive?: true
    createdByAdminId?: true
    createdAt?: true
  }

  export type ContestCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    startTime?: true
    endTime?: true
    isPublished?: true
    durationMinutes?: true
    totalMarks?: true
    isActive?: true
    createdByAdminId?: true
    createdAt?: true
    _all?: true
  }

  export type ContestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contest to aggregate.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: ContestOrderByWithRelationInput | ContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contests
    **/
    _count?: true | ContestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestMaxAggregateInputType
  }

  export type GetContestAggregateType<T extends ContestAggregateArgs> = {
        [P in keyof T & keyof AggregateContest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContest[P]>
      : GetScalarType<T[P], AggregateContest[P]>
  }




  export type ContestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestWhereInput
    orderBy?: ContestOrderByWithAggregationInput | ContestOrderByWithAggregationInput[]
    by: ContestScalarFieldEnum[] | ContestScalarFieldEnum
    having?: ContestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestCountAggregateInputType | true
    _avg?: ContestAvgAggregateInputType
    _sum?: ContestSumAggregateInputType
    _min?: ContestMinAggregateInputType
    _max?: ContestMaxAggregateInputType
  }

  export type ContestGroupByOutputType = {
    id: number
    title: string
    description: string | null
    category: string
    startTime: Date
    endTime: Date
    isPublished: boolean
    durationMinutes: number | null
    totalMarks: number | null
    isActive: boolean
    createdByAdminId: number | null
    createdAt: Date
    _count: ContestCountAggregateOutputType | null
    _avg: ContestAvgAggregateOutputType | null
    _sum: ContestSumAggregateOutputType | null
    _min: ContestMinAggregateOutputType | null
    _max: ContestMaxAggregateOutputType | null
  }

  type GetContestGroupByPayload<T extends ContestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestGroupByOutputType[P]>
            : GetScalarType<T[P], ContestGroupByOutputType[P]>
        }
      >
    >


  export type ContestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    startTime?: boolean
    endTime?: boolean
    isPublished?: boolean
    durationMinutes?: boolean
    totalMarks?: boolean
    isActive?: boolean
    createdByAdminId?: boolean
    createdAt?: boolean
    ContestQuestion?: boolean | Contest$ContestQuestionArgs<ExtArgs>
    ContestAttempt?: boolean | Contest$ContestAttemptArgs<ExtArgs>
    _count?: boolean | ContestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contest"]>

  export type ContestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    startTime?: boolean
    endTime?: boolean
    isPublished?: boolean
    durationMinutes?: boolean
    totalMarks?: boolean
    isActive?: boolean
    createdByAdminId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contest"]>

  export type ContestSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    startTime?: boolean
    endTime?: boolean
    isPublished?: boolean
    durationMinutes?: boolean
    totalMarks?: boolean
    isActive?: boolean
    createdByAdminId?: boolean
    createdAt?: boolean
  }

  export type ContestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ContestQuestion?: boolean | Contest$ContestQuestionArgs<ExtArgs>
    ContestAttempt?: boolean | Contest$ContestAttemptArgs<ExtArgs>
    _count?: boolean | ContestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contest"
    objects: {
      ContestQuestion: Prisma.$ContestQuestionPayload<ExtArgs>[]
      ContestAttempt: Prisma.$ContestAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      category: string
      startTime: Date
      endTime: Date
      isPublished: boolean
      durationMinutes: number | null
      totalMarks: number | null
      isActive: boolean
      createdByAdminId: number | null
      createdAt: Date
    }, ExtArgs["result"]["contest"]>
    composites: {}
  }

  type ContestGetPayload<S extends boolean | null | undefined | ContestDefaultArgs> = $Result.GetResult<Prisma.$ContestPayload, S>

  type ContestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContestCountAggregateInputType | true
    }

  export interface ContestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contest'], meta: { name: 'Contest' } }
    /**
     * Find zero or one Contest that matches the filter.
     * @param {ContestFindUniqueArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestFindUniqueArgs>(args: SelectSubset<T, ContestFindUniqueArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContestFindUniqueOrThrowArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestFindFirstArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestFindFirstArgs>(args?: SelectSubset<T, ContestFindFirstArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestFindFirstOrThrowArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contests
     * const contests = await prisma.contest.findMany()
     * 
     * // Get first 10 Contests
     * const contests = await prisma.contest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestWithIdOnly = await prisma.contest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestFindManyArgs>(args?: SelectSubset<T, ContestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contest.
     * @param {ContestCreateArgs} args - Arguments to create a Contest.
     * @example
     * // Create one Contest
     * const Contest = await prisma.contest.create({
     *   data: {
     *     // ... data to create a Contest
     *   }
     * })
     * 
     */
    create<T extends ContestCreateArgs>(args: SelectSubset<T, ContestCreateArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contests.
     * @param {ContestCreateManyArgs} args - Arguments to create many Contests.
     * @example
     * // Create many Contests
     * const contest = await prisma.contest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestCreateManyArgs>(args?: SelectSubset<T, ContestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contests and returns the data saved in the database.
     * @param {ContestCreateManyAndReturnArgs} args - Arguments to create many Contests.
     * @example
     * // Create many Contests
     * const contest = await prisma.contest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contests and only return the `id`
     * const contestWithIdOnly = await prisma.contest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContestCreateManyAndReturnArgs>(args?: SelectSubset<T, ContestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contest.
     * @param {ContestDeleteArgs} args - Arguments to delete one Contest.
     * @example
     * // Delete one Contest
     * const Contest = await prisma.contest.delete({
     *   where: {
     *     // ... filter to delete one Contest
     *   }
     * })
     * 
     */
    delete<T extends ContestDeleteArgs>(args: SelectSubset<T, ContestDeleteArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contest.
     * @param {ContestUpdateArgs} args - Arguments to update one Contest.
     * @example
     * // Update one Contest
     * const contest = await prisma.contest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestUpdateArgs>(args: SelectSubset<T, ContestUpdateArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contests.
     * @param {ContestDeleteManyArgs} args - Arguments to filter Contests to delete.
     * @example
     * // Delete a few Contests
     * const { count } = await prisma.contest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestDeleteManyArgs>(args?: SelectSubset<T, ContestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contests
     * const contest = await prisma.contest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestUpdateManyArgs>(args: SelectSubset<T, ContestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contest.
     * @param {ContestUpsertArgs} args - Arguments to update or create a Contest.
     * @example
     * // Update or create a Contest
     * const contest = await prisma.contest.upsert({
     *   create: {
     *     // ... data to create a Contest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contest we want to update
     *   }
     * })
     */
    upsert<T extends ContestUpsertArgs>(args: SelectSubset<T, ContestUpsertArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestCountArgs} args - Arguments to filter Contests to count.
     * @example
     * // Count the number of Contests
     * const count = await prisma.contest.count({
     *   where: {
     *     // ... the filter for the Contests we want to count
     *   }
     * })
    **/
    count<T extends ContestCountArgs>(
      args?: Subset<T, ContestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestAggregateArgs>(args: Subset<T, ContestAggregateArgs>): Prisma.PrismaPromise<GetContestAggregateType<T>>

    /**
     * Group by Contest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestGroupByArgs['orderBy'] }
        : { orderBy?: ContestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contest model
   */
  readonly fields: ContestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ContestQuestion<T extends Contest$ContestQuestionArgs<ExtArgs> = {}>(args?: Subset<T, Contest$ContestQuestionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestQuestionPayload<ExtArgs>, T, "findMany"> | Null>
    ContestAttempt<T extends Contest$ContestAttemptArgs<ExtArgs> = {}>(args?: Subset<T, Contest$ContestAttemptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contest model
   */ 
  interface ContestFieldRefs {
    readonly id: FieldRef<"Contest", 'Int'>
    readonly title: FieldRef<"Contest", 'String'>
    readonly description: FieldRef<"Contest", 'String'>
    readonly category: FieldRef<"Contest", 'String'>
    readonly startTime: FieldRef<"Contest", 'DateTime'>
    readonly endTime: FieldRef<"Contest", 'DateTime'>
    readonly isPublished: FieldRef<"Contest", 'Boolean'>
    readonly durationMinutes: FieldRef<"Contest", 'Int'>
    readonly totalMarks: FieldRef<"Contest", 'Int'>
    readonly isActive: FieldRef<"Contest", 'Boolean'>
    readonly createdByAdminId: FieldRef<"Contest", 'Int'>
    readonly createdAt: FieldRef<"Contest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contest findUnique
   */
  export type ContestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter, which Contest to fetch.
     */
    where: ContestWhereUniqueInput
  }

  /**
   * Contest findUniqueOrThrow
   */
  export type ContestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter, which Contest to fetch.
     */
    where: ContestWhereUniqueInput
  }

  /**
   * Contest findFirst
   */
  export type ContestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter, which Contest to fetch.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: ContestOrderByWithRelationInput | ContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contests.
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contests.
     */
    distinct?: ContestScalarFieldEnum | ContestScalarFieldEnum[]
  }

  /**
   * Contest findFirstOrThrow
   */
  export type ContestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter, which Contest to fetch.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: ContestOrderByWithRelationInput | ContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contests.
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contests.
     */
    distinct?: ContestScalarFieldEnum | ContestScalarFieldEnum[]
  }

  /**
   * Contest findMany
   */
  export type ContestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter, which Contests to fetch.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: ContestOrderByWithRelationInput | ContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contests.
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    distinct?: ContestScalarFieldEnum | ContestScalarFieldEnum[]
  }

  /**
   * Contest create
   */
  export type ContestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * The data needed to create a Contest.
     */
    data: XOR<ContestCreateInput, ContestUncheckedCreateInput>
  }

  /**
   * Contest createMany
   */
  export type ContestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contests.
     */
    data: ContestCreateManyInput | ContestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contest createManyAndReturn
   */
  export type ContestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contests.
     */
    data: ContestCreateManyInput | ContestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contest update
   */
  export type ContestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * The data needed to update a Contest.
     */
    data: XOR<ContestUpdateInput, ContestUncheckedUpdateInput>
    /**
     * Choose, which Contest to update.
     */
    where: ContestWhereUniqueInput
  }

  /**
   * Contest updateMany
   */
  export type ContestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contests.
     */
    data: XOR<ContestUpdateManyMutationInput, ContestUncheckedUpdateManyInput>
    /**
     * Filter which Contests to update
     */
    where?: ContestWhereInput
  }

  /**
   * Contest upsert
   */
  export type ContestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * The filter to search for the Contest to update in case it exists.
     */
    where: ContestWhereUniqueInput
    /**
     * In case the Contest found by the `where` argument doesn't exist, create a new Contest with this data.
     */
    create: XOR<ContestCreateInput, ContestUncheckedCreateInput>
    /**
     * In case the Contest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestUpdateInput, ContestUncheckedUpdateInput>
  }

  /**
   * Contest delete
   */
  export type ContestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter which Contest to delete.
     */
    where: ContestWhereUniqueInput
  }

  /**
   * Contest deleteMany
   */
  export type ContestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contests to delete
     */
    where?: ContestWhereInput
  }

  /**
   * Contest.ContestQuestion
   */
  export type Contest$ContestQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestQuestion
     */
    select?: ContestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestQuestionInclude<ExtArgs> | null
    where?: ContestQuestionWhereInput
    orderBy?: ContestQuestionOrderByWithRelationInput | ContestQuestionOrderByWithRelationInput[]
    cursor?: ContestQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestQuestionScalarFieldEnum | ContestQuestionScalarFieldEnum[]
  }

  /**
   * Contest.ContestAttempt
   */
  export type Contest$ContestAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAttempt
     */
    select?: ContestAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAttemptInclude<ExtArgs> | null
    where?: ContestAttemptWhereInput
    orderBy?: ContestAttemptOrderByWithRelationInput | ContestAttemptOrderByWithRelationInput[]
    cursor?: ContestAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestAttemptScalarFieldEnum | ContestAttemptScalarFieldEnum[]
  }

  /**
   * Contest without action
   */
  export type ContestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
  }


  /**
   * Model ContestQuestion
   */

  export type AggregateContestQuestion = {
    _count: ContestQuestionCountAggregateOutputType | null
    _avg: ContestQuestionAvgAggregateOutputType | null
    _sum: ContestQuestionSumAggregateOutputType | null
    _min: ContestQuestionMinAggregateOutputType | null
    _max: ContestQuestionMaxAggregateOutputType | null
  }

  export type ContestQuestionAvgAggregateOutputType = {
    id: number | null
    contestId: number | null
    marks: number | null
  }

  export type ContestQuestionSumAggregateOutputType = {
    id: number | null
    contestId: number | null
    marks: number | null
  }

  export type ContestQuestionMinAggregateOutputType = {
    id: number | null
    contestId: number | null
    questionText: string | null
    optionA: string | null
    optionB: string | null
    optionC: string | null
    optionD: string | null
    correctOption: string | null
    marks: number | null
  }

  export type ContestQuestionMaxAggregateOutputType = {
    id: number | null
    contestId: number | null
    questionText: string | null
    optionA: string | null
    optionB: string | null
    optionC: string | null
    optionD: string | null
    correctOption: string | null
    marks: number | null
  }

  export type ContestQuestionCountAggregateOutputType = {
    id: number
    contestId: number
    questionText: number
    optionA: number
    optionB: number
    optionC: number
    optionD: number
    correctOption: number
    marks: number
    _all: number
  }


  export type ContestQuestionAvgAggregateInputType = {
    id?: true
    contestId?: true
    marks?: true
  }

  export type ContestQuestionSumAggregateInputType = {
    id?: true
    contestId?: true
    marks?: true
  }

  export type ContestQuestionMinAggregateInputType = {
    id?: true
    contestId?: true
    questionText?: true
    optionA?: true
    optionB?: true
    optionC?: true
    optionD?: true
    correctOption?: true
    marks?: true
  }

  export type ContestQuestionMaxAggregateInputType = {
    id?: true
    contestId?: true
    questionText?: true
    optionA?: true
    optionB?: true
    optionC?: true
    optionD?: true
    correctOption?: true
    marks?: true
  }

  export type ContestQuestionCountAggregateInputType = {
    id?: true
    contestId?: true
    questionText?: true
    optionA?: true
    optionB?: true
    optionC?: true
    optionD?: true
    correctOption?: true
    marks?: true
    _all?: true
  }

  export type ContestQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestQuestion to aggregate.
     */
    where?: ContestQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestQuestions to fetch.
     */
    orderBy?: ContestQuestionOrderByWithRelationInput | ContestQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContestQuestions
    **/
    _count?: true | ContestQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestQuestionMaxAggregateInputType
  }

  export type GetContestQuestionAggregateType<T extends ContestQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateContestQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestQuestion[P]>
      : GetScalarType<T[P], AggregateContestQuestion[P]>
  }




  export type ContestQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestQuestionWhereInput
    orderBy?: ContestQuestionOrderByWithAggregationInput | ContestQuestionOrderByWithAggregationInput[]
    by: ContestQuestionScalarFieldEnum[] | ContestQuestionScalarFieldEnum
    having?: ContestQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestQuestionCountAggregateInputType | true
    _avg?: ContestQuestionAvgAggregateInputType
    _sum?: ContestQuestionSumAggregateInputType
    _min?: ContestQuestionMinAggregateInputType
    _max?: ContestQuestionMaxAggregateInputType
  }

  export type ContestQuestionGroupByOutputType = {
    id: number
    contestId: number
    questionText: string
    optionA: string
    optionB: string
    optionC: string | null
    optionD: string | null
    correctOption: string
    marks: number
    _count: ContestQuestionCountAggregateOutputType | null
    _avg: ContestQuestionAvgAggregateOutputType | null
    _sum: ContestQuestionSumAggregateOutputType | null
    _min: ContestQuestionMinAggregateOutputType | null
    _max: ContestQuestionMaxAggregateOutputType | null
  }

  type GetContestQuestionGroupByPayload<T extends ContestQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], ContestQuestionGroupByOutputType[P]>
        }
      >
    >


  export type ContestQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contestId?: boolean
    questionText?: boolean
    optionA?: boolean
    optionB?: boolean
    optionC?: boolean
    optionD?: boolean
    correctOption?: boolean
    marks?: boolean
    contestanswer?: boolean | ContestQuestion$contestanswerArgs<ExtArgs>
    contest?: boolean | ContestDefaultArgs<ExtArgs>
    _count?: boolean | ContestQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestQuestion"]>

  export type ContestQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contestId?: boolean
    questionText?: boolean
    optionA?: boolean
    optionB?: boolean
    optionC?: boolean
    optionD?: boolean
    correctOption?: boolean
    marks?: boolean
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestQuestion"]>

  export type ContestQuestionSelectScalar = {
    id?: boolean
    contestId?: boolean
    questionText?: boolean
    optionA?: boolean
    optionB?: boolean
    optionC?: boolean
    optionD?: boolean
    correctOption?: boolean
    marks?: boolean
  }

  export type ContestQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contestanswer?: boolean | ContestQuestion$contestanswerArgs<ExtArgs>
    contest?: boolean | ContestDefaultArgs<ExtArgs>
    _count?: boolean | ContestQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContestQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }

  export type $ContestQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContestQuestion"
    objects: {
      contestanswer: Prisma.$ContestAnswerPayload<ExtArgs>[]
      contest: Prisma.$ContestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contestId: number
      questionText: string
      optionA: string
      optionB: string
      optionC: string | null
      optionD: string | null
      correctOption: string
      marks: number
    }, ExtArgs["result"]["contestQuestion"]>
    composites: {}
  }

  type ContestQuestionGetPayload<S extends boolean | null | undefined | ContestQuestionDefaultArgs> = $Result.GetResult<Prisma.$ContestQuestionPayload, S>

  type ContestQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContestQuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContestQuestionCountAggregateInputType | true
    }

  export interface ContestQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContestQuestion'], meta: { name: 'ContestQuestion' } }
    /**
     * Find zero or one ContestQuestion that matches the filter.
     * @param {ContestQuestionFindUniqueArgs} args - Arguments to find a ContestQuestion
     * @example
     * // Get one ContestQuestion
     * const contestQuestion = await prisma.contestQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestQuestionFindUniqueArgs>(args: SelectSubset<T, ContestQuestionFindUniqueArgs<ExtArgs>>): Prisma__ContestQuestionClient<$Result.GetResult<Prisma.$ContestQuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContestQuestion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContestQuestionFindUniqueOrThrowArgs} args - Arguments to find a ContestQuestion
     * @example
     * // Get one ContestQuestion
     * const contestQuestion = await prisma.contestQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestQuestionClient<$Result.GetResult<Prisma.$ContestQuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContestQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestQuestionFindFirstArgs} args - Arguments to find a ContestQuestion
     * @example
     * // Get one ContestQuestion
     * const contestQuestion = await prisma.contestQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestQuestionFindFirstArgs>(args?: SelectSubset<T, ContestQuestionFindFirstArgs<ExtArgs>>): Prisma__ContestQuestionClient<$Result.GetResult<Prisma.$ContestQuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContestQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestQuestionFindFirstOrThrowArgs} args - Arguments to find a ContestQuestion
     * @example
     * // Get one ContestQuestion
     * const contestQuestion = await prisma.contestQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestQuestionClient<$Result.GetResult<Prisma.$ContestQuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContestQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContestQuestions
     * const contestQuestions = await prisma.contestQuestion.findMany()
     * 
     * // Get first 10 ContestQuestions
     * const contestQuestions = await prisma.contestQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestQuestionWithIdOnly = await prisma.contestQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestQuestionFindManyArgs>(args?: SelectSubset<T, ContestQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestQuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContestQuestion.
     * @param {ContestQuestionCreateArgs} args - Arguments to create a ContestQuestion.
     * @example
     * // Create one ContestQuestion
     * const ContestQuestion = await prisma.contestQuestion.create({
     *   data: {
     *     // ... data to create a ContestQuestion
     *   }
     * })
     * 
     */
    create<T extends ContestQuestionCreateArgs>(args: SelectSubset<T, ContestQuestionCreateArgs<ExtArgs>>): Prisma__ContestQuestionClient<$Result.GetResult<Prisma.$ContestQuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContestQuestions.
     * @param {ContestQuestionCreateManyArgs} args - Arguments to create many ContestQuestions.
     * @example
     * // Create many ContestQuestions
     * const contestQuestion = await prisma.contestQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestQuestionCreateManyArgs>(args?: SelectSubset<T, ContestQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContestQuestions and returns the data saved in the database.
     * @param {ContestQuestionCreateManyAndReturnArgs} args - Arguments to create many ContestQuestions.
     * @example
     * // Create many ContestQuestions
     * const contestQuestion = await prisma.contestQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContestQuestions and only return the `id`
     * const contestQuestionWithIdOnly = await prisma.contestQuestion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContestQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, ContestQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestQuestionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContestQuestion.
     * @param {ContestQuestionDeleteArgs} args - Arguments to delete one ContestQuestion.
     * @example
     * // Delete one ContestQuestion
     * const ContestQuestion = await prisma.contestQuestion.delete({
     *   where: {
     *     // ... filter to delete one ContestQuestion
     *   }
     * })
     * 
     */
    delete<T extends ContestQuestionDeleteArgs>(args: SelectSubset<T, ContestQuestionDeleteArgs<ExtArgs>>): Prisma__ContestQuestionClient<$Result.GetResult<Prisma.$ContestQuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContestQuestion.
     * @param {ContestQuestionUpdateArgs} args - Arguments to update one ContestQuestion.
     * @example
     * // Update one ContestQuestion
     * const contestQuestion = await prisma.contestQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestQuestionUpdateArgs>(args: SelectSubset<T, ContestQuestionUpdateArgs<ExtArgs>>): Prisma__ContestQuestionClient<$Result.GetResult<Prisma.$ContestQuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContestQuestions.
     * @param {ContestQuestionDeleteManyArgs} args - Arguments to filter ContestQuestions to delete.
     * @example
     * // Delete a few ContestQuestions
     * const { count } = await prisma.contestQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestQuestionDeleteManyArgs>(args?: SelectSubset<T, ContestQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContestQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContestQuestions
     * const contestQuestion = await prisma.contestQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestQuestionUpdateManyArgs>(args: SelectSubset<T, ContestQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContestQuestion.
     * @param {ContestQuestionUpsertArgs} args - Arguments to update or create a ContestQuestion.
     * @example
     * // Update or create a ContestQuestion
     * const contestQuestion = await prisma.contestQuestion.upsert({
     *   create: {
     *     // ... data to create a ContestQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContestQuestion we want to update
     *   }
     * })
     */
    upsert<T extends ContestQuestionUpsertArgs>(args: SelectSubset<T, ContestQuestionUpsertArgs<ExtArgs>>): Prisma__ContestQuestionClient<$Result.GetResult<Prisma.$ContestQuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContestQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestQuestionCountArgs} args - Arguments to filter ContestQuestions to count.
     * @example
     * // Count the number of ContestQuestions
     * const count = await prisma.contestQuestion.count({
     *   where: {
     *     // ... the filter for the ContestQuestions we want to count
     *   }
     * })
    **/
    count<T extends ContestQuestionCountArgs>(
      args?: Subset<T, ContestQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContestQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestQuestionAggregateArgs>(args: Subset<T, ContestQuestionAggregateArgs>): Prisma.PrismaPromise<GetContestQuestionAggregateType<T>>

    /**
     * Group by ContestQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestQuestionGroupByArgs['orderBy'] }
        : { orderBy?: ContestQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContestQuestion model
   */
  readonly fields: ContestQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContestQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contestanswer<T extends ContestQuestion$contestanswerArgs<ExtArgs> = {}>(args?: Subset<T, ContestQuestion$contestanswerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    contest<T extends ContestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestDefaultArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContestQuestion model
   */ 
  interface ContestQuestionFieldRefs {
    readonly id: FieldRef<"ContestQuestion", 'Int'>
    readonly contestId: FieldRef<"ContestQuestion", 'Int'>
    readonly questionText: FieldRef<"ContestQuestion", 'String'>
    readonly optionA: FieldRef<"ContestQuestion", 'String'>
    readonly optionB: FieldRef<"ContestQuestion", 'String'>
    readonly optionC: FieldRef<"ContestQuestion", 'String'>
    readonly optionD: FieldRef<"ContestQuestion", 'String'>
    readonly correctOption: FieldRef<"ContestQuestion", 'String'>
    readonly marks: FieldRef<"ContestQuestion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContestQuestion findUnique
   */
  export type ContestQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestQuestion
     */
    select?: ContestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ContestQuestion to fetch.
     */
    where: ContestQuestionWhereUniqueInput
  }

  /**
   * ContestQuestion findUniqueOrThrow
   */
  export type ContestQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestQuestion
     */
    select?: ContestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ContestQuestion to fetch.
     */
    where: ContestQuestionWhereUniqueInput
  }

  /**
   * ContestQuestion findFirst
   */
  export type ContestQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestQuestion
     */
    select?: ContestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ContestQuestion to fetch.
     */
    where?: ContestQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestQuestions to fetch.
     */
    orderBy?: ContestQuestionOrderByWithRelationInput | ContestQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestQuestions.
     */
    cursor?: ContestQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestQuestions.
     */
    distinct?: ContestQuestionScalarFieldEnum | ContestQuestionScalarFieldEnum[]
  }

  /**
   * ContestQuestion findFirstOrThrow
   */
  export type ContestQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestQuestion
     */
    select?: ContestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ContestQuestion to fetch.
     */
    where?: ContestQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestQuestions to fetch.
     */
    orderBy?: ContestQuestionOrderByWithRelationInput | ContestQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestQuestions.
     */
    cursor?: ContestQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestQuestions.
     */
    distinct?: ContestQuestionScalarFieldEnum | ContestQuestionScalarFieldEnum[]
  }

  /**
   * ContestQuestion findMany
   */
  export type ContestQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestQuestion
     */
    select?: ContestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ContestQuestions to fetch.
     */
    where?: ContestQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestQuestions to fetch.
     */
    orderBy?: ContestQuestionOrderByWithRelationInput | ContestQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContestQuestions.
     */
    cursor?: ContestQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestQuestions.
     */
    skip?: number
    distinct?: ContestQuestionScalarFieldEnum | ContestQuestionScalarFieldEnum[]
  }

  /**
   * ContestQuestion create
   */
  export type ContestQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestQuestion
     */
    select?: ContestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a ContestQuestion.
     */
    data: XOR<ContestQuestionCreateInput, ContestQuestionUncheckedCreateInput>
  }

  /**
   * ContestQuestion createMany
   */
  export type ContestQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContestQuestions.
     */
    data: ContestQuestionCreateManyInput | ContestQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContestQuestion createManyAndReturn
   */
  export type ContestQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestQuestion
     */
    select?: ContestQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContestQuestions.
     */
    data: ContestQuestionCreateManyInput | ContestQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContestQuestion update
   */
  export type ContestQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestQuestion
     */
    select?: ContestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a ContestQuestion.
     */
    data: XOR<ContestQuestionUpdateInput, ContestQuestionUncheckedUpdateInput>
    /**
     * Choose, which ContestQuestion to update.
     */
    where: ContestQuestionWhereUniqueInput
  }

  /**
   * ContestQuestion updateMany
   */
  export type ContestQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContestQuestions.
     */
    data: XOR<ContestQuestionUpdateManyMutationInput, ContestQuestionUncheckedUpdateManyInput>
    /**
     * Filter which ContestQuestions to update
     */
    where?: ContestQuestionWhereInput
  }

  /**
   * ContestQuestion upsert
   */
  export type ContestQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestQuestion
     */
    select?: ContestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the ContestQuestion to update in case it exists.
     */
    where: ContestQuestionWhereUniqueInput
    /**
     * In case the ContestQuestion found by the `where` argument doesn't exist, create a new ContestQuestion with this data.
     */
    create: XOR<ContestQuestionCreateInput, ContestQuestionUncheckedCreateInput>
    /**
     * In case the ContestQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestQuestionUpdateInput, ContestQuestionUncheckedUpdateInput>
  }

  /**
   * ContestQuestion delete
   */
  export type ContestQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestQuestion
     */
    select?: ContestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestQuestionInclude<ExtArgs> | null
    /**
     * Filter which ContestQuestion to delete.
     */
    where: ContestQuestionWhereUniqueInput
  }

  /**
   * ContestQuestion deleteMany
   */
  export type ContestQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestQuestions to delete
     */
    where?: ContestQuestionWhereInput
  }

  /**
   * ContestQuestion.contestanswer
   */
  export type ContestQuestion$contestanswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAnswer
     */
    select?: ContestAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAnswerInclude<ExtArgs> | null
    where?: ContestAnswerWhereInput
    orderBy?: ContestAnswerOrderByWithRelationInput | ContestAnswerOrderByWithRelationInput[]
    cursor?: ContestAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestAnswerScalarFieldEnum | ContestAnswerScalarFieldEnum[]
  }

  /**
   * ContestQuestion without action
   */
  export type ContestQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestQuestion
     */
    select?: ContestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestQuestionInclude<ExtArgs> | null
  }


  /**
   * Model ContestAttempt
   */

  export type AggregateContestAttempt = {
    _count: ContestAttemptCountAggregateOutputType | null
    _avg: ContestAttemptAvgAggregateOutputType | null
    _sum: ContestAttemptSumAggregateOutputType | null
    _min: ContestAttemptMinAggregateOutputType | null
    _max: ContestAttemptMaxAggregateOutputType | null
  }

  export type ContestAttemptAvgAggregateOutputType = {
    id: number | null
    contestId: number | null
    userId: number | null
    score: number | null
    timeTaken: number | null
  }

  export type ContestAttemptSumAggregateOutputType = {
    id: number | null
    contestId: number | null
    userId: number | null
    score: number | null
    timeTaken: number | null
  }

  export type ContestAttemptMinAggregateOutputType = {
    id: number | null
    contestId: number | null
    userId: number | null
    startedAt: Date | null
    submittedAt: Date | null
    score: number | null
    timeTaken: number | null
  }

  export type ContestAttemptMaxAggregateOutputType = {
    id: number | null
    contestId: number | null
    userId: number | null
    startedAt: Date | null
    submittedAt: Date | null
    score: number | null
    timeTaken: number | null
  }

  export type ContestAttemptCountAggregateOutputType = {
    id: number
    contestId: number
    userId: number
    startedAt: number
    submittedAt: number
    score: number
    timeTaken: number
    _all: number
  }


  export type ContestAttemptAvgAggregateInputType = {
    id?: true
    contestId?: true
    userId?: true
    score?: true
    timeTaken?: true
  }

  export type ContestAttemptSumAggregateInputType = {
    id?: true
    contestId?: true
    userId?: true
    score?: true
    timeTaken?: true
  }

  export type ContestAttemptMinAggregateInputType = {
    id?: true
    contestId?: true
    userId?: true
    startedAt?: true
    submittedAt?: true
    score?: true
    timeTaken?: true
  }

  export type ContestAttemptMaxAggregateInputType = {
    id?: true
    contestId?: true
    userId?: true
    startedAt?: true
    submittedAt?: true
    score?: true
    timeTaken?: true
  }

  export type ContestAttemptCountAggregateInputType = {
    id?: true
    contestId?: true
    userId?: true
    startedAt?: true
    submittedAt?: true
    score?: true
    timeTaken?: true
    _all?: true
  }

  export type ContestAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestAttempt to aggregate.
     */
    where?: ContestAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAttempts to fetch.
     */
    orderBy?: ContestAttemptOrderByWithRelationInput | ContestAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContestAttempts
    **/
    _count?: true | ContestAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestAttemptMaxAggregateInputType
  }

  export type GetContestAttemptAggregateType<T extends ContestAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateContestAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestAttempt[P]>
      : GetScalarType<T[P], AggregateContestAttempt[P]>
  }




  export type ContestAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestAttemptWhereInput
    orderBy?: ContestAttemptOrderByWithAggregationInput | ContestAttemptOrderByWithAggregationInput[]
    by: ContestAttemptScalarFieldEnum[] | ContestAttemptScalarFieldEnum
    having?: ContestAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestAttemptCountAggregateInputType | true
    _avg?: ContestAttemptAvgAggregateInputType
    _sum?: ContestAttemptSumAggregateInputType
    _min?: ContestAttemptMinAggregateInputType
    _max?: ContestAttemptMaxAggregateInputType
  }

  export type ContestAttemptGroupByOutputType = {
    id: number
    contestId: number
    userId: number
    startedAt: Date
    submittedAt: Date | null
    score: number | null
    timeTaken: number | null
    _count: ContestAttemptCountAggregateOutputType | null
    _avg: ContestAttemptAvgAggregateOutputType | null
    _sum: ContestAttemptSumAggregateOutputType | null
    _min: ContestAttemptMinAggregateOutputType | null
    _max: ContestAttemptMaxAggregateOutputType | null
  }

  type GetContestAttemptGroupByPayload<T extends ContestAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], ContestAttemptGroupByOutputType[P]>
        }
      >
    >


  export type ContestAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contestId?: boolean
    userId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    score?: boolean
    timeTaken?: boolean
    ContestAnswer?: boolean | ContestAttempt$ContestAnswerArgs<ExtArgs>
    contest?: boolean | ContestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ContestAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestAttempt"]>

  export type ContestAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contestId?: boolean
    userId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    score?: boolean
    timeTaken?: boolean
    contest?: boolean | ContestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestAttempt"]>

  export type ContestAttemptSelectScalar = {
    id?: boolean
    contestId?: boolean
    userId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    score?: boolean
    timeTaken?: boolean
  }

  export type ContestAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ContestAnswer?: boolean | ContestAttempt$ContestAnswerArgs<ExtArgs>
    contest?: boolean | ContestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ContestAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContestAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | ContestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContestAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContestAttempt"
    objects: {
      ContestAnswer: Prisma.$ContestAnswerPayload<ExtArgs>[]
      contest: Prisma.$ContestPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contestId: number
      userId: number
      startedAt: Date
      submittedAt: Date | null
      score: number | null
      timeTaken: number | null
    }, ExtArgs["result"]["contestAttempt"]>
    composites: {}
  }

  type ContestAttemptGetPayload<S extends boolean | null | undefined | ContestAttemptDefaultArgs> = $Result.GetResult<Prisma.$ContestAttemptPayload, S>

  type ContestAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContestAttemptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContestAttemptCountAggregateInputType | true
    }

  export interface ContestAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContestAttempt'], meta: { name: 'ContestAttempt' } }
    /**
     * Find zero or one ContestAttempt that matches the filter.
     * @param {ContestAttemptFindUniqueArgs} args - Arguments to find a ContestAttempt
     * @example
     * // Get one ContestAttempt
     * const contestAttempt = await prisma.contestAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestAttemptFindUniqueArgs>(args: SelectSubset<T, ContestAttemptFindUniqueArgs<ExtArgs>>): Prisma__ContestAttemptClient<$Result.GetResult<Prisma.$ContestAttemptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContestAttempt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContestAttemptFindUniqueOrThrowArgs} args - Arguments to find a ContestAttempt
     * @example
     * // Get one ContestAttempt
     * const contestAttempt = await prisma.contestAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestAttemptClient<$Result.GetResult<Prisma.$ContestAttemptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContestAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAttemptFindFirstArgs} args - Arguments to find a ContestAttempt
     * @example
     * // Get one ContestAttempt
     * const contestAttempt = await prisma.contestAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestAttemptFindFirstArgs>(args?: SelectSubset<T, ContestAttemptFindFirstArgs<ExtArgs>>): Prisma__ContestAttemptClient<$Result.GetResult<Prisma.$ContestAttemptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContestAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAttemptFindFirstOrThrowArgs} args - Arguments to find a ContestAttempt
     * @example
     * // Get one ContestAttempt
     * const contestAttempt = await prisma.contestAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestAttemptClient<$Result.GetResult<Prisma.$ContestAttemptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContestAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContestAttempts
     * const contestAttempts = await prisma.contestAttempt.findMany()
     * 
     * // Get first 10 ContestAttempts
     * const contestAttempts = await prisma.contestAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestAttemptWithIdOnly = await prisma.contestAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestAttemptFindManyArgs>(args?: SelectSubset<T, ContestAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestAttemptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContestAttempt.
     * @param {ContestAttemptCreateArgs} args - Arguments to create a ContestAttempt.
     * @example
     * // Create one ContestAttempt
     * const ContestAttempt = await prisma.contestAttempt.create({
     *   data: {
     *     // ... data to create a ContestAttempt
     *   }
     * })
     * 
     */
    create<T extends ContestAttemptCreateArgs>(args: SelectSubset<T, ContestAttemptCreateArgs<ExtArgs>>): Prisma__ContestAttemptClient<$Result.GetResult<Prisma.$ContestAttemptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContestAttempts.
     * @param {ContestAttemptCreateManyArgs} args - Arguments to create many ContestAttempts.
     * @example
     * // Create many ContestAttempts
     * const contestAttempt = await prisma.contestAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestAttemptCreateManyArgs>(args?: SelectSubset<T, ContestAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContestAttempts and returns the data saved in the database.
     * @param {ContestAttemptCreateManyAndReturnArgs} args - Arguments to create many ContestAttempts.
     * @example
     * // Create many ContestAttempts
     * const contestAttempt = await prisma.contestAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContestAttempts and only return the `id`
     * const contestAttemptWithIdOnly = await prisma.contestAttempt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContestAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, ContestAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestAttemptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContestAttempt.
     * @param {ContestAttemptDeleteArgs} args - Arguments to delete one ContestAttempt.
     * @example
     * // Delete one ContestAttempt
     * const ContestAttempt = await prisma.contestAttempt.delete({
     *   where: {
     *     // ... filter to delete one ContestAttempt
     *   }
     * })
     * 
     */
    delete<T extends ContestAttemptDeleteArgs>(args: SelectSubset<T, ContestAttemptDeleteArgs<ExtArgs>>): Prisma__ContestAttemptClient<$Result.GetResult<Prisma.$ContestAttemptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContestAttempt.
     * @param {ContestAttemptUpdateArgs} args - Arguments to update one ContestAttempt.
     * @example
     * // Update one ContestAttempt
     * const contestAttempt = await prisma.contestAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestAttemptUpdateArgs>(args: SelectSubset<T, ContestAttemptUpdateArgs<ExtArgs>>): Prisma__ContestAttemptClient<$Result.GetResult<Prisma.$ContestAttemptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContestAttempts.
     * @param {ContestAttemptDeleteManyArgs} args - Arguments to filter ContestAttempts to delete.
     * @example
     * // Delete a few ContestAttempts
     * const { count } = await prisma.contestAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestAttemptDeleteManyArgs>(args?: SelectSubset<T, ContestAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContestAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContestAttempts
     * const contestAttempt = await prisma.contestAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestAttemptUpdateManyArgs>(args: SelectSubset<T, ContestAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContestAttempt.
     * @param {ContestAttemptUpsertArgs} args - Arguments to update or create a ContestAttempt.
     * @example
     * // Update or create a ContestAttempt
     * const contestAttempt = await prisma.contestAttempt.upsert({
     *   create: {
     *     // ... data to create a ContestAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContestAttempt we want to update
     *   }
     * })
     */
    upsert<T extends ContestAttemptUpsertArgs>(args: SelectSubset<T, ContestAttemptUpsertArgs<ExtArgs>>): Prisma__ContestAttemptClient<$Result.GetResult<Prisma.$ContestAttemptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContestAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAttemptCountArgs} args - Arguments to filter ContestAttempts to count.
     * @example
     * // Count the number of ContestAttempts
     * const count = await prisma.contestAttempt.count({
     *   where: {
     *     // ... the filter for the ContestAttempts we want to count
     *   }
     * })
    **/
    count<T extends ContestAttemptCountArgs>(
      args?: Subset<T, ContestAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContestAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestAttemptAggregateArgs>(args: Subset<T, ContestAttemptAggregateArgs>): Prisma.PrismaPromise<GetContestAttemptAggregateType<T>>

    /**
     * Group by ContestAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestAttemptGroupByArgs['orderBy'] }
        : { orderBy?: ContestAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContestAttempt model
   */
  readonly fields: ContestAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContestAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ContestAnswer<T extends ContestAttempt$ContestAnswerArgs<ExtArgs> = {}>(args?: Subset<T, ContestAttempt$ContestAnswerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    contest<T extends ContestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestDefaultArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContestAttempt model
   */ 
  interface ContestAttemptFieldRefs {
    readonly id: FieldRef<"ContestAttempt", 'Int'>
    readonly contestId: FieldRef<"ContestAttempt", 'Int'>
    readonly userId: FieldRef<"ContestAttempt", 'Int'>
    readonly startedAt: FieldRef<"ContestAttempt", 'DateTime'>
    readonly submittedAt: FieldRef<"ContestAttempt", 'DateTime'>
    readonly score: FieldRef<"ContestAttempt", 'Int'>
    readonly timeTaken: FieldRef<"ContestAttempt", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContestAttempt findUnique
   */
  export type ContestAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAttempt
     */
    select?: ContestAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ContestAttempt to fetch.
     */
    where: ContestAttemptWhereUniqueInput
  }

  /**
   * ContestAttempt findUniqueOrThrow
   */
  export type ContestAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAttempt
     */
    select?: ContestAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ContestAttempt to fetch.
     */
    where: ContestAttemptWhereUniqueInput
  }

  /**
   * ContestAttempt findFirst
   */
  export type ContestAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAttempt
     */
    select?: ContestAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ContestAttempt to fetch.
     */
    where?: ContestAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAttempts to fetch.
     */
    orderBy?: ContestAttemptOrderByWithRelationInput | ContestAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestAttempts.
     */
    cursor?: ContestAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestAttempts.
     */
    distinct?: ContestAttemptScalarFieldEnum | ContestAttemptScalarFieldEnum[]
  }

  /**
   * ContestAttempt findFirstOrThrow
   */
  export type ContestAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAttempt
     */
    select?: ContestAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ContestAttempt to fetch.
     */
    where?: ContestAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAttempts to fetch.
     */
    orderBy?: ContestAttemptOrderByWithRelationInput | ContestAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestAttempts.
     */
    cursor?: ContestAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestAttempts.
     */
    distinct?: ContestAttemptScalarFieldEnum | ContestAttemptScalarFieldEnum[]
  }

  /**
   * ContestAttempt findMany
   */
  export type ContestAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAttempt
     */
    select?: ContestAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ContestAttempts to fetch.
     */
    where?: ContestAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAttempts to fetch.
     */
    orderBy?: ContestAttemptOrderByWithRelationInput | ContestAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContestAttempts.
     */
    cursor?: ContestAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAttempts.
     */
    skip?: number
    distinct?: ContestAttemptScalarFieldEnum | ContestAttemptScalarFieldEnum[]
  }

  /**
   * ContestAttempt create
   */
  export type ContestAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAttempt
     */
    select?: ContestAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a ContestAttempt.
     */
    data: XOR<ContestAttemptCreateInput, ContestAttemptUncheckedCreateInput>
  }

  /**
   * ContestAttempt createMany
   */
  export type ContestAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContestAttempts.
     */
    data: ContestAttemptCreateManyInput | ContestAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContestAttempt createManyAndReturn
   */
  export type ContestAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAttempt
     */
    select?: ContestAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContestAttempts.
     */
    data: ContestAttemptCreateManyInput | ContestAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContestAttempt update
   */
  export type ContestAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAttempt
     */
    select?: ContestAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a ContestAttempt.
     */
    data: XOR<ContestAttemptUpdateInput, ContestAttemptUncheckedUpdateInput>
    /**
     * Choose, which ContestAttempt to update.
     */
    where: ContestAttemptWhereUniqueInput
  }

  /**
   * ContestAttempt updateMany
   */
  export type ContestAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContestAttempts.
     */
    data: XOR<ContestAttemptUpdateManyMutationInput, ContestAttemptUncheckedUpdateManyInput>
    /**
     * Filter which ContestAttempts to update
     */
    where?: ContestAttemptWhereInput
  }

  /**
   * ContestAttempt upsert
   */
  export type ContestAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAttempt
     */
    select?: ContestAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the ContestAttempt to update in case it exists.
     */
    where: ContestAttemptWhereUniqueInput
    /**
     * In case the ContestAttempt found by the `where` argument doesn't exist, create a new ContestAttempt with this data.
     */
    create: XOR<ContestAttemptCreateInput, ContestAttemptUncheckedCreateInput>
    /**
     * In case the ContestAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestAttemptUpdateInput, ContestAttemptUncheckedUpdateInput>
  }

  /**
   * ContestAttempt delete
   */
  export type ContestAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAttempt
     */
    select?: ContestAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAttemptInclude<ExtArgs> | null
    /**
     * Filter which ContestAttempt to delete.
     */
    where: ContestAttemptWhereUniqueInput
  }

  /**
   * ContestAttempt deleteMany
   */
  export type ContestAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestAttempts to delete
     */
    where?: ContestAttemptWhereInput
  }

  /**
   * ContestAttempt.ContestAnswer
   */
  export type ContestAttempt$ContestAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAnswer
     */
    select?: ContestAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAnswerInclude<ExtArgs> | null
    where?: ContestAnswerWhereInput
    orderBy?: ContestAnswerOrderByWithRelationInput | ContestAnswerOrderByWithRelationInput[]
    cursor?: ContestAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestAnswerScalarFieldEnum | ContestAnswerScalarFieldEnum[]
  }

  /**
   * ContestAttempt without action
   */
  export type ContestAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAttempt
     */
    select?: ContestAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAttemptInclude<ExtArgs> | null
  }


  /**
   * Model ContestAnswer
   */

  export type AggregateContestAnswer = {
    _count: ContestAnswerCountAggregateOutputType | null
    _avg: ContestAnswerAvgAggregateOutputType | null
    _sum: ContestAnswerSumAggregateOutputType | null
    _min: ContestAnswerMinAggregateOutputType | null
    _max: ContestAnswerMaxAggregateOutputType | null
  }

  export type ContestAnswerAvgAggregateOutputType = {
    id: number | null
    attemptId: number | null
    questionId: number | null
  }

  export type ContestAnswerSumAggregateOutputType = {
    id: number | null
    attemptId: number | null
    questionId: number | null
  }

  export type ContestAnswerMinAggregateOutputType = {
    id: number | null
    attemptId: number | null
    questionId: number | null
    selectedOption: string | null
    isCorrect: boolean | null
  }

  export type ContestAnswerMaxAggregateOutputType = {
    id: number | null
    attemptId: number | null
    questionId: number | null
    selectedOption: string | null
    isCorrect: boolean | null
  }

  export type ContestAnswerCountAggregateOutputType = {
    id: number
    attemptId: number
    questionId: number
    selectedOption: number
    isCorrect: number
    _all: number
  }


  export type ContestAnswerAvgAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
  }

  export type ContestAnswerSumAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
  }

  export type ContestAnswerMinAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
    selectedOption?: true
    isCorrect?: true
  }

  export type ContestAnswerMaxAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
    selectedOption?: true
    isCorrect?: true
  }

  export type ContestAnswerCountAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
    selectedOption?: true
    isCorrect?: true
    _all?: true
  }

  export type ContestAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestAnswer to aggregate.
     */
    where?: ContestAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAnswers to fetch.
     */
    orderBy?: ContestAnswerOrderByWithRelationInput | ContestAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContestAnswers
    **/
    _count?: true | ContestAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestAnswerMaxAggregateInputType
  }

  export type GetContestAnswerAggregateType<T extends ContestAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateContestAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestAnswer[P]>
      : GetScalarType<T[P], AggregateContestAnswer[P]>
  }




  export type ContestAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestAnswerWhereInput
    orderBy?: ContestAnswerOrderByWithAggregationInput | ContestAnswerOrderByWithAggregationInput[]
    by: ContestAnswerScalarFieldEnum[] | ContestAnswerScalarFieldEnum
    having?: ContestAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestAnswerCountAggregateInputType | true
    _avg?: ContestAnswerAvgAggregateInputType
    _sum?: ContestAnswerSumAggregateInputType
    _min?: ContestAnswerMinAggregateInputType
    _max?: ContestAnswerMaxAggregateInputType
  }

  export type ContestAnswerGroupByOutputType = {
    id: number
    attemptId: number
    questionId: number
    selectedOption: string
    isCorrect: boolean
    _count: ContestAnswerCountAggregateOutputType | null
    _avg: ContestAnswerAvgAggregateOutputType | null
    _sum: ContestAnswerSumAggregateOutputType | null
    _min: ContestAnswerMinAggregateOutputType | null
    _max: ContestAnswerMaxAggregateOutputType | null
  }

  type GetContestAnswerGroupByPayload<T extends ContestAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], ContestAnswerGroupByOutputType[P]>
        }
      >
    >


  export type ContestAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    questionId?: boolean
    selectedOption?: boolean
    isCorrect?: boolean
    attempt?: boolean | ContestAttemptDefaultArgs<ExtArgs>
    question?: boolean | ContestQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestAnswer"]>

  export type ContestAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    questionId?: boolean
    selectedOption?: boolean
    isCorrect?: boolean
    attempt?: boolean | ContestAttemptDefaultArgs<ExtArgs>
    question?: boolean | ContestQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestAnswer"]>

  export type ContestAnswerSelectScalar = {
    id?: boolean
    attemptId?: boolean
    questionId?: boolean
    selectedOption?: boolean
    isCorrect?: boolean
  }

  export type ContestAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | ContestAttemptDefaultArgs<ExtArgs>
    question?: boolean | ContestQuestionDefaultArgs<ExtArgs>
  }
  export type ContestAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | ContestAttemptDefaultArgs<ExtArgs>
    question?: boolean | ContestQuestionDefaultArgs<ExtArgs>
  }

  export type $ContestAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContestAnswer"
    objects: {
      attempt: Prisma.$ContestAttemptPayload<ExtArgs>
      question: Prisma.$ContestQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      attemptId: number
      questionId: number
      selectedOption: string
      isCorrect: boolean
    }, ExtArgs["result"]["contestAnswer"]>
    composites: {}
  }

  type ContestAnswerGetPayload<S extends boolean | null | undefined | ContestAnswerDefaultArgs> = $Result.GetResult<Prisma.$ContestAnswerPayload, S>

  type ContestAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContestAnswerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContestAnswerCountAggregateInputType | true
    }

  export interface ContestAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContestAnswer'], meta: { name: 'ContestAnswer' } }
    /**
     * Find zero or one ContestAnswer that matches the filter.
     * @param {ContestAnswerFindUniqueArgs} args - Arguments to find a ContestAnswer
     * @example
     * // Get one ContestAnswer
     * const contestAnswer = await prisma.contestAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestAnswerFindUniqueArgs>(args: SelectSubset<T, ContestAnswerFindUniqueArgs<ExtArgs>>): Prisma__ContestAnswerClient<$Result.GetResult<Prisma.$ContestAnswerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContestAnswer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContestAnswerFindUniqueOrThrowArgs} args - Arguments to find a ContestAnswer
     * @example
     * // Get one ContestAnswer
     * const contestAnswer = await prisma.contestAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestAnswerClient<$Result.GetResult<Prisma.$ContestAnswerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContestAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAnswerFindFirstArgs} args - Arguments to find a ContestAnswer
     * @example
     * // Get one ContestAnswer
     * const contestAnswer = await prisma.contestAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestAnswerFindFirstArgs>(args?: SelectSubset<T, ContestAnswerFindFirstArgs<ExtArgs>>): Prisma__ContestAnswerClient<$Result.GetResult<Prisma.$ContestAnswerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContestAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAnswerFindFirstOrThrowArgs} args - Arguments to find a ContestAnswer
     * @example
     * // Get one ContestAnswer
     * const contestAnswer = await prisma.contestAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestAnswerClient<$Result.GetResult<Prisma.$ContestAnswerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContestAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContestAnswers
     * const contestAnswers = await prisma.contestAnswer.findMany()
     * 
     * // Get first 10 ContestAnswers
     * const contestAnswers = await prisma.contestAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestAnswerWithIdOnly = await prisma.contestAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestAnswerFindManyArgs>(args?: SelectSubset<T, ContestAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestAnswerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContestAnswer.
     * @param {ContestAnswerCreateArgs} args - Arguments to create a ContestAnswer.
     * @example
     * // Create one ContestAnswer
     * const ContestAnswer = await prisma.contestAnswer.create({
     *   data: {
     *     // ... data to create a ContestAnswer
     *   }
     * })
     * 
     */
    create<T extends ContestAnswerCreateArgs>(args: SelectSubset<T, ContestAnswerCreateArgs<ExtArgs>>): Prisma__ContestAnswerClient<$Result.GetResult<Prisma.$ContestAnswerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContestAnswers.
     * @param {ContestAnswerCreateManyArgs} args - Arguments to create many ContestAnswers.
     * @example
     * // Create many ContestAnswers
     * const contestAnswer = await prisma.contestAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestAnswerCreateManyArgs>(args?: SelectSubset<T, ContestAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContestAnswers and returns the data saved in the database.
     * @param {ContestAnswerCreateManyAndReturnArgs} args - Arguments to create many ContestAnswers.
     * @example
     * // Create many ContestAnswers
     * const contestAnswer = await prisma.contestAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContestAnswers and only return the `id`
     * const contestAnswerWithIdOnly = await prisma.contestAnswer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContestAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, ContestAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestAnswerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContestAnswer.
     * @param {ContestAnswerDeleteArgs} args - Arguments to delete one ContestAnswer.
     * @example
     * // Delete one ContestAnswer
     * const ContestAnswer = await prisma.contestAnswer.delete({
     *   where: {
     *     // ... filter to delete one ContestAnswer
     *   }
     * })
     * 
     */
    delete<T extends ContestAnswerDeleteArgs>(args: SelectSubset<T, ContestAnswerDeleteArgs<ExtArgs>>): Prisma__ContestAnswerClient<$Result.GetResult<Prisma.$ContestAnswerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContestAnswer.
     * @param {ContestAnswerUpdateArgs} args - Arguments to update one ContestAnswer.
     * @example
     * // Update one ContestAnswer
     * const contestAnswer = await prisma.contestAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestAnswerUpdateArgs>(args: SelectSubset<T, ContestAnswerUpdateArgs<ExtArgs>>): Prisma__ContestAnswerClient<$Result.GetResult<Prisma.$ContestAnswerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContestAnswers.
     * @param {ContestAnswerDeleteManyArgs} args - Arguments to filter ContestAnswers to delete.
     * @example
     * // Delete a few ContestAnswers
     * const { count } = await prisma.contestAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestAnswerDeleteManyArgs>(args?: SelectSubset<T, ContestAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContestAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContestAnswers
     * const contestAnswer = await prisma.contestAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestAnswerUpdateManyArgs>(args: SelectSubset<T, ContestAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContestAnswer.
     * @param {ContestAnswerUpsertArgs} args - Arguments to update or create a ContestAnswer.
     * @example
     * // Update or create a ContestAnswer
     * const contestAnswer = await prisma.contestAnswer.upsert({
     *   create: {
     *     // ... data to create a ContestAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContestAnswer we want to update
     *   }
     * })
     */
    upsert<T extends ContestAnswerUpsertArgs>(args: SelectSubset<T, ContestAnswerUpsertArgs<ExtArgs>>): Prisma__ContestAnswerClient<$Result.GetResult<Prisma.$ContestAnswerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContestAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAnswerCountArgs} args - Arguments to filter ContestAnswers to count.
     * @example
     * // Count the number of ContestAnswers
     * const count = await prisma.contestAnswer.count({
     *   where: {
     *     // ... the filter for the ContestAnswers we want to count
     *   }
     * })
    **/
    count<T extends ContestAnswerCountArgs>(
      args?: Subset<T, ContestAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContestAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestAnswerAggregateArgs>(args: Subset<T, ContestAnswerAggregateArgs>): Prisma.PrismaPromise<GetContestAnswerAggregateType<T>>

    /**
     * Group by ContestAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestAnswerGroupByArgs['orderBy'] }
        : { orderBy?: ContestAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContestAnswer model
   */
  readonly fields: ContestAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContestAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempt<T extends ContestAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestAttemptDefaultArgs<ExtArgs>>): Prisma__ContestAttemptClient<$Result.GetResult<Prisma.$ContestAttemptPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    question<T extends ContestQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestQuestionDefaultArgs<ExtArgs>>): Prisma__ContestQuestionClient<$Result.GetResult<Prisma.$ContestQuestionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContestAnswer model
   */ 
  interface ContestAnswerFieldRefs {
    readonly id: FieldRef<"ContestAnswer", 'Int'>
    readonly attemptId: FieldRef<"ContestAnswer", 'Int'>
    readonly questionId: FieldRef<"ContestAnswer", 'Int'>
    readonly selectedOption: FieldRef<"ContestAnswer", 'String'>
    readonly isCorrect: FieldRef<"ContestAnswer", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ContestAnswer findUnique
   */
  export type ContestAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAnswer
     */
    select?: ContestAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ContestAnswer to fetch.
     */
    where: ContestAnswerWhereUniqueInput
  }

  /**
   * ContestAnswer findUniqueOrThrow
   */
  export type ContestAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAnswer
     */
    select?: ContestAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ContestAnswer to fetch.
     */
    where: ContestAnswerWhereUniqueInput
  }

  /**
   * ContestAnswer findFirst
   */
  export type ContestAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAnswer
     */
    select?: ContestAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ContestAnswer to fetch.
     */
    where?: ContestAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAnswers to fetch.
     */
    orderBy?: ContestAnswerOrderByWithRelationInput | ContestAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestAnswers.
     */
    cursor?: ContestAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestAnswers.
     */
    distinct?: ContestAnswerScalarFieldEnum | ContestAnswerScalarFieldEnum[]
  }

  /**
   * ContestAnswer findFirstOrThrow
   */
  export type ContestAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAnswer
     */
    select?: ContestAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ContestAnswer to fetch.
     */
    where?: ContestAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAnswers to fetch.
     */
    orderBy?: ContestAnswerOrderByWithRelationInput | ContestAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestAnswers.
     */
    cursor?: ContestAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestAnswers.
     */
    distinct?: ContestAnswerScalarFieldEnum | ContestAnswerScalarFieldEnum[]
  }

  /**
   * ContestAnswer findMany
   */
  export type ContestAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAnswer
     */
    select?: ContestAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ContestAnswers to fetch.
     */
    where?: ContestAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAnswers to fetch.
     */
    orderBy?: ContestAnswerOrderByWithRelationInput | ContestAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContestAnswers.
     */
    cursor?: ContestAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAnswers.
     */
    skip?: number
    distinct?: ContestAnswerScalarFieldEnum | ContestAnswerScalarFieldEnum[]
  }

  /**
   * ContestAnswer create
   */
  export type ContestAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAnswer
     */
    select?: ContestAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a ContestAnswer.
     */
    data: XOR<ContestAnswerCreateInput, ContestAnswerUncheckedCreateInput>
  }

  /**
   * ContestAnswer createMany
   */
  export type ContestAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContestAnswers.
     */
    data: ContestAnswerCreateManyInput | ContestAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContestAnswer createManyAndReturn
   */
  export type ContestAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAnswer
     */
    select?: ContestAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContestAnswers.
     */
    data: ContestAnswerCreateManyInput | ContestAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContestAnswer update
   */
  export type ContestAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAnswer
     */
    select?: ContestAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a ContestAnswer.
     */
    data: XOR<ContestAnswerUpdateInput, ContestAnswerUncheckedUpdateInput>
    /**
     * Choose, which ContestAnswer to update.
     */
    where: ContestAnswerWhereUniqueInput
  }

  /**
   * ContestAnswer updateMany
   */
  export type ContestAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContestAnswers.
     */
    data: XOR<ContestAnswerUpdateManyMutationInput, ContestAnswerUncheckedUpdateManyInput>
    /**
     * Filter which ContestAnswers to update
     */
    where?: ContestAnswerWhereInput
  }

  /**
   * ContestAnswer upsert
   */
  export type ContestAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAnswer
     */
    select?: ContestAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the ContestAnswer to update in case it exists.
     */
    where: ContestAnswerWhereUniqueInput
    /**
     * In case the ContestAnswer found by the `where` argument doesn't exist, create a new ContestAnswer with this data.
     */
    create: XOR<ContestAnswerCreateInput, ContestAnswerUncheckedCreateInput>
    /**
     * In case the ContestAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestAnswerUpdateInput, ContestAnswerUncheckedUpdateInput>
  }

  /**
   * ContestAnswer delete
   */
  export type ContestAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAnswer
     */
    select?: ContestAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAnswerInclude<ExtArgs> | null
    /**
     * Filter which ContestAnswer to delete.
     */
    where: ContestAnswerWhereUniqueInput
  }

  /**
   * ContestAnswer deleteMany
   */
  export type ContestAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestAnswers to delete
     */
    where?: ContestAnswerWhereInput
  }

  /**
   * ContestAnswer without action
   */
  export type ContestAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAnswer
     */
    select?: ContestAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAnswerInclude<ExtArgs> | null
  }


  /**
   * Model Challenge
   */

  export type AggregateChallenge = {
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  export type ChallengeAvgAggregateOutputType = {
    id: number | null
    points: number | null
  }

  export type ChallengeSumAggregateOutputType = {
    id: number | null
    points: number | null
  }

  export type ChallengeMinAggregateOutputType = {
    id: number | null
    title: string | null
    type: $Enums.ChallengeType | null
    category: string | null
    difficulty: string | null
    points: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
  }

  export type ChallengeMaxAggregateOutputType = {
    id: number | null
    title: string | null
    type: $Enums.ChallengeType | null
    category: string | null
    difficulty: string | null
    points: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
  }

  export type ChallengeCountAggregateOutputType = {
    id: number
    title: number
    type: number
    category: number
    difficulty: number
    points: number
    startDate: number
    endDate: number
    isActive: number
    _all: number
  }


  export type ChallengeAvgAggregateInputType = {
    id?: true
    points?: true
  }

  export type ChallengeSumAggregateInputType = {
    id?: true
    points?: true
  }

  export type ChallengeMinAggregateInputType = {
    id?: true
    title?: true
    type?: true
    category?: true
    difficulty?: true
    points?: true
    startDate?: true
    endDate?: true
    isActive?: true
  }

  export type ChallengeMaxAggregateInputType = {
    id?: true
    title?: true
    type?: true
    category?: true
    difficulty?: true
    points?: true
    startDate?: true
    endDate?: true
    isActive?: true
  }

  export type ChallengeCountAggregateInputType = {
    id?: true
    title?: true
    type?: true
    category?: true
    difficulty?: true
    points?: true
    startDate?: true
    endDate?: true
    isActive?: true
    _all?: true
  }

  export type ChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenge to aggregate.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Challenges
    **/
    _count?: true | ChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeMaxAggregateInputType
  }

  export type GetChallengeAggregateType<T extends ChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallenge[P]>
      : GetScalarType<T[P], AggregateChallenge[P]>
  }




  export type ChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithAggregationInput | ChallengeOrderByWithAggregationInput[]
    by: ChallengeScalarFieldEnum[] | ChallengeScalarFieldEnum
    having?: ChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeCountAggregateInputType | true
    _avg?: ChallengeAvgAggregateInputType
    _sum?: ChallengeSumAggregateInputType
    _min?: ChallengeMinAggregateInputType
    _max?: ChallengeMaxAggregateInputType
  }

  export type ChallengeGroupByOutputType = {
    id: number
    title: string
    type: $Enums.ChallengeType
    category: string
    difficulty: string
    points: number
    startDate: Date
    endDate: Date
    isActive: boolean
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  type GetChallengeGroupByPayload<T extends ChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    category?: boolean
    difficulty?: boolean
    points?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    ChallengeAttempt?: boolean | Challenge$ChallengeAttemptArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    category?: boolean
    difficulty?: boolean
    points?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectScalar = {
    id?: boolean
    title?: boolean
    type?: boolean
    category?: boolean
    difficulty?: boolean
    points?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
  }

  export type ChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ChallengeAttempt?: boolean | Challenge$ChallengeAttemptArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Challenge"
    objects: {
      ChallengeAttempt: Prisma.$ChallengeAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      type: $Enums.ChallengeType
      category: string
      difficulty: string
      points: number
      startDate: Date
      endDate: Date
      isActive: boolean
    }, ExtArgs["result"]["challenge"]>
    composites: {}
  }

  type ChallengeGetPayload<S extends boolean | null | undefined | ChallengeDefaultArgs> = $Result.GetResult<Prisma.$ChallengePayload, S>

  type ChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChallengeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChallengeCountAggregateInputType | true
    }

  export interface ChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Challenge'], meta: { name: 'Challenge' } }
    /**
     * Find zero or one Challenge that matches the filter.
     * @param {ChallengeFindUniqueArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeFindUniqueArgs>(args: SelectSubset<T, ChallengeFindUniqueArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Challenge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChallengeFindUniqueOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Challenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeFindFirstArgs>(args?: SelectSubset<T, ChallengeFindFirstArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Challenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Challenges
     * const challenges = await prisma.challenge.findMany()
     * 
     * // Get first 10 Challenges
     * const challenges = await prisma.challenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeWithIdOnly = await prisma.challenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeFindManyArgs>(args?: SelectSubset<T, ChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Challenge.
     * @param {ChallengeCreateArgs} args - Arguments to create a Challenge.
     * @example
     * // Create one Challenge
     * const Challenge = await prisma.challenge.create({
     *   data: {
     *     // ... data to create a Challenge
     *   }
     * })
     * 
     */
    create<T extends ChallengeCreateArgs>(args: SelectSubset<T, ChallengeCreateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Challenges.
     * @param {ChallengeCreateManyArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeCreateManyArgs>(args?: SelectSubset<T, ChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Challenges and returns the data saved in the database.
     * @param {ChallengeCreateManyAndReturnArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Challenges and only return the `id`
     * const challengeWithIdOnly = await prisma.challenge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Challenge.
     * @param {ChallengeDeleteArgs} args - Arguments to delete one Challenge.
     * @example
     * // Delete one Challenge
     * const Challenge = await prisma.challenge.delete({
     *   where: {
     *     // ... filter to delete one Challenge
     *   }
     * })
     * 
     */
    delete<T extends ChallengeDeleteArgs>(args: SelectSubset<T, ChallengeDeleteArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Challenge.
     * @param {ChallengeUpdateArgs} args - Arguments to update one Challenge.
     * @example
     * // Update one Challenge
     * const challenge = await prisma.challenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeUpdateArgs>(args: SelectSubset<T, ChallengeUpdateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Challenges.
     * @param {ChallengeDeleteManyArgs} args - Arguments to filter Challenges to delete.
     * @example
     * // Delete a few Challenges
     * const { count } = await prisma.challenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeDeleteManyArgs>(args?: SelectSubset<T, ChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeUpdateManyArgs>(args: SelectSubset<T, ChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Challenge.
     * @param {ChallengeUpsertArgs} args - Arguments to update or create a Challenge.
     * @example
     * // Update or create a Challenge
     * const challenge = await prisma.challenge.upsert({
     *   create: {
     *     // ... data to create a Challenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Challenge we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeUpsertArgs>(args: SelectSubset<T, ChallengeUpsertArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeCountArgs} args - Arguments to filter Challenges to count.
     * @example
     * // Count the number of Challenges
     * const count = await prisma.challenge.count({
     *   where: {
     *     // ... the filter for the Challenges we want to count
     *   }
     * })
    **/
    count<T extends ChallengeCountArgs>(
      args?: Subset<T, ChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeAggregateArgs>(args: Subset<T, ChallengeAggregateArgs>): Prisma.PrismaPromise<GetChallengeAggregateType<T>>

    /**
     * Group by Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Challenge model
   */
  readonly fields: ChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Challenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ChallengeAttempt<T extends Challenge$ChallengeAttemptArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$ChallengeAttemptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Challenge model
   */ 
  interface ChallengeFieldRefs {
    readonly id: FieldRef<"Challenge", 'Int'>
    readonly title: FieldRef<"Challenge", 'String'>
    readonly type: FieldRef<"Challenge", 'ChallengeType'>
    readonly category: FieldRef<"Challenge", 'String'>
    readonly difficulty: FieldRef<"Challenge", 'String'>
    readonly points: FieldRef<"Challenge", 'Int'>
    readonly startDate: FieldRef<"Challenge", 'DateTime'>
    readonly endDate: FieldRef<"Challenge", 'DateTime'>
    readonly isActive: FieldRef<"Challenge", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Challenge findUnique
   */
  export type ChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findUniqueOrThrow
   */
  export type ChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findFirst
   */
  export type ChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findFirstOrThrow
   */
  export type ChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findMany
   */
  export type ChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenges to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge create
   */
  export type ChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a Challenge.
     */
    data: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
  }

  /**
   * Challenge createMany
   */
  export type ChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Challenge createManyAndReturn
   */
  export type ChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Challenge update
   */
  export type ChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a Challenge.
     */
    data: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
    /**
     * Choose, which Challenge to update.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge updateMany
   */
  export type ChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput
  }

  /**
   * Challenge upsert
   */
  export type ChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the Challenge to update in case it exists.
     */
    where: ChallengeWhereUniqueInput
    /**
     * In case the Challenge found by the `where` argument doesn't exist, create a new Challenge with this data.
     */
    create: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
    /**
     * In case the Challenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
  }

  /**
   * Challenge delete
   */
  export type ChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter which Challenge to delete.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge deleteMany
   */
  export type ChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenges to delete
     */
    where?: ChallengeWhereInput
  }

  /**
   * Challenge.ChallengeAttempt
   */
  export type Challenge$ChallengeAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAttempt
     */
    select?: ChallengeAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAttemptInclude<ExtArgs> | null
    where?: ChallengeAttemptWhereInput
    orderBy?: ChallengeAttemptOrderByWithRelationInput | ChallengeAttemptOrderByWithRelationInput[]
    cursor?: ChallengeAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeAttemptScalarFieldEnum | ChallengeAttemptScalarFieldEnum[]
  }

  /**
   * Challenge without action
   */
  export type ChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeAttempt
   */

  export type AggregateChallengeAttempt = {
    _count: ChallengeAttemptCountAggregateOutputType | null
    _avg: ChallengeAttemptAvgAggregateOutputType | null
    _sum: ChallengeAttemptSumAggregateOutputType | null
    _min: ChallengeAttemptMinAggregateOutputType | null
    _max: ChallengeAttemptMaxAggregateOutputType | null
  }

  export type ChallengeAttemptAvgAggregateOutputType = {
    id: number | null
    challengeId: number | null
    userId: number | null
    earnedPoints: number | null
  }

  export type ChallengeAttemptSumAggregateOutputType = {
    id: number | null
    challengeId: number | null
    userId: number | null
    earnedPoints: number | null
  }

  export type ChallengeAttemptMinAggregateOutputType = {
    id: number | null
    challengeId: number | null
    userId: number | null
    completedAt: Date | null
    earnedPoints: number | null
  }

  export type ChallengeAttemptMaxAggregateOutputType = {
    id: number | null
    challengeId: number | null
    userId: number | null
    completedAt: Date | null
    earnedPoints: number | null
  }

  export type ChallengeAttemptCountAggregateOutputType = {
    id: number
    challengeId: number
    userId: number
    completedAt: number
    earnedPoints: number
    _all: number
  }


  export type ChallengeAttemptAvgAggregateInputType = {
    id?: true
    challengeId?: true
    userId?: true
    earnedPoints?: true
  }

  export type ChallengeAttemptSumAggregateInputType = {
    id?: true
    challengeId?: true
    userId?: true
    earnedPoints?: true
  }

  export type ChallengeAttemptMinAggregateInputType = {
    id?: true
    challengeId?: true
    userId?: true
    completedAt?: true
    earnedPoints?: true
  }

  export type ChallengeAttemptMaxAggregateInputType = {
    id?: true
    challengeId?: true
    userId?: true
    completedAt?: true
    earnedPoints?: true
  }

  export type ChallengeAttemptCountAggregateInputType = {
    id?: true
    challengeId?: true
    userId?: true
    completedAt?: true
    earnedPoints?: true
    _all?: true
  }

  export type ChallengeAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeAttempt to aggregate.
     */
    where?: ChallengeAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeAttempts to fetch.
     */
    orderBy?: ChallengeAttemptOrderByWithRelationInput | ChallengeAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeAttempts
    **/
    _count?: true | ChallengeAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeAttemptMaxAggregateInputType
  }

  export type GetChallengeAttemptAggregateType<T extends ChallengeAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeAttempt[P]>
      : GetScalarType<T[P], AggregateChallengeAttempt[P]>
  }




  export type ChallengeAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeAttemptWhereInput
    orderBy?: ChallengeAttemptOrderByWithAggregationInput | ChallengeAttemptOrderByWithAggregationInput[]
    by: ChallengeAttemptScalarFieldEnum[] | ChallengeAttemptScalarFieldEnum
    having?: ChallengeAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeAttemptCountAggregateInputType | true
    _avg?: ChallengeAttemptAvgAggregateInputType
    _sum?: ChallengeAttemptSumAggregateInputType
    _min?: ChallengeAttemptMinAggregateInputType
    _max?: ChallengeAttemptMaxAggregateInputType
  }

  export type ChallengeAttemptGroupByOutputType = {
    id: number
    challengeId: number
    userId: number
    completedAt: Date | null
    earnedPoints: number
    _count: ChallengeAttemptCountAggregateOutputType | null
    _avg: ChallengeAttemptAvgAggregateOutputType | null
    _sum: ChallengeAttemptSumAggregateOutputType | null
    _min: ChallengeAttemptMinAggregateOutputType | null
    _max: ChallengeAttemptMaxAggregateOutputType | null
  }

  type GetChallengeAttemptGroupByPayload<T extends ChallengeAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeAttemptGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    userId?: boolean
    completedAt?: boolean
    earnedPoints?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeAttempt"]>

  export type ChallengeAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    userId?: boolean
    completedAt?: boolean
    earnedPoints?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeAttempt"]>

  export type ChallengeAttemptSelectScalar = {
    id?: boolean
    challengeId?: boolean
    userId?: boolean
    completedAt?: boolean
    earnedPoints?: boolean
  }

  export type ChallengeAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChallengeAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChallengeAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeAttempt"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      challengeId: number
      userId: number
      completedAt: Date | null
      earnedPoints: number
    }, ExtArgs["result"]["challengeAttempt"]>
    composites: {}
  }

  type ChallengeAttemptGetPayload<S extends boolean | null | undefined | ChallengeAttemptDefaultArgs> = $Result.GetResult<Prisma.$ChallengeAttemptPayload, S>

  type ChallengeAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChallengeAttemptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChallengeAttemptCountAggregateInputType | true
    }

  export interface ChallengeAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeAttempt'], meta: { name: 'ChallengeAttempt' } }
    /**
     * Find zero or one ChallengeAttempt that matches the filter.
     * @param {ChallengeAttemptFindUniqueArgs} args - Arguments to find a ChallengeAttempt
     * @example
     * // Get one ChallengeAttempt
     * const challengeAttempt = await prisma.challengeAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeAttemptFindUniqueArgs>(args: SelectSubset<T, ChallengeAttemptFindUniqueArgs<ExtArgs>>): Prisma__ChallengeAttemptClient<$Result.GetResult<Prisma.$ChallengeAttemptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChallengeAttempt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChallengeAttemptFindUniqueOrThrowArgs} args - Arguments to find a ChallengeAttempt
     * @example
     * // Get one ChallengeAttempt
     * const challengeAttempt = await prisma.challengeAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeAttemptClient<$Result.GetResult<Prisma.$ChallengeAttemptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChallengeAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAttemptFindFirstArgs} args - Arguments to find a ChallengeAttempt
     * @example
     * // Get one ChallengeAttempt
     * const challengeAttempt = await prisma.challengeAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeAttemptFindFirstArgs>(args?: SelectSubset<T, ChallengeAttemptFindFirstArgs<ExtArgs>>): Prisma__ChallengeAttemptClient<$Result.GetResult<Prisma.$ChallengeAttemptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChallengeAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAttemptFindFirstOrThrowArgs} args - Arguments to find a ChallengeAttempt
     * @example
     * // Get one ChallengeAttempt
     * const challengeAttempt = await prisma.challengeAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeAttemptClient<$Result.GetResult<Prisma.$ChallengeAttemptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChallengeAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeAttempts
     * const challengeAttempts = await prisma.challengeAttempt.findMany()
     * 
     * // Get first 10 ChallengeAttempts
     * const challengeAttempts = await prisma.challengeAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeAttemptWithIdOnly = await prisma.challengeAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeAttemptFindManyArgs>(args?: SelectSubset<T, ChallengeAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeAttemptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChallengeAttempt.
     * @param {ChallengeAttemptCreateArgs} args - Arguments to create a ChallengeAttempt.
     * @example
     * // Create one ChallengeAttempt
     * const ChallengeAttempt = await prisma.challengeAttempt.create({
     *   data: {
     *     // ... data to create a ChallengeAttempt
     *   }
     * })
     * 
     */
    create<T extends ChallengeAttemptCreateArgs>(args: SelectSubset<T, ChallengeAttemptCreateArgs<ExtArgs>>): Prisma__ChallengeAttemptClient<$Result.GetResult<Prisma.$ChallengeAttemptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChallengeAttempts.
     * @param {ChallengeAttemptCreateManyArgs} args - Arguments to create many ChallengeAttempts.
     * @example
     * // Create many ChallengeAttempts
     * const challengeAttempt = await prisma.challengeAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeAttemptCreateManyArgs>(args?: SelectSubset<T, ChallengeAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeAttempts and returns the data saved in the database.
     * @param {ChallengeAttemptCreateManyAndReturnArgs} args - Arguments to create many ChallengeAttempts.
     * @example
     * // Create many ChallengeAttempts
     * const challengeAttempt = await prisma.challengeAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeAttempts and only return the `id`
     * const challengeAttemptWithIdOnly = await prisma.challengeAttempt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeAttemptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChallengeAttempt.
     * @param {ChallengeAttemptDeleteArgs} args - Arguments to delete one ChallengeAttempt.
     * @example
     * // Delete one ChallengeAttempt
     * const ChallengeAttempt = await prisma.challengeAttempt.delete({
     *   where: {
     *     // ... filter to delete one ChallengeAttempt
     *   }
     * })
     * 
     */
    delete<T extends ChallengeAttemptDeleteArgs>(args: SelectSubset<T, ChallengeAttemptDeleteArgs<ExtArgs>>): Prisma__ChallengeAttemptClient<$Result.GetResult<Prisma.$ChallengeAttemptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChallengeAttempt.
     * @param {ChallengeAttemptUpdateArgs} args - Arguments to update one ChallengeAttempt.
     * @example
     * // Update one ChallengeAttempt
     * const challengeAttempt = await prisma.challengeAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeAttemptUpdateArgs>(args: SelectSubset<T, ChallengeAttemptUpdateArgs<ExtArgs>>): Prisma__ChallengeAttemptClient<$Result.GetResult<Prisma.$ChallengeAttemptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChallengeAttempts.
     * @param {ChallengeAttemptDeleteManyArgs} args - Arguments to filter ChallengeAttempts to delete.
     * @example
     * // Delete a few ChallengeAttempts
     * const { count } = await prisma.challengeAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeAttemptDeleteManyArgs>(args?: SelectSubset<T, ChallengeAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeAttempts
     * const challengeAttempt = await prisma.challengeAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeAttemptUpdateManyArgs>(args: SelectSubset<T, ChallengeAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChallengeAttempt.
     * @param {ChallengeAttemptUpsertArgs} args - Arguments to update or create a ChallengeAttempt.
     * @example
     * // Update or create a ChallengeAttempt
     * const challengeAttempt = await prisma.challengeAttempt.upsert({
     *   create: {
     *     // ... data to create a ChallengeAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeAttempt we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeAttemptUpsertArgs>(args: SelectSubset<T, ChallengeAttemptUpsertArgs<ExtArgs>>): Prisma__ChallengeAttemptClient<$Result.GetResult<Prisma.$ChallengeAttemptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChallengeAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAttemptCountArgs} args - Arguments to filter ChallengeAttempts to count.
     * @example
     * // Count the number of ChallengeAttempts
     * const count = await prisma.challengeAttempt.count({
     *   where: {
     *     // ... the filter for the ChallengeAttempts we want to count
     *   }
     * })
    **/
    count<T extends ChallengeAttemptCountArgs>(
      args?: Subset<T, ChallengeAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeAttemptAggregateArgs>(args: Subset<T, ChallengeAttemptAggregateArgs>): Prisma.PrismaPromise<GetChallengeAttemptAggregateType<T>>

    /**
     * Group by ChallengeAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeAttemptGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeAttempt model
   */
  readonly fields: ChallengeAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeAttempt model
   */ 
  interface ChallengeAttemptFieldRefs {
    readonly id: FieldRef<"ChallengeAttempt", 'Int'>
    readonly challengeId: FieldRef<"ChallengeAttempt", 'Int'>
    readonly userId: FieldRef<"ChallengeAttempt", 'Int'>
    readonly completedAt: FieldRef<"ChallengeAttempt", 'DateTime'>
    readonly earnedPoints: FieldRef<"ChallengeAttempt", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeAttempt findUnique
   */
  export type ChallengeAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAttempt
     */
    select?: ChallengeAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeAttempt to fetch.
     */
    where: ChallengeAttemptWhereUniqueInput
  }

  /**
   * ChallengeAttempt findUniqueOrThrow
   */
  export type ChallengeAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAttempt
     */
    select?: ChallengeAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeAttempt to fetch.
     */
    where: ChallengeAttemptWhereUniqueInput
  }

  /**
   * ChallengeAttempt findFirst
   */
  export type ChallengeAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAttempt
     */
    select?: ChallengeAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeAttempt to fetch.
     */
    where?: ChallengeAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeAttempts to fetch.
     */
    orderBy?: ChallengeAttemptOrderByWithRelationInput | ChallengeAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeAttempts.
     */
    cursor?: ChallengeAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeAttempts.
     */
    distinct?: ChallengeAttemptScalarFieldEnum | ChallengeAttemptScalarFieldEnum[]
  }

  /**
   * ChallengeAttempt findFirstOrThrow
   */
  export type ChallengeAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAttempt
     */
    select?: ChallengeAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeAttempt to fetch.
     */
    where?: ChallengeAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeAttempts to fetch.
     */
    orderBy?: ChallengeAttemptOrderByWithRelationInput | ChallengeAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeAttempts.
     */
    cursor?: ChallengeAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeAttempts.
     */
    distinct?: ChallengeAttemptScalarFieldEnum | ChallengeAttemptScalarFieldEnum[]
  }

  /**
   * ChallengeAttempt findMany
   */
  export type ChallengeAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAttempt
     */
    select?: ChallengeAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeAttempts to fetch.
     */
    where?: ChallengeAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeAttempts to fetch.
     */
    orderBy?: ChallengeAttemptOrderByWithRelationInput | ChallengeAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeAttempts.
     */
    cursor?: ChallengeAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeAttempts.
     */
    skip?: number
    distinct?: ChallengeAttemptScalarFieldEnum | ChallengeAttemptScalarFieldEnum[]
  }

  /**
   * ChallengeAttempt create
   */
  export type ChallengeAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAttempt
     */
    select?: ChallengeAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeAttempt.
     */
    data: XOR<ChallengeAttemptCreateInput, ChallengeAttemptUncheckedCreateInput>
  }

  /**
   * ChallengeAttempt createMany
   */
  export type ChallengeAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeAttempts.
     */
    data: ChallengeAttemptCreateManyInput | ChallengeAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeAttempt createManyAndReturn
   */
  export type ChallengeAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAttempt
     */
    select?: ChallengeAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChallengeAttempts.
     */
    data: ChallengeAttemptCreateManyInput | ChallengeAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeAttempt update
   */
  export type ChallengeAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAttempt
     */
    select?: ChallengeAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeAttempt.
     */
    data: XOR<ChallengeAttemptUpdateInput, ChallengeAttemptUncheckedUpdateInput>
    /**
     * Choose, which ChallengeAttempt to update.
     */
    where: ChallengeAttemptWhereUniqueInput
  }

  /**
   * ChallengeAttempt updateMany
   */
  export type ChallengeAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeAttempts.
     */
    data: XOR<ChallengeAttemptUpdateManyMutationInput, ChallengeAttemptUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeAttempts to update
     */
    where?: ChallengeAttemptWhereInput
  }

  /**
   * ChallengeAttempt upsert
   */
  export type ChallengeAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAttempt
     */
    select?: ChallengeAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeAttempt to update in case it exists.
     */
    where: ChallengeAttemptWhereUniqueInput
    /**
     * In case the ChallengeAttempt found by the `where` argument doesn't exist, create a new ChallengeAttempt with this data.
     */
    create: XOR<ChallengeAttemptCreateInput, ChallengeAttemptUncheckedCreateInput>
    /**
     * In case the ChallengeAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeAttemptUpdateInput, ChallengeAttemptUncheckedUpdateInput>
  }

  /**
   * ChallengeAttempt delete
   */
  export type ChallengeAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAttempt
     */
    select?: ChallengeAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAttemptInclude<ExtArgs> | null
    /**
     * Filter which ChallengeAttempt to delete.
     */
    where: ChallengeAttemptWhereUniqueInput
  }

  /**
   * ChallengeAttempt deleteMany
   */
  export type ChallengeAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeAttempts to delete
     */
    where?: ChallengeAttemptWhereInput
  }

  /**
   * ChallengeAttempt without action
   */
  export type ChallengeAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAttempt
     */
    select?: ChallengeAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAttemptInclude<ExtArgs> | null
  }


  /**
   * Model Counselor
   */

  export type AggregateCounselor = {
    _count: CounselorCountAggregateOutputType | null
    _avg: CounselorAvgAggregateOutputType | null
    _sum: CounselorSumAggregateOutputType | null
    _min: CounselorMinAggregateOutputType | null
    _max: CounselorMaxAggregateOutputType | null
  }

  export type CounselorAvgAggregateOutputType = {
    experience: number | null
    rating: number | null
    totalMeetings: number | null
    totalRevenue: number | null
  }

  export type CounselorSumAggregateOutputType = {
    experience: number | null
    rating: number | null
    totalMeetings: number | null
    totalRevenue: number | null
  }

  export type CounselorMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    bio: string | null
    profileImage: string | null
    specialization: string | null
    experience: number | null
    employmentType: $Enums.EmploymentType | null
    isActive: boolean | null
    rating: number | null
    totalMeetings: number | null
    totalRevenue: number | null
    createdByAdminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CounselorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    bio: string | null
    profileImage: string | null
    specialization: string | null
    experience: number | null
    employmentType: $Enums.EmploymentType | null
    isActive: boolean | null
    rating: number | null
    totalMeetings: number | null
    totalRevenue: number | null
    createdByAdminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CounselorCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    bio: number
    profileImage: number
    specialization: number
    experience: number
    employmentType: number
    isActive: number
    rating: number
    totalMeetings: number
    totalRevenue: number
    createdByAdminId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CounselorAvgAggregateInputType = {
    experience?: true
    rating?: true
    totalMeetings?: true
    totalRevenue?: true
  }

  export type CounselorSumAggregateInputType = {
    experience?: true
    rating?: true
    totalMeetings?: true
    totalRevenue?: true
  }

  export type CounselorMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    bio?: true
    profileImage?: true
    specialization?: true
    experience?: true
    employmentType?: true
    isActive?: true
    rating?: true
    totalMeetings?: true
    totalRevenue?: true
    createdByAdminId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CounselorMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    bio?: true
    profileImage?: true
    specialization?: true
    experience?: true
    employmentType?: true
    isActive?: true
    rating?: true
    totalMeetings?: true
    totalRevenue?: true
    createdByAdminId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CounselorCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    bio?: true
    profileImage?: true
    specialization?: true
    experience?: true
    employmentType?: true
    isActive?: true
    rating?: true
    totalMeetings?: true
    totalRevenue?: true
    createdByAdminId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CounselorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Counselor to aggregate.
     */
    where?: CounselorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counselors to fetch.
     */
    orderBy?: CounselorOrderByWithRelationInput | CounselorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CounselorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counselors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counselors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Counselors
    **/
    _count?: true | CounselorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CounselorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CounselorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CounselorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CounselorMaxAggregateInputType
  }

  export type GetCounselorAggregateType<T extends CounselorAggregateArgs> = {
        [P in keyof T & keyof AggregateCounselor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCounselor[P]>
      : GetScalarType<T[P], AggregateCounselor[P]>
  }




  export type CounselorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CounselorWhereInput
    orderBy?: CounselorOrderByWithAggregationInput | CounselorOrderByWithAggregationInput[]
    by: CounselorScalarFieldEnum[] | CounselorScalarFieldEnum
    having?: CounselorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CounselorCountAggregateInputType | true
    _avg?: CounselorAvgAggregateInputType
    _sum?: CounselorSumAggregateInputType
    _min?: CounselorMinAggregateInputType
    _max?: CounselorMaxAggregateInputType
  }

  export type CounselorGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    bio: string | null
    profileImage: string | null
    specialization: string | null
    experience: number | null
    employmentType: $Enums.EmploymentType
    isActive: boolean
    rating: number
    totalMeetings: number
    totalRevenue: number
    createdByAdminId: string
    createdAt: Date
    updatedAt: Date
    _count: CounselorCountAggregateOutputType | null
    _avg: CounselorAvgAggregateOutputType | null
    _sum: CounselorSumAggregateOutputType | null
    _min: CounselorMinAggregateOutputType | null
    _max: CounselorMaxAggregateOutputType | null
  }

  type GetCounselorGroupByPayload<T extends CounselorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CounselorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CounselorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CounselorGroupByOutputType[P]>
            : GetScalarType<T[P], CounselorGroupByOutputType[P]>
        }
      >
    >


  export type CounselorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    bio?: boolean
    profileImage?: boolean
    specialization?: boolean
    experience?: boolean
    employmentType?: boolean
    isActive?: boolean
    rating?: boolean
    totalMeetings?: boolean
    totalRevenue?: boolean
    createdByAdminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consultationRequests?: boolean | Counselor$consultationRequestsArgs<ExtArgs>
    meetings?: boolean | Counselor$meetingsArgs<ExtArgs>
    _count?: boolean | CounselorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["counselor"]>

  export type CounselorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    bio?: boolean
    profileImage?: boolean
    specialization?: boolean
    experience?: boolean
    employmentType?: boolean
    isActive?: boolean
    rating?: boolean
    totalMeetings?: boolean
    totalRevenue?: boolean
    createdByAdminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["counselor"]>

  export type CounselorSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    bio?: boolean
    profileImage?: boolean
    specialization?: boolean
    experience?: boolean
    employmentType?: boolean
    isActive?: boolean
    rating?: boolean
    totalMeetings?: boolean
    totalRevenue?: boolean
    createdByAdminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CounselorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultationRequests?: boolean | Counselor$consultationRequestsArgs<ExtArgs>
    meetings?: boolean | Counselor$meetingsArgs<ExtArgs>
    _count?: boolean | CounselorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CounselorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CounselorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Counselor"
    objects: {
      consultationRequests: Prisma.$ConsultationRequestPayload<ExtArgs>[]
      meetings: Prisma.$MeetingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      bio: string | null
      profileImage: string | null
      specialization: string | null
      experience: number | null
      employmentType: $Enums.EmploymentType
      isActive: boolean
      rating: number
      totalMeetings: number
      totalRevenue: number
      createdByAdminId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["counselor"]>
    composites: {}
  }

  type CounselorGetPayload<S extends boolean | null | undefined | CounselorDefaultArgs> = $Result.GetResult<Prisma.$CounselorPayload, S>

  type CounselorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CounselorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CounselorCountAggregateInputType | true
    }

  export interface CounselorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Counselor'], meta: { name: 'Counselor' } }
    /**
     * Find zero or one Counselor that matches the filter.
     * @param {CounselorFindUniqueArgs} args - Arguments to find a Counselor
     * @example
     * // Get one Counselor
     * const counselor = await prisma.counselor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CounselorFindUniqueArgs>(args: SelectSubset<T, CounselorFindUniqueArgs<ExtArgs>>): Prisma__CounselorClient<$Result.GetResult<Prisma.$CounselorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Counselor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CounselorFindUniqueOrThrowArgs} args - Arguments to find a Counselor
     * @example
     * // Get one Counselor
     * const counselor = await prisma.counselor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CounselorFindUniqueOrThrowArgs>(args: SelectSubset<T, CounselorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CounselorClient<$Result.GetResult<Prisma.$CounselorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Counselor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounselorFindFirstArgs} args - Arguments to find a Counselor
     * @example
     * // Get one Counselor
     * const counselor = await prisma.counselor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CounselorFindFirstArgs>(args?: SelectSubset<T, CounselorFindFirstArgs<ExtArgs>>): Prisma__CounselorClient<$Result.GetResult<Prisma.$CounselorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Counselor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounselorFindFirstOrThrowArgs} args - Arguments to find a Counselor
     * @example
     * // Get one Counselor
     * const counselor = await prisma.counselor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CounselorFindFirstOrThrowArgs>(args?: SelectSubset<T, CounselorFindFirstOrThrowArgs<ExtArgs>>): Prisma__CounselorClient<$Result.GetResult<Prisma.$CounselorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Counselors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounselorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Counselors
     * const counselors = await prisma.counselor.findMany()
     * 
     * // Get first 10 Counselors
     * const counselors = await prisma.counselor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const counselorWithIdOnly = await prisma.counselor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CounselorFindManyArgs>(args?: SelectSubset<T, CounselorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CounselorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Counselor.
     * @param {CounselorCreateArgs} args - Arguments to create a Counselor.
     * @example
     * // Create one Counselor
     * const Counselor = await prisma.counselor.create({
     *   data: {
     *     // ... data to create a Counselor
     *   }
     * })
     * 
     */
    create<T extends CounselorCreateArgs>(args: SelectSubset<T, CounselorCreateArgs<ExtArgs>>): Prisma__CounselorClient<$Result.GetResult<Prisma.$CounselorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Counselors.
     * @param {CounselorCreateManyArgs} args - Arguments to create many Counselors.
     * @example
     * // Create many Counselors
     * const counselor = await prisma.counselor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CounselorCreateManyArgs>(args?: SelectSubset<T, CounselorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Counselors and returns the data saved in the database.
     * @param {CounselorCreateManyAndReturnArgs} args - Arguments to create many Counselors.
     * @example
     * // Create many Counselors
     * const counselor = await prisma.counselor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Counselors and only return the `id`
     * const counselorWithIdOnly = await prisma.counselor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CounselorCreateManyAndReturnArgs>(args?: SelectSubset<T, CounselorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CounselorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Counselor.
     * @param {CounselorDeleteArgs} args - Arguments to delete one Counselor.
     * @example
     * // Delete one Counselor
     * const Counselor = await prisma.counselor.delete({
     *   where: {
     *     // ... filter to delete one Counselor
     *   }
     * })
     * 
     */
    delete<T extends CounselorDeleteArgs>(args: SelectSubset<T, CounselorDeleteArgs<ExtArgs>>): Prisma__CounselorClient<$Result.GetResult<Prisma.$CounselorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Counselor.
     * @param {CounselorUpdateArgs} args - Arguments to update one Counselor.
     * @example
     * // Update one Counselor
     * const counselor = await prisma.counselor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CounselorUpdateArgs>(args: SelectSubset<T, CounselorUpdateArgs<ExtArgs>>): Prisma__CounselorClient<$Result.GetResult<Prisma.$CounselorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Counselors.
     * @param {CounselorDeleteManyArgs} args - Arguments to filter Counselors to delete.
     * @example
     * // Delete a few Counselors
     * const { count } = await prisma.counselor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CounselorDeleteManyArgs>(args?: SelectSubset<T, CounselorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Counselors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounselorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Counselors
     * const counselor = await prisma.counselor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CounselorUpdateManyArgs>(args: SelectSubset<T, CounselorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Counselor.
     * @param {CounselorUpsertArgs} args - Arguments to update or create a Counselor.
     * @example
     * // Update or create a Counselor
     * const counselor = await prisma.counselor.upsert({
     *   create: {
     *     // ... data to create a Counselor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Counselor we want to update
     *   }
     * })
     */
    upsert<T extends CounselorUpsertArgs>(args: SelectSubset<T, CounselorUpsertArgs<ExtArgs>>): Prisma__CounselorClient<$Result.GetResult<Prisma.$CounselorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Counselors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounselorCountArgs} args - Arguments to filter Counselors to count.
     * @example
     * // Count the number of Counselors
     * const count = await prisma.counselor.count({
     *   where: {
     *     // ... the filter for the Counselors we want to count
     *   }
     * })
    **/
    count<T extends CounselorCountArgs>(
      args?: Subset<T, CounselorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CounselorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Counselor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounselorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CounselorAggregateArgs>(args: Subset<T, CounselorAggregateArgs>): Prisma.PrismaPromise<GetCounselorAggregateType<T>>

    /**
     * Group by Counselor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounselorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CounselorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CounselorGroupByArgs['orderBy'] }
        : { orderBy?: CounselorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CounselorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCounselorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Counselor model
   */
  readonly fields: CounselorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Counselor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CounselorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultationRequests<T extends Counselor$consultationRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Counselor$consultationRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationRequestPayload<ExtArgs>, T, "findMany"> | Null>
    meetings<T extends Counselor$meetingsArgs<ExtArgs> = {}>(args?: Subset<T, Counselor$meetingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Counselor model
   */ 
  interface CounselorFieldRefs {
    readonly id: FieldRef<"Counselor", 'String'>
    readonly name: FieldRef<"Counselor", 'String'>
    readonly email: FieldRef<"Counselor", 'String'>
    readonly password: FieldRef<"Counselor", 'String'>
    readonly bio: FieldRef<"Counselor", 'String'>
    readonly profileImage: FieldRef<"Counselor", 'String'>
    readonly specialization: FieldRef<"Counselor", 'String'>
    readonly experience: FieldRef<"Counselor", 'Int'>
    readonly employmentType: FieldRef<"Counselor", 'EmploymentType'>
    readonly isActive: FieldRef<"Counselor", 'Boolean'>
    readonly rating: FieldRef<"Counselor", 'Float'>
    readonly totalMeetings: FieldRef<"Counselor", 'Int'>
    readonly totalRevenue: FieldRef<"Counselor", 'Float'>
    readonly createdByAdminId: FieldRef<"Counselor", 'String'>
    readonly createdAt: FieldRef<"Counselor", 'DateTime'>
    readonly updatedAt: FieldRef<"Counselor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Counselor findUnique
   */
  export type CounselorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counselor
     */
    select?: CounselorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounselorInclude<ExtArgs> | null
    /**
     * Filter, which Counselor to fetch.
     */
    where: CounselorWhereUniqueInput
  }

  /**
   * Counselor findUniqueOrThrow
   */
  export type CounselorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counselor
     */
    select?: CounselorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounselorInclude<ExtArgs> | null
    /**
     * Filter, which Counselor to fetch.
     */
    where: CounselorWhereUniqueInput
  }

  /**
   * Counselor findFirst
   */
  export type CounselorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counselor
     */
    select?: CounselorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounselorInclude<ExtArgs> | null
    /**
     * Filter, which Counselor to fetch.
     */
    where?: CounselorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counselors to fetch.
     */
    orderBy?: CounselorOrderByWithRelationInput | CounselorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Counselors.
     */
    cursor?: CounselorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counselors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counselors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Counselors.
     */
    distinct?: CounselorScalarFieldEnum | CounselorScalarFieldEnum[]
  }

  /**
   * Counselor findFirstOrThrow
   */
  export type CounselorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counselor
     */
    select?: CounselorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounselorInclude<ExtArgs> | null
    /**
     * Filter, which Counselor to fetch.
     */
    where?: CounselorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counselors to fetch.
     */
    orderBy?: CounselorOrderByWithRelationInput | CounselorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Counselors.
     */
    cursor?: CounselorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counselors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counselors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Counselors.
     */
    distinct?: CounselorScalarFieldEnum | CounselorScalarFieldEnum[]
  }

  /**
   * Counselor findMany
   */
  export type CounselorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counselor
     */
    select?: CounselorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounselorInclude<ExtArgs> | null
    /**
     * Filter, which Counselors to fetch.
     */
    where?: CounselorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counselors to fetch.
     */
    orderBy?: CounselorOrderByWithRelationInput | CounselorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Counselors.
     */
    cursor?: CounselorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counselors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counselors.
     */
    skip?: number
    distinct?: CounselorScalarFieldEnum | CounselorScalarFieldEnum[]
  }

  /**
   * Counselor create
   */
  export type CounselorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counselor
     */
    select?: CounselorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounselorInclude<ExtArgs> | null
    /**
     * The data needed to create a Counselor.
     */
    data: XOR<CounselorCreateInput, CounselorUncheckedCreateInput>
  }

  /**
   * Counselor createMany
   */
  export type CounselorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Counselors.
     */
    data: CounselorCreateManyInput | CounselorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Counselor createManyAndReturn
   */
  export type CounselorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counselor
     */
    select?: CounselorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Counselors.
     */
    data: CounselorCreateManyInput | CounselorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Counselor update
   */
  export type CounselorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counselor
     */
    select?: CounselorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounselorInclude<ExtArgs> | null
    /**
     * The data needed to update a Counselor.
     */
    data: XOR<CounselorUpdateInput, CounselorUncheckedUpdateInput>
    /**
     * Choose, which Counselor to update.
     */
    where: CounselorWhereUniqueInput
  }

  /**
   * Counselor updateMany
   */
  export type CounselorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Counselors.
     */
    data: XOR<CounselorUpdateManyMutationInput, CounselorUncheckedUpdateManyInput>
    /**
     * Filter which Counselors to update
     */
    where?: CounselorWhereInput
  }

  /**
   * Counselor upsert
   */
  export type CounselorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counselor
     */
    select?: CounselorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounselorInclude<ExtArgs> | null
    /**
     * The filter to search for the Counselor to update in case it exists.
     */
    where: CounselorWhereUniqueInput
    /**
     * In case the Counselor found by the `where` argument doesn't exist, create a new Counselor with this data.
     */
    create: XOR<CounselorCreateInput, CounselorUncheckedCreateInput>
    /**
     * In case the Counselor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CounselorUpdateInput, CounselorUncheckedUpdateInput>
  }

  /**
   * Counselor delete
   */
  export type CounselorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counselor
     */
    select?: CounselorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounselorInclude<ExtArgs> | null
    /**
     * Filter which Counselor to delete.
     */
    where: CounselorWhereUniqueInput
  }

  /**
   * Counselor deleteMany
   */
  export type CounselorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Counselors to delete
     */
    where?: CounselorWhereInput
  }

  /**
   * Counselor.consultationRequests
   */
  export type Counselor$consultationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationRequest
     */
    select?: ConsultationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationRequestInclude<ExtArgs> | null
    where?: ConsultationRequestWhereInput
    orderBy?: ConsultationRequestOrderByWithRelationInput | ConsultationRequestOrderByWithRelationInput[]
    cursor?: ConsultationRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultationRequestScalarFieldEnum | ConsultationRequestScalarFieldEnum[]
  }

  /**
   * Counselor.meetings
   */
  export type Counselor$meetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    cursor?: MeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Counselor without action
   */
  export type CounselorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counselor
     */
    select?: CounselorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounselorInclude<ExtArgs> | null
  }


  /**
   * Model ConsultationRequest
   */

  export type AggregateConsultationRequest = {
    _count: ConsultationRequestCountAggregateOutputType | null
    _avg: ConsultationRequestAvgAggregateOutputType | null
    _sum: ConsultationRequestSumAggregateOutputType | null
    _min: ConsultationRequestMinAggregateOutputType | null
    _max: ConsultationRequestMaxAggregateOutputType | null
  }

  export type ConsultationRequestAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ConsultationRequestSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ConsultationRequestMinAggregateOutputType = {
    id: number | null
    userId: number | null
    counselorId: string | null
    requestType: $Enums.ConsultationType | null
    scheduledAt: Date | null
    status: $Enums.ConsultationStatus | null
    message: string | null
    respondedAt: Date | null
    createdAt: Date | null
  }

  export type ConsultationRequestMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    counselorId: string | null
    requestType: $Enums.ConsultationType | null
    scheduledAt: Date | null
    status: $Enums.ConsultationStatus | null
    message: string | null
    respondedAt: Date | null
    createdAt: Date | null
  }

  export type ConsultationRequestCountAggregateOutputType = {
    id: number
    userId: number
    counselorId: number
    requestType: number
    scheduledAt: number
    status: number
    message: number
    respondedAt: number
    createdAt: number
    _all: number
  }


  export type ConsultationRequestAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ConsultationRequestSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ConsultationRequestMinAggregateInputType = {
    id?: true
    userId?: true
    counselorId?: true
    requestType?: true
    scheduledAt?: true
    status?: true
    message?: true
    respondedAt?: true
    createdAt?: true
  }

  export type ConsultationRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    counselorId?: true
    requestType?: true
    scheduledAt?: true
    status?: true
    message?: true
    respondedAt?: true
    createdAt?: true
  }

  export type ConsultationRequestCountAggregateInputType = {
    id?: true
    userId?: true
    counselorId?: true
    requestType?: true
    scheduledAt?: true
    status?: true
    message?: true
    respondedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ConsultationRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultationRequest to aggregate.
     */
    where?: ConsultationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationRequests to fetch.
     */
    orderBy?: ConsultationRequestOrderByWithRelationInput | ConsultationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConsultationRequests
    **/
    _count?: true | ConsultationRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultationRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultationRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultationRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultationRequestMaxAggregateInputType
  }

  export type GetConsultationRequestAggregateType<T extends ConsultationRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultationRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultationRequest[P]>
      : GetScalarType<T[P], AggregateConsultationRequest[P]>
  }




  export type ConsultationRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationRequestWhereInput
    orderBy?: ConsultationRequestOrderByWithAggregationInput | ConsultationRequestOrderByWithAggregationInput[]
    by: ConsultationRequestScalarFieldEnum[] | ConsultationRequestScalarFieldEnum
    having?: ConsultationRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultationRequestCountAggregateInputType | true
    _avg?: ConsultationRequestAvgAggregateInputType
    _sum?: ConsultationRequestSumAggregateInputType
    _min?: ConsultationRequestMinAggregateInputType
    _max?: ConsultationRequestMaxAggregateInputType
  }

  export type ConsultationRequestGroupByOutputType = {
    id: number
    userId: number
    counselorId: string
    requestType: $Enums.ConsultationType
    scheduledAt: Date | null
    status: $Enums.ConsultationStatus
    message: string | null
    respondedAt: Date | null
    createdAt: Date
    _count: ConsultationRequestCountAggregateOutputType | null
    _avg: ConsultationRequestAvgAggregateOutputType | null
    _sum: ConsultationRequestSumAggregateOutputType | null
    _min: ConsultationRequestMinAggregateOutputType | null
    _max: ConsultationRequestMaxAggregateOutputType | null
  }

  type GetConsultationRequestGroupByPayload<T extends ConsultationRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultationRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultationRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultationRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultationRequestGroupByOutputType[P]>
        }
      >
    >


  export type ConsultationRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    counselorId?: boolean
    requestType?: boolean
    scheduledAt?: boolean
    status?: boolean
    message?: boolean
    respondedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    counselor?: boolean | CounselorDefaultArgs<ExtArgs>
    meeting?: boolean | ConsultationRequest$meetingArgs<ExtArgs>
  }, ExtArgs["result"]["consultationRequest"]>

  export type ConsultationRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    counselorId?: boolean
    requestType?: boolean
    scheduledAt?: boolean
    status?: boolean
    message?: boolean
    respondedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    counselor?: boolean | CounselorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultationRequest"]>

  export type ConsultationRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    counselorId?: boolean
    requestType?: boolean
    scheduledAt?: boolean
    status?: boolean
    message?: boolean
    respondedAt?: boolean
    createdAt?: boolean
  }

  export type ConsultationRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    counselor?: boolean | CounselorDefaultArgs<ExtArgs>
    meeting?: boolean | ConsultationRequest$meetingArgs<ExtArgs>
  }
  export type ConsultationRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    counselor?: boolean | CounselorDefaultArgs<ExtArgs>
  }

  export type $ConsultationRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConsultationRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      counselor: Prisma.$CounselorPayload<ExtArgs>
      meeting: Prisma.$MeetingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      counselorId: string
      requestType: $Enums.ConsultationType
      scheduledAt: Date | null
      status: $Enums.ConsultationStatus
      message: string | null
      respondedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["consultationRequest"]>
    composites: {}
  }

  type ConsultationRequestGetPayload<S extends boolean | null | undefined | ConsultationRequestDefaultArgs> = $Result.GetResult<Prisma.$ConsultationRequestPayload, S>

  type ConsultationRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConsultationRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConsultationRequestCountAggregateInputType | true
    }

  export interface ConsultationRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConsultationRequest'], meta: { name: 'ConsultationRequest' } }
    /**
     * Find zero or one ConsultationRequest that matches the filter.
     * @param {ConsultationRequestFindUniqueArgs} args - Arguments to find a ConsultationRequest
     * @example
     * // Get one ConsultationRequest
     * const consultationRequest = await prisma.consultationRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsultationRequestFindUniqueArgs>(args: SelectSubset<T, ConsultationRequestFindUniqueArgs<ExtArgs>>): Prisma__ConsultationRequestClient<$Result.GetResult<Prisma.$ConsultationRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConsultationRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConsultationRequestFindUniqueOrThrowArgs} args - Arguments to find a ConsultationRequest
     * @example
     * // Get one ConsultationRequest
     * const consultationRequest = await prisma.consultationRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsultationRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsultationRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsultationRequestClient<$Result.GetResult<Prisma.$ConsultationRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConsultationRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationRequestFindFirstArgs} args - Arguments to find a ConsultationRequest
     * @example
     * // Get one ConsultationRequest
     * const consultationRequest = await prisma.consultationRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsultationRequestFindFirstArgs>(args?: SelectSubset<T, ConsultationRequestFindFirstArgs<ExtArgs>>): Prisma__ConsultationRequestClient<$Result.GetResult<Prisma.$ConsultationRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConsultationRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationRequestFindFirstOrThrowArgs} args - Arguments to find a ConsultationRequest
     * @example
     * // Get one ConsultationRequest
     * const consultationRequest = await prisma.consultationRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsultationRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsultationRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsultationRequestClient<$Result.GetResult<Prisma.$ConsultationRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConsultationRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsultationRequests
     * const consultationRequests = await prisma.consultationRequest.findMany()
     * 
     * // Get first 10 ConsultationRequests
     * const consultationRequests = await prisma.consultationRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultationRequestWithIdOnly = await prisma.consultationRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsultationRequestFindManyArgs>(args?: SelectSubset<T, ConsultationRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConsultationRequest.
     * @param {ConsultationRequestCreateArgs} args - Arguments to create a ConsultationRequest.
     * @example
     * // Create one ConsultationRequest
     * const ConsultationRequest = await prisma.consultationRequest.create({
     *   data: {
     *     // ... data to create a ConsultationRequest
     *   }
     * })
     * 
     */
    create<T extends ConsultationRequestCreateArgs>(args: SelectSubset<T, ConsultationRequestCreateArgs<ExtArgs>>): Prisma__ConsultationRequestClient<$Result.GetResult<Prisma.$ConsultationRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConsultationRequests.
     * @param {ConsultationRequestCreateManyArgs} args - Arguments to create many ConsultationRequests.
     * @example
     * // Create many ConsultationRequests
     * const consultationRequest = await prisma.consultationRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsultationRequestCreateManyArgs>(args?: SelectSubset<T, ConsultationRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConsultationRequests and returns the data saved in the database.
     * @param {ConsultationRequestCreateManyAndReturnArgs} args - Arguments to create many ConsultationRequests.
     * @example
     * // Create many ConsultationRequests
     * const consultationRequest = await prisma.consultationRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConsultationRequests and only return the `id`
     * const consultationRequestWithIdOnly = await prisma.consultationRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsultationRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsultationRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConsultationRequest.
     * @param {ConsultationRequestDeleteArgs} args - Arguments to delete one ConsultationRequest.
     * @example
     * // Delete one ConsultationRequest
     * const ConsultationRequest = await prisma.consultationRequest.delete({
     *   where: {
     *     // ... filter to delete one ConsultationRequest
     *   }
     * })
     * 
     */
    delete<T extends ConsultationRequestDeleteArgs>(args: SelectSubset<T, ConsultationRequestDeleteArgs<ExtArgs>>): Prisma__ConsultationRequestClient<$Result.GetResult<Prisma.$ConsultationRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConsultationRequest.
     * @param {ConsultationRequestUpdateArgs} args - Arguments to update one ConsultationRequest.
     * @example
     * // Update one ConsultationRequest
     * const consultationRequest = await prisma.consultationRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsultationRequestUpdateArgs>(args: SelectSubset<T, ConsultationRequestUpdateArgs<ExtArgs>>): Prisma__ConsultationRequestClient<$Result.GetResult<Prisma.$ConsultationRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConsultationRequests.
     * @param {ConsultationRequestDeleteManyArgs} args - Arguments to filter ConsultationRequests to delete.
     * @example
     * // Delete a few ConsultationRequests
     * const { count } = await prisma.consultationRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsultationRequestDeleteManyArgs>(args?: SelectSubset<T, ConsultationRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsultationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsultationRequests
     * const consultationRequest = await prisma.consultationRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsultationRequestUpdateManyArgs>(args: SelectSubset<T, ConsultationRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsultationRequest.
     * @param {ConsultationRequestUpsertArgs} args - Arguments to update or create a ConsultationRequest.
     * @example
     * // Update or create a ConsultationRequest
     * const consultationRequest = await prisma.consultationRequest.upsert({
     *   create: {
     *     // ... data to create a ConsultationRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsultationRequest we want to update
     *   }
     * })
     */
    upsert<T extends ConsultationRequestUpsertArgs>(args: SelectSubset<T, ConsultationRequestUpsertArgs<ExtArgs>>): Prisma__ConsultationRequestClient<$Result.GetResult<Prisma.$ConsultationRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConsultationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationRequestCountArgs} args - Arguments to filter ConsultationRequests to count.
     * @example
     * // Count the number of ConsultationRequests
     * const count = await prisma.consultationRequest.count({
     *   where: {
     *     // ... the filter for the ConsultationRequests we want to count
     *   }
     * })
    **/
    count<T extends ConsultationRequestCountArgs>(
      args?: Subset<T, ConsultationRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultationRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsultationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultationRequestAggregateArgs>(args: Subset<T, ConsultationRequestAggregateArgs>): Prisma.PrismaPromise<GetConsultationRequestAggregateType<T>>

    /**
     * Group by ConsultationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultationRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultationRequestGroupByArgs['orderBy'] }
        : { orderBy?: ConsultationRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultationRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultationRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConsultationRequest model
   */
  readonly fields: ConsultationRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConsultationRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsultationRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    counselor<T extends CounselorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CounselorDefaultArgs<ExtArgs>>): Prisma__CounselorClient<$Result.GetResult<Prisma.$CounselorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    meeting<T extends ConsultationRequest$meetingArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationRequest$meetingArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConsultationRequest model
   */ 
  interface ConsultationRequestFieldRefs {
    readonly id: FieldRef<"ConsultationRequest", 'Int'>
    readonly userId: FieldRef<"ConsultationRequest", 'Int'>
    readonly counselorId: FieldRef<"ConsultationRequest", 'String'>
    readonly requestType: FieldRef<"ConsultationRequest", 'ConsultationType'>
    readonly scheduledAt: FieldRef<"ConsultationRequest", 'DateTime'>
    readonly status: FieldRef<"ConsultationRequest", 'ConsultationStatus'>
    readonly message: FieldRef<"ConsultationRequest", 'String'>
    readonly respondedAt: FieldRef<"ConsultationRequest", 'DateTime'>
    readonly createdAt: FieldRef<"ConsultationRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConsultationRequest findUnique
   */
  export type ConsultationRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationRequest
     */
    select?: ConsultationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationRequestInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationRequest to fetch.
     */
    where: ConsultationRequestWhereUniqueInput
  }

  /**
   * ConsultationRequest findUniqueOrThrow
   */
  export type ConsultationRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationRequest
     */
    select?: ConsultationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationRequestInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationRequest to fetch.
     */
    where: ConsultationRequestWhereUniqueInput
  }

  /**
   * ConsultationRequest findFirst
   */
  export type ConsultationRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationRequest
     */
    select?: ConsultationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationRequestInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationRequest to fetch.
     */
    where?: ConsultationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationRequests to fetch.
     */
    orderBy?: ConsultationRequestOrderByWithRelationInput | ConsultationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultationRequests.
     */
    cursor?: ConsultationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultationRequests.
     */
    distinct?: ConsultationRequestScalarFieldEnum | ConsultationRequestScalarFieldEnum[]
  }

  /**
   * ConsultationRequest findFirstOrThrow
   */
  export type ConsultationRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationRequest
     */
    select?: ConsultationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationRequestInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationRequest to fetch.
     */
    where?: ConsultationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationRequests to fetch.
     */
    orderBy?: ConsultationRequestOrderByWithRelationInput | ConsultationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultationRequests.
     */
    cursor?: ConsultationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultationRequests.
     */
    distinct?: ConsultationRequestScalarFieldEnum | ConsultationRequestScalarFieldEnum[]
  }

  /**
   * ConsultationRequest findMany
   */
  export type ConsultationRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationRequest
     */
    select?: ConsultationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationRequestInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationRequests to fetch.
     */
    where?: ConsultationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationRequests to fetch.
     */
    orderBy?: ConsultationRequestOrderByWithRelationInput | ConsultationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConsultationRequests.
     */
    cursor?: ConsultationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationRequests.
     */
    skip?: number
    distinct?: ConsultationRequestScalarFieldEnum | ConsultationRequestScalarFieldEnum[]
  }

  /**
   * ConsultationRequest create
   */
  export type ConsultationRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationRequest
     */
    select?: ConsultationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ConsultationRequest.
     */
    data: XOR<ConsultationRequestCreateInput, ConsultationRequestUncheckedCreateInput>
  }

  /**
   * ConsultationRequest createMany
   */
  export type ConsultationRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConsultationRequests.
     */
    data: ConsultationRequestCreateManyInput | ConsultationRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConsultationRequest createManyAndReturn
   */
  export type ConsultationRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationRequest
     */
    select?: ConsultationRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConsultationRequests.
     */
    data: ConsultationRequestCreateManyInput | ConsultationRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConsultationRequest update
   */
  export type ConsultationRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationRequest
     */
    select?: ConsultationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ConsultationRequest.
     */
    data: XOR<ConsultationRequestUpdateInput, ConsultationRequestUncheckedUpdateInput>
    /**
     * Choose, which ConsultationRequest to update.
     */
    where: ConsultationRequestWhereUniqueInput
  }

  /**
   * ConsultationRequest updateMany
   */
  export type ConsultationRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConsultationRequests.
     */
    data: XOR<ConsultationRequestUpdateManyMutationInput, ConsultationRequestUncheckedUpdateManyInput>
    /**
     * Filter which ConsultationRequests to update
     */
    where?: ConsultationRequestWhereInput
  }

  /**
   * ConsultationRequest upsert
   */
  export type ConsultationRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationRequest
     */
    select?: ConsultationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ConsultationRequest to update in case it exists.
     */
    where: ConsultationRequestWhereUniqueInput
    /**
     * In case the ConsultationRequest found by the `where` argument doesn't exist, create a new ConsultationRequest with this data.
     */
    create: XOR<ConsultationRequestCreateInput, ConsultationRequestUncheckedCreateInput>
    /**
     * In case the ConsultationRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultationRequestUpdateInput, ConsultationRequestUncheckedUpdateInput>
  }

  /**
   * ConsultationRequest delete
   */
  export type ConsultationRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationRequest
     */
    select?: ConsultationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationRequestInclude<ExtArgs> | null
    /**
     * Filter which ConsultationRequest to delete.
     */
    where: ConsultationRequestWhereUniqueInput
  }

  /**
   * ConsultationRequest deleteMany
   */
  export type ConsultationRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultationRequests to delete
     */
    where?: ConsultationRequestWhereInput
  }

  /**
   * ConsultationRequest.meeting
   */
  export type ConsultationRequest$meetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
  }

  /**
   * ConsultationRequest without action
   */
  export type ConsultationRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationRequest
     */
    select?: ConsultationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationRequestInclude<ExtArgs> | null
  }


  /**
   * Model Meeting
   */

  export type AggregateMeeting = {
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  export type MeetingAvgAggregateOutputType = {
    consultationRequestId: number | null
    userId: number | null
    duration: number | null
  }

  export type MeetingSumAggregateOutputType = {
    consultationRequestId: number | null
    userId: number | null
    duration: number | null
  }

  export type MeetingMinAggregateOutputType = {
    id: string | null
    consultationRequestId: number | null
    counselorId: string | null
    userId: number | null
    meetingProvider: $Enums.MeetingProvider | null
    meetingRoomId: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    status: $Enums.MeetingStatus | null
    createdAt: Date | null
  }

  export type MeetingMaxAggregateOutputType = {
    id: string | null
    consultationRequestId: number | null
    counselorId: string | null
    userId: number | null
    meetingProvider: $Enums.MeetingProvider | null
    meetingRoomId: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    status: $Enums.MeetingStatus | null
    createdAt: Date | null
  }

  export type MeetingCountAggregateOutputType = {
    id: number
    consultationRequestId: number
    counselorId: number
    userId: number
    meetingProvider: number
    meetingRoomId: number
    startTime: number
    endTime: number
    duration: number
    status: number
    createdAt: number
    _all: number
  }


  export type MeetingAvgAggregateInputType = {
    consultationRequestId?: true
    userId?: true
    duration?: true
  }

  export type MeetingSumAggregateInputType = {
    consultationRequestId?: true
    userId?: true
    duration?: true
  }

  export type MeetingMinAggregateInputType = {
    id?: true
    consultationRequestId?: true
    counselorId?: true
    userId?: true
    meetingProvider?: true
    meetingRoomId?: true
    startTime?: true
    endTime?: true
    duration?: true
    status?: true
    createdAt?: true
  }

  export type MeetingMaxAggregateInputType = {
    id?: true
    consultationRequestId?: true
    counselorId?: true
    userId?: true
    meetingProvider?: true
    meetingRoomId?: true
    startTime?: true
    endTime?: true
    duration?: true
    status?: true
    createdAt?: true
  }

  export type MeetingCountAggregateInputType = {
    id?: true
    consultationRequestId?: true
    counselorId?: true
    userId?: true
    meetingProvider?: true
    meetingRoomId?: true
    startTime?: true
    endTime?: true
    duration?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type MeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meeting to aggregate.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meetings
    **/
    _count?: true | MeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeetingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeetingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingMaxAggregateInputType
  }

  export type GetMeetingAggregateType<T extends MeetingAggregateArgs> = {
        [P in keyof T & keyof AggregateMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeeting[P]>
      : GetScalarType<T[P], AggregateMeeting[P]>
  }




  export type MeetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithAggregationInput | MeetingOrderByWithAggregationInput[]
    by: MeetingScalarFieldEnum[] | MeetingScalarFieldEnum
    having?: MeetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingCountAggregateInputType | true
    _avg?: MeetingAvgAggregateInputType
    _sum?: MeetingSumAggregateInputType
    _min?: MeetingMinAggregateInputType
    _max?: MeetingMaxAggregateInputType
  }

  export type MeetingGroupByOutputType = {
    id: string
    consultationRequestId: number
    counselorId: string
    userId: number
    meetingProvider: $Enums.MeetingProvider
    meetingRoomId: string
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    status: $Enums.MeetingStatus
    createdAt: Date
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  type GetMeetingGroupByPayload<T extends MeetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingGroupByOutputType[P]>
        }
      >
    >


  export type MeetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationRequestId?: boolean
    counselorId?: boolean
    userId?: boolean
    meetingProvider?: boolean
    meetingRoomId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    status?: boolean
    createdAt?: boolean
    consultationRequest?: boolean | ConsultationRequestDefaultArgs<ExtArgs>
    counselor?: boolean | CounselorDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationRequestId?: boolean
    counselorId?: boolean
    userId?: boolean
    meetingProvider?: boolean
    meetingRoomId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    status?: boolean
    createdAt?: boolean
    consultationRequest?: boolean | ConsultationRequestDefaultArgs<ExtArgs>
    counselor?: boolean | CounselorDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectScalar = {
    id?: boolean
    consultationRequestId?: boolean
    counselorId?: boolean
    userId?: boolean
    meetingProvider?: boolean
    meetingRoomId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type MeetingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultationRequest?: boolean | ConsultationRequestDefaultArgs<ExtArgs>
    counselor?: boolean | CounselorDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MeetingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultationRequest?: boolean | ConsultationRequestDefaultArgs<ExtArgs>
    counselor?: boolean | CounselorDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MeetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Meeting"
    objects: {
      consultationRequest: Prisma.$ConsultationRequestPayload<ExtArgs>
      counselor: Prisma.$CounselorPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      consultationRequestId: number
      counselorId: string
      userId: number
      meetingProvider: $Enums.MeetingProvider
      meetingRoomId: string
      startTime: Date | null
      endTime: Date | null
      duration: number | null
      status: $Enums.MeetingStatus
      createdAt: Date
    }, ExtArgs["result"]["meeting"]>
    composites: {}
  }

  type MeetingGetPayload<S extends boolean | null | undefined | MeetingDefaultArgs> = $Result.GetResult<Prisma.$MeetingPayload, S>

  type MeetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MeetingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MeetingCountAggregateInputType | true
    }

  export interface MeetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meeting'], meta: { name: 'Meeting' } }
    /**
     * Find zero or one Meeting that matches the filter.
     * @param {MeetingFindUniqueArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingFindUniqueArgs>(args: SelectSubset<T, MeetingFindUniqueArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Meeting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MeetingFindUniqueOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Meeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingFindFirstArgs>(args?: SelectSubset<T, MeetingFindFirstArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Meeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Meetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meetings
     * const meetings = await prisma.meeting.findMany()
     * 
     * // Get first 10 Meetings
     * const meetings = await prisma.meeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingWithIdOnly = await prisma.meeting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeetingFindManyArgs>(args?: SelectSubset<T, MeetingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Meeting.
     * @param {MeetingCreateArgs} args - Arguments to create a Meeting.
     * @example
     * // Create one Meeting
     * const Meeting = await prisma.meeting.create({
     *   data: {
     *     // ... data to create a Meeting
     *   }
     * })
     * 
     */
    create<T extends MeetingCreateArgs>(args: SelectSubset<T, MeetingCreateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Meetings.
     * @param {MeetingCreateManyArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingCreateManyArgs>(args?: SelectSubset<T, MeetingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Meetings and returns the data saved in the database.
     * @param {MeetingCreateManyAndReturnArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Meetings and only return the `id`
     * const meetingWithIdOnly = await prisma.meeting.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeetingCreateManyAndReturnArgs>(args?: SelectSubset<T, MeetingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Meeting.
     * @param {MeetingDeleteArgs} args - Arguments to delete one Meeting.
     * @example
     * // Delete one Meeting
     * const Meeting = await prisma.meeting.delete({
     *   where: {
     *     // ... filter to delete one Meeting
     *   }
     * })
     * 
     */
    delete<T extends MeetingDeleteArgs>(args: SelectSubset<T, MeetingDeleteArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Meeting.
     * @param {MeetingUpdateArgs} args - Arguments to update one Meeting.
     * @example
     * // Update one Meeting
     * const meeting = await prisma.meeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingUpdateArgs>(args: SelectSubset<T, MeetingUpdateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Meetings.
     * @param {MeetingDeleteManyArgs} args - Arguments to filter Meetings to delete.
     * @example
     * // Delete a few Meetings
     * const { count } = await prisma.meeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingDeleteManyArgs>(args?: SelectSubset<T, MeetingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingUpdateManyArgs>(args: SelectSubset<T, MeetingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meeting.
     * @param {MeetingUpsertArgs} args - Arguments to update or create a Meeting.
     * @example
     * // Update or create a Meeting
     * const meeting = await prisma.meeting.upsert({
     *   create: {
     *     // ... data to create a Meeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meeting we want to update
     *   }
     * })
     */
    upsert<T extends MeetingUpsertArgs>(args: SelectSubset<T, MeetingUpsertArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingCountArgs} args - Arguments to filter Meetings to count.
     * @example
     * // Count the number of Meetings
     * const count = await prisma.meeting.count({
     *   where: {
     *     // ... the filter for the Meetings we want to count
     *   }
     * })
    **/
    count<T extends MeetingCountArgs>(
      args?: Subset<T, MeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingAggregateArgs>(args: Subset<T, MeetingAggregateArgs>): Prisma.PrismaPromise<GetMeetingAggregateType<T>>

    /**
     * Group by Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingGroupByArgs['orderBy'] }
        : { orderBy?: MeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Meeting model
   */
  readonly fields: MeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultationRequest<T extends ConsultationRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationRequestDefaultArgs<ExtArgs>>): Prisma__ConsultationRequestClient<$Result.GetResult<Prisma.$ConsultationRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    counselor<T extends CounselorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CounselorDefaultArgs<ExtArgs>>): Prisma__CounselorClient<$Result.GetResult<Prisma.$CounselorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Meeting model
   */ 
  interface MeetingFieldRefs {
    readonly id: FieldRef<"Meeting", 'String'>
    readonly consultationRequestId: FieldRef<"Meeting", 'Int'>
    readonly counselorId: FieldRef<"Meeting", 'String'>
    readonly userId: FieldRef<"Meeting", 'Int'>
    readonly meetingProvider: FieldRef<"Meeting", 'MeetingProvider'>
    readonly meetingRoomId: FieldRef<"Meeting", 'String'>
    readonly startTime: FieldRef<"Meeting", 'DateTime'>
    readonly endTime: FieldRef<"Meeting", 'DateTime'>
    readonly duration: FieldRef<"Meeting", 'Int'>
    readonly status: FieldRef<"Meeting", 'MeetingStatus'>
    readonly createdAt: FieldRef<"Meeting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Meeting findUnique
   */
  export type MeetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findUniqueOrThrow
   */
  export type MeetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findFirst
   */
  export type MeetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findFirstOrThrow
   */
  export type MeetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findMany
   */
  export type MeetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meetings to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting create
   */
  export type MeetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to create a Meeting.
     */
    data: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
  }

  /**
   * Meeting createMany
   */
  export type MeetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Meeting createManyAndReturn
   */
  export type MeetingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Meeting update
   */
  export type MeetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to update a Meeting.
     */
    data: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
    /**
     * Choose, which Meeting to update.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting updateMany
   */
  export type MeetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meetings.
     */
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyInput>
    /**
     * Filter which Meetings to update
     */
    where?: MeetingWhereInput
  }

  /**
   * Meeting upsert
   */
  export type MeetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The filter to search for the Meeting to update in case it exists.
     */
    where: MeetingWhereUniqueInput
    /**
     * In case the Meeting found by the `where` argument doesn't exist, create a new Meeting with this data.
     */
    create: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
    /**
     * In case the Meeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
  }

  /**
   * Meeting delete
   */
  export type MeetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter which Meeting to delete.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting deleteMany
   */
  export type MeetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meetings to delete
     */
    where?: MeetingWhereInput
  }

  /**
   * Meeting without action
   */
  export type MeetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceAvgAggregateOutputType = {
    id: number | null
    downloads: number | null
  }

  export type ResourceSumAggregateOutputType = {
    id: number | null
    downloads: number | null
  }

  export type ResourceMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    category: $Enums.ResourceCategory | null
    type: string | null
    url: string | null
    size: string | null
    uploadedBy: string | null
    downloads: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    category: $Enums.ResourceCategory | null
    type: string | null
    url: string | null
    size: string | null
    uploadedBy: string | null
    downloads: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    type: number
    url: number
    size: number
    uploadedBy: number
    downloads: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResourceAvgAggregateInputType = {
    id?: true
    downloads?: true
  }

  export type ResourceSumAggregateInputType = {
    id?: true
    downloads?: true
  }

  export type ResourceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    type?: true
    url?: true
    size?: true
    uploadedBy?: true
    downloads?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    type?: true
    url?: true
    size?: true
    uploadedBy?: true
    downloads?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    type?: true
    url?: true
    size?: true
    uploadedBy?: true
    downloads?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _avg?: ResourceAvgAggregateInputType
    _sum?: ResourceSumAggregateInputType
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: number
    title: string
    description: string | null
    category: $Enums.ResourceCategory
    type: string
    url: string
    size: string | null
    uploadedBy: string | null
    downloads: number
    createdAt: Date
    updatedAt: Date
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    uploadedBy?: boolean
    downloads?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    uploadedBy?: boolean
    downloads?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    uploadedBy?: boolean
    downloads?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      category: $Enums.ResourceCategory
      type: string
      url: string
      size: string | null
      uploadedBy: string | null
      downloads: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceFindUniqueArgs>(args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceFindFirstArgs>(args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceFindManyArgs>(args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends ResourceCreateArgs>(args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Resources.
     * @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCreateManyArgs>(args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {ResourceCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends ResourceDeleteArgs>(args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceUpdateArgs>(args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDeleteManyArgs>(args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceUpdateManyArgs>(args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends ResourceUpsertArgs>(args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resource model
   */ 
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'Int'>
    readonly title: FieldRef<"Resource", 'String'>
    readonly description: FieldRef<"Resource", 'String'>
    readonly category: FieldRef<"Resource", 'ResourceCategory'>
    readonly type: FieldRef<"Resource", 'String'>
    readonly url: FieldRef<"Resource", 'String'>
    readonly size: FieldRef<"Resource", 'String'>
    readonly uploadedBy: FieldRef<"Resource", 'String'>
    readonly downloads: FieldRef<"Resource", 'Int'>
    readonly createdAt: FieldRef<"Resource", 'DateTime'>
    readonly updatedAt: FieldRef<"Resource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource createManyAndReturn
   */
  export type ResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    phoneNo: 'phoneNo',
    address: 'address',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    state: 'state',
    country: 'country',
    profileImage: 'profileImage',
    currenrStudyLevel: 'currenrStudyLevel',
    email: 'email',
    username: 'username',
    password: 'password',
    isActive: 'isActive',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const UserRoleMappingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    assignedAt: 'assignedAt',
    assignedBy: 'assignedBy'
  };

  export type UserRoleMappingScalarFieldEnum = (typeof UserRoleMappingScalarFieldEnum)[keyof typeof UserRoleMappingScalarFieldEnum]


  export const CoursesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    price: 'price',
    thumbnailUrl: 'thumbnailUrl',
    instructor: 'instructor',
    duration: 'duration',
    level: 'level',
    category: 'category',
    language: 'language',
    isPublished: 'isPublished',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type CoursesScalarFieldEnum = (typeof CoursesScalarFieldEnum)[keyof typeof CoursesScalarFieldEnum]


  export const LessonsScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    title: 'title',
    description: 'description',
    videoType: 'videoType',
    videoId: 'videoId',
    duration: 'duration',
    order: 'order',
    isFreePreview: 'isFreePreview'
  };

  export type LessonsScalarFieldEnum = (typeof LessonsScalarFieldEnum)[keyof typeof LessonsScalarFieldEnum]


  export const CourseUserMapperScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    enrolledAt: 'enrolledAt',
    completedAt: 'completedAt',
    progress: 'progress',
    isCompleted: 'isCompleted'
  };

  export type CourseUserMapperScalarFieldEnum = (typeof CourseUserMapperScalarFieldEnum)[keyof typeof CourseUserMapperScalarFieldEnum]


  export const ContestScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    startTime: 'startTime',
    endTime: 'endTime',
    isPublished: 'isPublished',
    durationMinutes: 'durationMinutes',
    totalMarks: 'totalMarks',
    isActive: 'isActive',
    createdByAdminId: 'createdByAdminId',
    createdAt: 'createdAt'
  };

  export type ContestScalarFieldEnum = (typeof ContestScalarFieldEnum)[keyof typeof ContestScalarFieldEnum]


  export const ContestQuestionScalarFieldEnum: {
    id: 'id',
    contestId: 'contestId',
    questionText: 'questionText',
    optionA: 'optionA',
    optionB: 'optionB',
    optionC: 'optionC',
    optionD: 'optionD',
    correctOption: 'correctOption',
    marks: 'marks'
  };

  export type ContestQuestionScalarFieldEnum = (typeof ContestQuestionScalarFieldEnum)[keyof typeof ContestQuestionScalarFieldEnum]


  export const ContestAttemptScalarFieldEnum: {
    id: 'id',
    contestId: 'contestId',
    userId: 'userId',
    startedAt: 'startedAt',
    submittedAt: 'submittedAt',
    score: 'score',
    timeTaken: 'timeTaken'
  };

  export type ContestAttemptScalarFieldEnum = (typeof ContestAttemptScalarFieldEnum)[keyof typeof ContestAttemptScalarFieldEnum]


  export const ContestAnswerScalarFieldEnum: {
    id: 'id',
    attemptId: 'attemptId',
    questionId: 'questionId',
    selectedOption: 'selectedOption',
    isCorrect: 'isCorrect'
  };

  export type ContestAnswerScalarFieldEnum = (typeof ContestAnswerScalarFieldEnum)[keyof typeof ContestAnswerScalarFieldEnum]


  export const ChallengeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    type: 'type',
    category: 'category',
    difficulty: 'difficulty',
    points: 'points',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive'
  };

  export type ChallengeScalarFieldEnum = (typeof ChallengeScalarFieldEnum)[keyof typeof ChallengeScalarFieldEnum]


  export const ChallengeAttemptScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    userId: 'userId',
    completedAt: 'completedAt',
    earnedPoints: 'earnedPoints'
  };

  export type ChallengeAttemptScalarFieldEnum = (typeof ChallengeAttemptScalarFieldEnum)[keyof typeof ChallengeAttemptScalarFieldEnum]


  export const CounselorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    bio: 'bio',
    profileImage: 'profileImage',
    specialization: 'specialization',
    experience: 'experience',
    employmentType: 'employmentType',
    isActive: 'isActive',
    rating: 'rating',
    totalMeetings: 'totalMeetings',
    totalRevenue: 'totalRevenue',
    createdByAdminId: 'createdByAdminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CounselorScalarFieldEnum = (typeof CounselorScalarFieldEnum)[keyof typeof CounselorScalarFieldEnum]


  export const ConsultationRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    counselorId: 'counselorId',
    requestType: 'requestType',
    scheduledAt: 'scheduledAt',
    status: 'status',
    message: 'message',
    respondedAt: 'respondedAt',
    createdAt: 'createdAt'
  };

  export type ConsultationRequestScalarFieldEnum = (typeof ConsultationRequestScalarFieldEnum)[keyof typeof ConsultationRequestScalarFieldEnum]


  export const MeetingScalarFieldEnum: {
    id: 'id',
    consultationRequestId: 'consultationRequestId',
    counselorId: 'counselorId',
    userId: 'userId',
    meetingProvider: 'meetingProvider',
    meetingRoomId: 'meetingRoomId',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type MeetingScalarFieldEnum = (typeof MeetingScalarFieldEnum)[keyof typeof MeetingScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    type: 'type',
    url: 'url',
    size: 'size',
    uploadedBy: 'uploadedBy',
    downloads: 'downloads',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'currenrStudylevel'
   */
  export type EnumcurrenrStudylevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'currenrStudylevel'>
    


  /**
   * Reference to a field of type 'currenrStudylevel[]'
   */
  export type ListEnumcurrenrStudylevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'currenrStudylevel[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CourseLevel'
   */
  export type EnumCourseLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseLevel'>
    


  /**
   * Reference to a field of type 'CourseLevel[]'
   */
  export type ListEnumCourseLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseLevel[]'>
    


  /**
   * Reference to a field of type 'ChallengeType'
   */
  export type EnumChallengeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeType'>
    


  /**
   * Reference to a field of type 'ChallengeType[]'
   */
  export type ListEnumChallengeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeType[]'>
    


  /**
   * Reference to a field of type 'EmploymentType'
   */
  export type EnumEmploymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentType'>
    


  /**
   * Reference to a field of type 'EmploymentType[]'
   */
  export type ListEnumEmploymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentType[]'>
    


  /**
   * Reference to a field of type 'ConsultationType'
   */
  export type EnumConsultationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsultationType'>
    


  /**
   * Reference to a field of type 'ConsultationType[]'
   */
  export type ListEnumConsultationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsultationType[]'>
    


  /**
   * Reference to a field of type 'ConsultationStatus'
   */
  export type EnumConsultationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsultationStatus'>
    


  /**
   * Reference to a field of type 'ConsultationStatus[]'
   */
  export type ListEnumConsultationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsultationStatus[]'>
    


  /**
   * Reference to a field of type 'MeetingProvider'
   */
  export type EnumMeetingProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeetingProvider'>
    


  /**
   * Reference to a field of type 'MeetingProvider[]'
   */
  export type ListEnumMeetingProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeetingProvider[]'>
    


  /**
   * Reference to a field of type 'MeetingStatus'
   */
  export type EnumMeetingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeetingStatus'>
    


  /**
   * Reference to a field of type 'MeetingStatus[]'
   */
  export type ListEnumMeetingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeetingStatus[]'>
    


  /**
   * Reference to a field of type 'ResourceCategory'
   */
  export type EnumResourceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceCategory'>
    


  /**
   * Reference to a field of type 'ResourceCategory[]'
   */
  export type ListEnumResourceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceCategory[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phoneNo?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    currenrStudyLevel?: EnumcurrenrStudylevelNullableFilter<"User"> | $Enums.currenrStudylevel | null
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    isDeleted?: BoolFilter<"User"> | boolean
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    userRoleMappings?: UserRoleMappingListRelationFilter
    ContestAttempt?: ContestAttemptListRelationFilter
    ChallengeAttempt?: ChallengeAttemptListRelationFilter
    consultationRequests?: ConsultationRequestListRelationFilter
    meetings?: MeetingListRelationFilter
    enrolledCourses?: CourseUserMapperListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phoneNo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    currenrStudyLevel?: SortOrderInput | SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userRoleMappings?: UserRoleMappingOrderByRelationAggregateInput
    ContestAttempt?: ContestAttemptOrderByRelationAggregateInput
    ChallengeAttempt?: ChallengeAttemptOrderByRelationAggregateInput
    consultationRequests?: ConsultationRequestOrderByRelationAggregateInput
    meetings?: MeetingOrderByRelationAggregateInput
    enrolledCourses?: CourseUserMapperOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phoneNo?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    currenrStudyLevel?: EnumcurrenrStudylevelNullableFilter<"User"> | $Enums.currenrStudylevel | null
    password?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    isDeleted?: BoolFilter<"User"> | boolean
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    userRoleMappings?: UserRoleMappingListRelationFilter
    ContestAttempt?: ContestAttemptListRelationFilter
    ChallengeAttempt?: ChallengeAttemptListRelationFilter
    consultationRequests?: ConsultationRequestListRelationFilter
    meetings?: MeetingListRelationFilter
    enrolledCourses?: CourseUserMapperListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phoneNo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    currenrStudyLevel?: SortOrderInput | SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNo?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    state?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    currenrStudyLevel?: EnumcurrenrStudylevelNullableWithAggregatesFilter<"User"> | $Enums.currenrStudylevel | null
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"User"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    id?: IntFilter<"roles"> | number
    name?: StringFilter<"roles"> | string
    description?: StringNullableFilter<"roles"> | string | null
    createdAt?: DateTimeFilter<"roles"> | Date | string
    updatedAt?: DateTimeNullableFilter<"roles"> | Date | string | null
    userRoleMappings?: UserRoleMappingListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userRoleMappings?: UserRoleMappingOrderByRelationAggregateInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    description?: StringNullableFilter<"roles"> | string | null
    createdAt?: DateTimeFilter<"roles"> | Date | string
    updatedAt?: DateTimeNullableFilter<"roles"> | Date | string | null
    userRoleMappings?: UserRoleMappingListRelationFilter
  }, "id" | "name">

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"roles"> | number
    name?: StringWithAggregatesFilter<"roles"> | string
    description?: StringNullableWithAggregatesFilter<"roles"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"roles"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"roles"> | Date | string | null
  }

  export type UserRoleMappingWhereInput = {
    AND?: UserRoleMappingWhereInput | UserRoleMappingWhereInput[]
    OR?: UserRoleMappingWhereInput[]
    NOT?: UserRoleMappingWhereInput | UserRoleMappingWhereInput[]
    id?: IntFilter<"UserRoleMapping"> | number
    userId?: IntFilter<"UserRoleMapping"> | number
    roleId?: IntFilter<"UserRoleMapping"> | number
    assignedAt?: DateTimeFilter<"UserRoleMapping"> | Date | string
    assignedBy?: IntNullableFilter<"UserRoleMapping"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RolesRelationFilter, rolesWhereInput>
  }

  export type UserRoleMappingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    role?: rolesOrderByWithRelationInput
  }

  export type UserRoleMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_roleId?: UserRoleMappingUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleMappingWhereInput | UserRoleMappingWhereInput[]
    OR?: UserRoleMappingWhereInput[]
    NOT?: UserRoleMappingWhereInput | UserRoleMappingWhereInput[]
    userId?: IntFilter<"UserRoleMapping"> | number
    roleId?: IntFilter<"UserRoleMapping"> | number
    assignedAt?: DateTimeFilter<"UserRoleMapping"> | Date | string
    assignedBy?: IntNullableFilter<"UserRoleMapping"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RolesRelationFilter, rolesWhereInput>
  }, "id" | "userId_roleId">

  export type UserRoleMappingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    _count?: UserRoleMappingCountOrderByAggregateInput
    _avg?: UserRoleMappingAvgOrderByAggregateInput
    _max?: UserRoleMappingMaxOrderByAggregateInput
    _min?: UserRoleMappingMinOrderByAggregateInput
    _sum?: UserRoleMappingSumOrderByAggregateInput
  }

  export type UserRoleMappingScalarWhereWithAggregatesInput = {
    AND?: UserRoleMappingScalarWhereWithAggregatesInput | UserRoleMappingScalarWhereWithAggregatesInput[]
    OR?: UserRoleMappingScalarWhereWithAggregatesInput[]
    NOT?: UserRoleMappingScalarWhereWithAggregatesInput | UserRoleMappingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserRoleMapping"> | number
    userId?: IntWithAggregatesFilter<"UserRoleMapping"> | number
    roleId?: IntWithAggregatesFilter<"UserRoleMapping"> | number
    assignedAt?: DateTimeWithAggregatesFilter<"UserRoleMapping"> | Date | string
    assignedBy?: IntNullableWithAggregatesFilter<"UserRoleMapping"> | number | null
  }

  export type CoursesWhereInput = {
    AND?: CoursesWhereInput | CoursesWhereInput[]
    OR?: CoursesWhereInput[]
    NOT?: CoursesWhereInput | CoursesWhereInput[]
    id?: IntFilter<"Courses"> | number
    title?: StringFilter<"Courses"> | string
    description?: StringNullableFilter<"Courses"> | string | null
    price?: FloatFilter<"Courses"> | number
    thumbnailUrl?: StringNullableFilter<"Courses"> | string | null
    instructor?: StringNullableFilter<"Courses"> | string | null
    duration?: StringNullableFilter<"Courses"> | string | null
    level?: EnumCourseLevelFilter<"Courses"> | $Enums.CourseLevel
    category?: StringNullableFilter<"Courses"> | string | null
    language?: StringNullableFilter<"Courses"> | string | null
    isPublished?: BoolFilter<"Courses"> | boolean
    createdBy?: IntNullableFilter<"Courses"> | number | null
    createdAt?: DateTimeNullableFilter<"Courses"> | Date | string | null
    lessons?: LessonsListRelationFilter
    enrolledUsers?: CourseUserMapperListRelationFilter
  }

  export type CoursesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    instructor?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    level?: SortOrder
    category?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    lessons?: LessonsOrderByRelationAggregateInput
    enrolledUsers?: CourseUserMapperOrderByRelationAggregateInput
  }

  export type CoursesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CoursesWhereInput | CoursesWhereInput[]
    OR?: CoursesWhereInput[]
    NOT?: CoursesWhereInput | CoursesWhereInput[]
    title?: StringFilter<"Courses"> | string
    description?: StringNullableFilter<"Courses"> | string | null
    price?: FloatFilter<"Courses"> | number
    thumbnailUrl?: StringNullableFilter<"Courses"> | string | null
    instructor?: StringNullableFilter<"Courses"> | string | null
    duration?: StringNullableFilter<"Courses"> | string | null
    level?: EnumCourseLevelFilter<"Courses"> | $Enums.CourseLevel
    category?: StringNullableFilter<"Courses"> | string | null
    language?: StringNullableFilter<"Courses"> | string | null
    isPublished?: BoolFilter<"Courses"> | boolean
    createdBy?: IntNullableFilter<"Courses"> | number | null
    createdAt?: DateTimeNullableFilter<"Courses"> | Date | string | null
    lessons?: LessonsListRelationFilter
    enrolledUsers?: CourseUserMapperListRelationFilter
  }, "id">

  export type CoursesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    instructor?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    level?: SortOrder
    category?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: CoursesCountOrderByAggregateInput
    _avg?: CoursesAvgOrderByAggregateInput
    _max?: CoursesMaxOrderByAggregateInput
    _min?: CoursesMinOrderByAggregateInput
    _sum?: CoursesSumOrderByAggregateInput
  }

  export type CoursesScalarWhereWithAggregatesInput = {
    AND?: CoursesScalarWhereWithAggregatesInput | CoursesScalarWhereWithAggregatesInput[]
    OR?: CoursesScalarWhereWithAggregatesInput[]
    NOT?: CoursesScalarWhereWithAggregatesInput | CoursesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Courses"> | number
    title?: StringWithAggregatesFilter<"Courses"> | string
    description?: StringNullableWithAggregatesFilter<"Courses"> | string | null
    price?: FloatWithAggregatesFilter<"Courses"> | number
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Courses"> | string | null
    instructor?: StringNullableWithAggregatesFilter<"Courses"> | string | null
    duration?: StringNullableWithAggregatesFilter<"Courses"> | string | null
    level?: EnumCourseLevelWithAggregatesFilter<"Courses"> | $Enums.CourseLevel
    category?: StringNullableWithAggregatesFilter<"Courses"> | string | null
    language?: StringNullableWithAggregatesFilter<"Courses"> | string | null
    isPublished?: BoolWithAggregatesFilter<"Courses"> | boolean
    createdBy?: IntNullableWithAggregatesFilter<"Courses"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Courses"> | Date | string | null
  }

  export type LessonsWhereInput = {
    AND?: LessonsWhereInput | LessonsWhereInput[]
    OR?: LessonsWhereInput[]
    NOT?: LessonsWhereInput | LessonsWhereInput[]
    id?: IntFilter<"Lessons"> | number
    courseId?: IntFilter<"Lessons"> | number
    title?: StringFilter<"Lessons"> | string
    description?: StringNullableFilter<"Lessons"> | string | null
    videoType?: StringFilter<"Lessons"> | string
    videoId?: StringFilter<"Lessons"> | string
    duration?: IntNullableFilter<"Lessons"> | number | null
    order?: IntFilter<"Lessons"> | number
    isFreePreview?: BoolFilter<"Lessons"> | boolean
    course?: XOR<CoursesRelationFilter, CoursesWhereInput>
  }

  export type LessonsOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    videoType?: SortOrder
    videoId?: SortOrder
    duration?: SortOrderInput | SortOrder
    order?: SortOrder
    isFreePreview?: SortOrder
    course?: CoursesOrderByWithRelationInput
  }

  export type LessonsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LessonsWhereInput | LessonsWhereInput[]
    OR?: LessonsWhereInput[]
    NOT?: LessonsWhereInput | LessonsWhereInput[]
    courseId?: IntFilter<"Lessons"> | number
    title?: StringFilter<"Lessons"> | string
    description?: StringNullableFilter<"Lessons"> | string | null
    videoType?: StringFilter<"Lessons"> | string
    videoId?: StringFilter<"Lessons"> | string
    duration?: IntNullableFilter<"Lessons"> | number | null
    order?: IntFilter<"Lessons"> | number
    isFreePreview?: BoolFilter<"Lessons"> | boolean
    course?: XOR<CoursesRelationFilter, CoursesWhereInput>
  }, "id">

  export type LessonsOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    videoType?: SortOrder
    videoId?: SortOrder
    duration?: SortOrderInput | SortOrder
    order?: SortOrder
    isFreePreview?: SortOrder
    _count?: LessonsCountOrderByAggregateInput
    _avg?: LessonsAvgOrderByAggregateInput
    _max?: LessonsMaxOrderByAggregateInput
    _min?: LessonsMinOrderByAggregateInput
    _sum?: LessonsSumOrderByAggregateInput
  }

  export type LessonsScalarWhereWithAggregatesInput = {
    AND?: LessonsScalarWhereWithAggregatesInput | LessonsScalarWhereWithAggregatesInput[]
    OR?: LessonsScalarWhereWithAggregatesInput[]
    NOT?: LessonsScalarWhereWithAggregatesInput | LessonsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Lessons"> | number
    courseId?: IntWithAggregatesFilter<"Lessons"> | number
    title?: StringWithAggregatesFilter<"Lessons"> | string
    description?: StringNullableWithAggregatesFilter<"Lessons"> | string | null
    videoType?: StringWithAggregatesFilter<"Lessons"> | string
    videoId?: StringWithAggregatesFilter<"Lessons"> | string
    duration?: IntNullableWithAggregatesFilter<"Lessons"> | number | null
    order?: IntWithAggregatesFilter<"Lessons"> | number
    isFreePreview?: BoolWithAggregatesFilter<"Lessons"> | boolean
  }

  export type CourseUserMapperWhereInput = {
    AND?: CourseUserMapperWhereInput | CourseUserMapperWhereInput[]
    OR?: CourseUserMapperWhereInput[]
    NOT?: CourseUserMapperWhereInput | CourseUserMapperWhereInput[]
    id?: IntFilter<"CourseUserMapper"> | number
    userId?: IntFilter<"CourseUserMapper"> | number
    courseId?: IntFilter<"CourseUserMapper"> | number
    enrolledAt?: DateTimeFilter<"CourseUserMapper"> | Date | string
    completedAt?: DateTimeNullableFilter<"CourseUserMapper"> | Date | string | null
    progress?: IntFilter<"CourseUserMapper"> | number
    isCompleted?: BoolFilter<"CourseUserMapper"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CoursesRelationFilter, CoursesWhereInput>
  }

  export type CourseUserMapperOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    isCompleted?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CoursesOrderByWithRelationInput
  }

  export type CourseUserMapperWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_courseId?: CourseUserMapperUserIdCourseIdCompoundUniqueInput
    AND?: CourseUserMapperWhereInput | CourseUserMapperWhereInput[]
    OR?: CourseUserMapperWhereInput[]
    NOT?: CourseUserMapperWhereInput | CourseUserMapperWhereInput[]
    userId?: IntFilter<"CourseUserMapper"> | number
    courseId?: IntFilter<"CourseUserMapper"> | number
    enrolledAt?: DateTimeFilter<"CourseUserMapper"> | Date | string
    completedAt?: DateTimeNullableFilter<"CourseUserMapper"> | Date | string | null
    progress?: IntFilter<"CourseUserMapper"> | number
    isCompleted?: BoolFilter<"CourseUserMapper"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CoursesRelationFilter, CoursesWhereInput>
  }, "id" | "userId_courseId">

  export type CourseUserMapperOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    isCompleted?: SortOrder
    _count?: CourseUserMapperCountOrderByAggregateInput
    _avg?: CourseUserMapperAvgOrderByAggregateInput
    _max?: CourseUserMapperMaxOrderByAggregateInput
    _min?: CourseUserMapperMinOrderByAggregateInput
    _sum?: CourseUserMapperSumOrderByAggregateInput
  }

  export type CourseUserMapperScalarWhereWithAggregatesInput = {
    AND?: CourseUserMapperScalarWhereWithAggregatesInput | CourseUserMapperScalarWhereWithAggregatesInput[]
    OR?: CourseUserMapperScalarWhereWithAggregatesInput[]
    NOT?: CourseUserMapperScalarWhereWithAggregatesInput | CourseUserMapperScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseUserMapper"> | number
    userId?: IntWithAggregatesFilter<"CourseUserMapper"> | number
    courseId?: IntWithAggregatesFilter<"CourseUserMapper"> | number
    enrolledAt?: DateTimeWithAggregatesFilter<"CourseUserMapper"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"CourseUserMapper"> | Date | string | null
    progress?: IntWithAggregatesFilter<"CourseUserMapper"> | number
    isCompleted?: BoolWithAggregatesFilter<"CourseUserMapper"> | boolean
  }

  export type ContestWhereInput = {
    AND?: ContestWhereInput | ContestWhereInput[]
    OR?: ContestWhereInput[]
    NOT?: ContestWhereInput | ContestWhereInput[]
    id?: IntFilter<"Contest"> | number
    title?: StringFilter<"Contest"> | string
    description?: StringNullableFilter<"Contest"> | string | null
    category?: StringFilter<"Contest"> | string
    startTime?: DateTimeFilter<"Contest"> | Date | string
    endTime?: DateTimeFilter<"Contest"> | Date | string
    isPublished?: BoolFilter<"Contest"> | boolean
    durationMinutes?: IntNullableFilter<"Contest"> | number | null
    totalMarks?: IntNullableFilter<"Contest"> | number | null
    isActive?: BoolFilter<"Contest"> | boolean
    createdByAdminId?: IntNullableFilter<"Contest"> | number | null
    createdAt?: DateTimeFilter<"Contest"> | Date | string
    ContestQuestion?: ContestQuestionListRelationFilter
    ContestAttempt?: ContestAttemptListRelationFilter
  }

  export type ContestOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isPublished?: SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    totalMarks?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdByAdminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    ContestQuestion?: ContestQuestionOrderByRelationAggregateInput
    ContestAttempt?: ContestAttemptOrderByRelationAggregateInput
  }

  export type ContestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContestWhereInput | ContestWhereInput[]
    OR?: ContestWhereInput[]
    NOT?: ContestWhereInput | ContestWhereInput[]
    title?: StringFilter<"Contest"> | string
    description?: StringNullableFilter<"Contest"> | string | null
    category?: StringFilter<"Contest"> | string
    startTime?: DateTimeFilter<"Contest"> | Date | string
    endTime?: DateTimeFilter<"Contest"> | Date | string
    isPublished?: BoolFilter<"Contest"> | boolean
    durationMinutes?: IntNullableFilter<"Contest"> | number | null
    totalMarks?: IntNullableFilter<"Contest"> | number | null
    isActive?: BoolFilter<"Contest"> | boolean
    createdByAdminId?: IntNullableFilter<"Contest"> | number | null
    createdAt?: DateTimeFilter<"Contest"> | Date | string
    ContestQuestion?: ContestQuestionListRelationFilter
    ContestAttempt?: ContestAttemptListRelationFilter
  }, "id">

  export type ContestOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isPublished?: SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    totalMarks?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdByAdminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ContestCountOrderByAggregateInput
    _avg?: ContestAvgOrderByAggregateInput
    _max?: ContestMaxOrderByAggregateInput
    _min?: ContestMinOrderByAggregateInput
    _sum?: ContestSumOrderByAggregateInput
  }

  export type ContestScalarWhereWithAggregatesInput = {
    AND?: ContestScalarWhereWithAggregatesInput | ContestScalarWhereWithAggregatesInput[]
    OR?: ContestScalarWhereWithAggregatesInput[]
    NOT?: ContestScalarWhereWithAggregatesInput | ContestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contest"> | number
    title?: StringWithAggregatesFilter<"Contest"> | string
    description?: StringNullableWithAggregatesFilter<"Contest"> | string | null
    category?: StringWithAggregatesFilter<"Contest"> | string
    startTime?: DateTimeWithAggregatesFilter<"Contest"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Contest"> | Date | string
    isPublished?: BoolWithAggregatesFilter<"Contest"> | boolean
    durationMinutes?: IntNullableWithAggregatesFilter<"Contest"> | number | null
    totalMarks?: IntNullableWithAggregatesFilter<"Contest"> | number | null
    isActive?: BoolWithAggregatesFilter<"Contest"> | boolean
    createdByAdminId?: IntNullableWithAggregatesFilter<"Contest"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Contest"> | Date | string
  }

  export type ContestQuestionWhereInput = {
    AND?: ContestQuestionWhereInput | ContestQuestionWhereInput[]
    OR?: ContestQuestionWhereInput[]
    NOT?: ContestQuestionWhereInput | ContestQuestionWhereInput[]
    id?: IntFilter<"ContestQuestion"> | number
    contestId?: IntFilter<"ContestQuestion"> | number
    questionText?: StringFilter<"ContestQuestion"> | string
    optionA?: StringFilter<"ContestQuestion"> | string
    optionB?: StringFilter<"ContestQuestion"> | string
    optionC?: StringNullableFilter<"ContestQuestion"> | string | null
    optionD?: StringNullableFilter<"ContestQuestion"> | string | null
    correctOption?: StringFilter<"ContestQuestion"> | string
    marks?: IntFilter<"ContestQuestion"> | number
    contestanswer?: ContestAnswerListRelationFilter
    contest?: XOR<ContestRelationFilter, ContestWhereInput>
  }

  export type ContestQuestionOrderByWithRelationInput = {
    id?: SortOrder
    contestId?: SortOrder
    questionText?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrderInput | SortOrder
    optionD?: SortOrderInput | SortOrder
    correctOption?: SortOrder
    marks?: SortOrder
    contestanswer?: ContestAnswerOrderByRelationAggregateInput
    contest?: ContestOrderByWithRelationInput
  }

  export type ContestQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContestQuestionWhereInput | ContestQuestionWhereInput[]
    OR?: ContestQuestionWhereInput[]
    NOT?: ContestQuestionWhereInput | ContestQuestionWhereInput[]
    contestId?: IntFilter<"ContestQuestion"> | number
    questionText?: StringFilter<"ContestQuestion"> | string
    optionA?: StringFilter<"ContestQuestion"> | string
    optionB?: StringFilter<"ContestQuestion"> | string
    optionC?: StringNullableFilter<"ContestQuestion"> | string | null
    optionD?: StringNullableFilter<"ContestQuestion"> | string | null
    correctOption?: StringFilter<"ContestQuestion"> | string
    marks?: IntFilter<"ContestQuestion"> | number
    contestanswer?: ContestAnswerListRelationFilter
    contest?: XOR<ContestRelationFilter, ContestWhereInput>
  }, "id">

  export type ContestQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    contestId?: SortOrder
    questionText?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrderInput | SortOrder
    optionD?: SortOrderInput | SortOrder
    correctOption?: SortOrder
    marks?: SortOrder
    _count?: ContestQuestionCountOrderByAggregateInput
    _avg?: ContestQuestionAvgOrderByAggregateInput
    _max?: ContestQuestionMaxOrderByAggregateInput
    _min?: ContestQuestionMinOrderByAggregateInput
    _sum?: ContestQuestionSumOrderByAggregateInput
  }

  export type ContestQuestionScalarWhereWithAggregatesInput = {
    AND?: ContestQuestionScalarWhereWithAggregatesInput | ContestQuestionScalarWhereWithAggregatesInput[]
    OR?: ContestQuestionScalarWhereWithAggregatesInput[]
    NOT?: ContestQuestionScalarWhereWithAggregatesInput | ContestQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContestQuestion"> | number
    contestId?: IntWithAggregatesFilter<"ContestQuestion"> | number
    questionText?: StringWithAggregatesFilter<"ContestQuestion"> | string
    optionA?: StringWithAggregatesFilter<"ContestQuestion"> | string
    optionB?: StringWithAggregatesFilter<"ContestQuestion"> | string
    optionC?: StringNullableWithAggregatesFilter<"ContestQuestion"> | string | null
    optionD?: StringNullableWithAggregatesFilter<"ContestQuestion"> | string | null
    correctOption?: StringWithAggregatesFilter<"ContestQuestion"> | string
    marks?: IntWithAggregatesFilter<"ContestQuestion"> | number
  }

  export type ContestAttemptWhereInput = {
    AND?: ContestAttemptWhereInput | ContestAttemptWhereInput[]
    OR?: ContestAttemptWhereInput[]
    NOT?: ContestAttemptWhereInput | ContestAttemptWhereInput[]
    id?: IntFilter<"ContestAttempt"> | number
    contestId?: IntFilter<"ContestAttempt"> | number
    userId?: IntFilter<"ContestAttempt"> | number
    startedAt?: DateTimeFilter<"ContestAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"ContestAttempt"> | Date | string | null
    score?: IntNullableFilter<"ContestAttempt"> | number | null
    timeTaken?: IntNullableFilter<"ContestAttempt"> | number | null
    ContestAnswer?: ContestAnswerListRelationFilter
    contest?: XOR<ContestRelationFilter, ContestWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ContestAttemptOrderByWithRelationInput = {
    id?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    timeTaken?: SortOrderInput | SortOrder
    ContestAnswer?: ContestAnswerOrderByRelationAggregateInput
    contest?: ContestOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ContestAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContestAttemptWhereInput | ContestAttemptWhereInput[]
    OR?: ContestAttemptWhereInput[]
    NOT?: ContestAttemptWhereInput | ContestAttemptWhereInput[]
    contestId?: IntFilter<"ContestAttempt"> | number
    userId?: IntFilter<"ContestAttempt"> | number
    startedAt?: DateTimeFilter<"ContestAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"ContestAttempt"> | Date | string | null
    score?: IntNullableFilter<"ContestAttempt"> | number | null
    timeTaken?: IntNullableFilter<"ContestAttempt"> | number | null
    ContestAnswer?: ContestAnswerListRelationFilter
    contest?: XOR<ContestRelationFilter, ContestWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ContestAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    timeTaken?: SortOrderInput | SortOrder
    _count?: ContestAttemptCountOrderByAggregateInput
    _avg?: ContestAttemptAvgOrderByAggregateInput
    _max?: ContestAttemptMaxOrderByAggregateInput
    _min?: ContestAttemptMinOrderByAggregateInput
    _sum?: ContestAttemptSumOrderByAggregateInput
  }

  export type ContestAttemptScalarWhereWithAggregatesInput = {
    AND?: ContestAttemptScalarWhereWithAggregatesInput | ContestAttemptScalarWhereWithAggregatesInput[]
    OR?: ContestAttemptScalarWhereWithAggregatesInput[]
    NOT?: ContestAttemptScalarWhereWithAggregatesInput | ContestAttemptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContestAttempt"> | number
    contestId?: IntWithAggregatesFilter<"ContestAttempt"> | number
    userId?: IntWithAggregatesFilter<"ContestAttempt"> | number
    startedAt?: DateTimeWithAggregatesFilter<"ContestAttempt"> | Date | string
    submittedAt?: DateTimeNullableWithAggregatesFilter<"ContestAttempt"> | Date | string | null
    score?: IntNullableWithAggregatesFilter<"ContestAttempt"> | number | null
    timeTaken?: IntNullableWithAggregatesFilter<"ContestAttempt"> | number | null
  }

  export type ContestAnswerWhereInput = {
    AND?: ContestAnswerWhereInput | ContestAnswerWhereInput[]
    OR?: ContestAnswerWhereInput[]
    NOT?: ContestAnswerWhereInput | ContestAnswerWhereInput[]
    id?: IntFilter<"ContestAnswer"> | number
    attemptId?: IntFilter<"ContestAnswer"> | number
    questionId?: IntFilter<"ContestAnswer"> | number
    selectedOption?: StringFilter<"ContestAnswer"> | string
    isCorrect?: BoolFilter<"ContestAnswer"> | boolean
    attempt?: XOR<ContestAttemptRelationFilter, ContestAttemptWhereInput>
    question?: XOR<ContestQuestionRelationFilter, ContestQuestionWhereInput>
  }

  export type ContestAnswerOrderByWithRelationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    selectedOption?: SortOrder
    isCorrect?: SortOrder
    attempt?: ContestAttemptOrderByWithRelationInput
    question?: ContestQuestionOrderByWithRelationInput
  }

  export type ContestAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContestAnswerWhereInput | ContestAnswerWhereInput[]
    OR?: ContestAnswerWhereInput[]
    NOT?: ContestAnswerWhereInput | ContestAnswerWhereInput[]
    attemptId?: IntFilter<"ContestAnswer"> | number
    questionId?: IntFilter<"ContestAnswer"> | number
    selectedOption?: StringFilter<"ContestAnswer"> | string
    isCorrect?: BoolFilter<"ContestAnswer"> | boolean
    attempt?: XOR<ContestAttemptRelationFilter, ContestAttemptWhereInput>
    question?: XOR<ContestQuestionRelationFilter, ContestQuestionWhereInput>
  }, "id">

  export type ContestAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    selectedOption?: SortOrder
    isCorrect?: SortOrder
    _count?: ContestAnswerCountOrderByAggregateInput
    _avg?: ContestAnswerAvgOrderByAggregateInput
    _max?: ContestAnswerMaxOrderByAggregateInput
    _min?: ContestAnswerMinOrderByAggregateInput
    _sum?: ContestAnswerSumOrderByAggregateInput
  }

  export type ContestAnswerScalarWhereWithAggregatesInput = {
    AND?: ContestAnswerScalarWhereWithAggregatesInput | ContestAnswerScalarWhereWithAggregatesInput[]
    OR?: ContestAnswerScalarWhereWithAggregatesInput[]
    NOT?: ContestAnswerScalarWhereWithAggregatesInput | ContestAnswerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContestAnswer"> | number
    attemptId?: IntWithAggregatesFilter<"ContestAnswer"> | number
    questionId?: IntWithAggregatesFilter<"ContestAnswer"> | number
    selectedOption?: StringWithAggregatesFilter<"ContestAnswer"> | string
    isCorrect?: BoolWithAggregatesFilter<"ContestAnswer"> | boolean
  }

  export type ChallengeWhereInput = {
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    id?: IntFilter<"Challenge"> | number
    title?: StringFilter<"Challenge"> | string
    type?: EnumChallengeTypeFilter<"Challenge"> | $Enums.ChallengeType
    category?: StringFilter<"Challenge"> | string
    difficulty?: StringFilter<"Challenge"> | string
    points?: IntFilter<"Challenge"> | number
    startDate?: DateTimeFilter<"Challenge"> | Date | string
    endDate?: DateTimeFilter<"Challenge"> | Date | string
    isActive?: BoolFilter<"Challenge"> | boolean
    ChallengeAttempt?: ChallengeAttemptListRelationFilter
  }

  export type ChallengeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    points?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    ChallengeAttempt?: ChallengeAttemptOrderByRelationAggregateInput
  }

  export type ChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    title?: StringFilter<"Challenge"> | string
    type?: EnumChallengeTypeFilter<"Challenge"> | $Enums.ChallengeType
    category?: StringFilter<"Challenge"> | string
    difficulty?: StringFilter<"Challenge"> | string
    points?: IntFilter<"Challenge"> | number
    startDate?: DateTimeFilter<"Challenge"> | Date | string
    endDate?: DateTimeFilter<"Challenge"> | Date | string
    isActive?: BoolFilter<"Challenge"> | boolean
    ChallengeAttempt?: ChallengeAttemptListRelationFilter
  }, "id">

  export type ChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    points?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    _count?: ChallengeCountOrderByAggregateInput
    _avg?: ChallengeAvgOrderByAggregateInput
    _max?: ChallengeMaxOrderByAggregateInput
    _min?: ChallengeMinOrderByAggregateInput
    _sum?: ChallengeSumOrderByAggregateInput
  }

  export type ChallengeScalarWhereWithAggregatesInput = {
    AND?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    OR?: ChallengeScalarWhereWithAggregatesInput[]
    NOT?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Challenge"> | number
    title?: StringWithAggregatesFilter<"Challenge"> | string
    type?: EnumChallengeTypeWithAggregatesFilter<"Challenge"> | $Enums.ChallengeType
    category?: StringWithAggregatesFilter<"Challenge"> | string
    difficulty?: StringWithAggregatesFilter<"Challenge"> | string
    points?: IntWithAggregatesFilter<"Challenge"> | number
    startDate?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Challenge"> | boolean
  }

  export type ChallengeAttemptWhereInput = {
    AND?: ChallengeAttemptWhereInput | ChallengeAttemptWhereInput[]
    OR?: ChallengeAttemptWhereInput[]
    NOT?: ChallengeAttemptWhereInput | ChallengeAttemptWhereInput[]
    id?: IntFilter<"ChallengeAttempt"> | number
    challengeId?: IntFilter<"ChallengeAttempt"> | number
    userId?: IntFilter<"ChallengeAttempt"> | number
    completedAt?: DateTimeNullableFilter<"ChallengeAttempt"> | Date | string | null
    earnedPoints?: IntFilter<"ChallengeAttempt"> | number
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChallengeAttemptOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    userId?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    earnedPoints?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ChallengeAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChallengeAttemptWhereInput | ChallengeAttemptWhereInput[]
    OR?: ChallengeAttemptWhereInput[]
    NOT?: ChallengeAttemptWhereInput | ChallengeAttemptWhereInput[]
    challengeId?: IntFilter<"ChallengeAttempt"> | number
    userId?: IntFilter<"ChallengeAttempt"> | number
    completedAt?: DateTimeNullableFilter<"ChallengeAttempt"> | Date | string | null
    earnedPoints?: IntFilter<"ChallengeAttempt"> | number
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ChallengeAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    userId?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    earnedPoints?: SortOrder
    _count?: ChallengeAttemptCountOrderByAggregateInput
    _avg?: ChallengeAttemptAvgOrderByAggregateInput
    _max?: ChallengeAttemptMaxOrderByAggregateInput
    _min?: ChallengeAttemptMinOrderByAggregateInput
    _sum?: ChallengeAttemptSumOrderByAggregateInput
  }

  export type ChallengeAttemptScalarWhereWithAggregatesInput = {
    AND?: ChallengeAttemptScalarWhereWithAggregatesInput | ChallengeAttemptScalarWhereWithAggregatesInput[]
    OR?: ChallengeAttemptScalarWhereWithAggregatesInput[]
    NOT?: ChallengeAttemptScalarWhereWithAggregatesInput | ChallengeAttemptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChallengeAttempt"> | number
    challengeId?: IntWithAggregatesFilter<"ChallengeAttempt"> | number
    userId?: IntWithAggregatesFilter<"ChallengeAttempt"> | number
    completedAt?: DateTimeNullableWithAggregatesFilter<"ChallengeAttempt"> | Date | string | null
    earnedPoints?: IntWithAggregatesFilter<"ChallengeAttempt"> | number
  }

  export type CounselorWhereInput = {
    AND?: CounselorWhereInput | CounselorWhereInput[]
    OR?: CounselorWhereInput[]
    NOT?: CounselorWhereInput | CounselorWhereInput[]
    id?: StringFilter<"Counselor"> | string
    name?: StringFilter<"Counselor"> | string
    email?: StringFilter<"Counselor"> | string
    password?: StringFilter<"Counselor"> | string
    bio?: StringNullableFilter<"Counselor"> | string | null
    profileImage?: StringNullableFilter<"Counselor"> | string | null
    specialization?: StringNullableFilter<"Counselor"> | string | null
    experience?: IntNullableFilter<"Counselor"> | number | null
    employmentType?: EnumEmploymentTypeFilter<"Counselor"> | $Enums.EmploymentType
    isActive?: BoolFilter<"Counselor"> | boolean
    rating?: FloatFilter<"Counselor"> | number
    totalMeetings?: IntFilter<"Counselor"> | number
    totalRevenue?: FloatFilter<"Counselor"> | number
    createdByAdminId?: StringFilter<"Counselor"> | string
    createdAt?: DateTimeFilter<"Counselor"> | Date | string
    updatedAt?: DateTimeFilter<"Counselor"> | Date | string
    consultationRequests?: ConsultationRequestListRelationFilter
    meetings?: MeetingListRelationFilter
  }

  export type CounselorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    bio?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    specialization?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    employmentType?: SortOrder
    isActive?: SortOrder
    rating?: SortOrder
    totalMeetings?: SortOrder
    totalRevenue?: SortOrder
    createdByAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consultationRequests?: ConsultationRequestOrderByRelationAggregateInput
    meetings?: MeetingOrderByRelationAggregateInput
  }

  export type CounselorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CounselorWhereInput | CounselorWhereInput[]
    OR?: CounselorWhereInput[]
    NOT?: CounselorWhereInput | CounselorWhereInput[]
    name?: StringFilter<"Counselor"> | string
    password?: StringFilter<"Counselor"> | string
    bio?: StringNullableFilter<"Counselor"> | string | null
    profileImage?: StringNullableFilter<"Counselor"> | string | null
    specialization?: StringNullableFilter<"Counselor"> | string | null
    experience?: IntNullableFilter<"Counselor"> | number | null
    employmentType?: EnumEmploymentTypeFilter<"Counselor"> | $Enums.EmploymentType
    isActive?: BoolFilter<"Counselor"> | boolean
    rating?: FloatFilter<"Counselor"> | number
    totalMeetings?: IntFilter<"Counselor"> | number
    totalRevenue?: FloatFilter<"Counselor"> | number
    createdByAdminId?: StringFilter<"Counselor"> | string
    createdAt?: DateTimeFilter<"Counselor"> | Date | string
    updatedAt?: DateTimeFilter<"Counselor"> | Date | string
    consultationRequests?: ConsultationRequestListRelationFilter
    meetings?: MeetingListRelationFilter
  }, "id" | "email">

  export type CounselorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    bio?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    specialization?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    employmentType?: SortOrder
    isActive?: SortOrder
    rating?: SortOrder
    totalMeetings?: SortOrder
    totalRevenue?: SortOrder
    createdByAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CounselorCountOrderByAggregateInput
    _avg?: CounselorAvgOrderByAggregateInput
    _max?: CounselorMaxOrderByAggregateInput
    _min?: CounselorMinOrderByAggregateInput
    _sum?: CounselorSumOrderByAggregateInput
  }

  export type CounselorScalarWhereWithAggregatesInput = {
    AND?: CounselorScalarWhereWithAggregatesInput | CounselorScalarWhereWithAggregatesInput[]
    OR?: CounselorScalarWhereWithAggregatesInput[]
    NOT?: CounselorScalarWhereWithAggregatesInput | CounselorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Counselor"> | string
    name?: StringWithAggregatesFilter<"Counselor"> | string
    email?: StringWithAggregatesFilter<"Counselor"> | string
    password?: StringWithAggregatesFilter<"Counselor"> | string
    bio?: StringNullableWithAggregatesFilter<"Counselor"> | string | null
    profileImage?: StringNullableWithAggregatesFilter<"Counselor"> | string | null
    specialization?: StringNullableWithAggregatesFilter<"Counselor"> | string | null
    experience?: IntNullableWithAggregatesFilter<"Counselor"> | number | null
    employmentType?: EnumEmploymentTypeWithAggregatesFilter<"Counselor"> | $Enums.EmploymentType
    isActive?: BoolWithAggregatesFilter<"Counselor"> | boolean
    rating?: FloatWithAggregatesFilter<"Counselor"> | number
    totalMeetings?: IntWithAggregatesFilter<"Counselor"> | number
    totalRevenue?: FloatWithAggregatesFilter<"Counselor"> | number
    createdByAdminId?: StringWithAggregatesFilter<"Counselor"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Counselor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Counselor"> | Date | string
  }

  export type ConsultationRequestWhereInput = {
    AND?: ConsultationRequestWhereInput | ConsultationRequestWhereInput[]
    OR?: ConsultationRequestWhereInput[]
    NOT?: ConsultationRequestWhereInput | ConsultationRequestWhereInput[]
    id?: IntFilter<"ConsultationRequest"> | number
    userId?: IntFilter<"ConsultationRequest"> | number
    counselorId?: StringFilter<"ConsultationRequest"> | string
    requestType?: EnumConsultationTypeFilter<"ConsultationRequest"> | $Enums.ConsultationType
    scheduledAt?: DateTimeNullableFilter<"ConsultationRequest"> | Date | string | null
    status?: EnumConsultationStatusFilter<"ConsultationRequest"> | $Enums.ConsultationStatus
    message?: StringNullableFilter<"ConsultationRequest"> | string | null
    respondedAt?: DateTimeNullableFilter<"ConsultationRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"ConsultationRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    counselor?: XOR<CounselorRelationFilter, CounselorWhereInput>
    meeting?: XOR<MeetingNullableRelationFilter, MeetingWhereInput> | null
  }

  export type ConsultationRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    counselorId?: SortOrder
    requestType?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    counselor?: CounselorOrderByWithRelationInput
    meeting?: MeetingOrderByWithRelationInput
  }

  export type ConsultationRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConsultationRequestWhereInput | ConsultationRequestWhereInput[]
    OR?: ConsultationRequestWhereInput[]
    NOT?: ConsultationRequestWhereInput | ConsultationRequestWhereInput[]
    userId?: IntFilter<"ConsultationRequest"> | number
    counselorId?: StringFilter<"ConsultationRequest"> | string
    requestType?: EnumConsultationTypeFilter<"ConsultationRequest"> | $Enums.ConsultationType
    scheduledAt?: DateTimeNullableFilter<"ConsultationRequest"> | Date | string | null
    status?: EnumConsultationStatusFilter<"ConsultationRequest"> | $Enums.ConsultationStatus
    message?: StringNullableFilter<"ConsultationRequest"> | string | null
    respondedAt?: DateTimeNullableFilter<"ConsultationRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"ConsultationRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    counselor?: XOR<CounselorRelationFilter, CounselorWhereInput>
    meeting?: XOR<MeetingNullableRelationFilter, MeetingWhereInput> | null
  }, "id">

  export type ConsultationRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    counselorId?: SortOrder
    requestType?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ConsultationRequestCountOrderByAggregateInput
    _avg?: ConsultationRequestAvgOrderByAggregateInput
    _max?: ConsultationRequestMaxOrderByAggregateInput
    _min?: ConsultationRequestMinOrderByAggregateInput
    _sum?: ConsultationRequestSumOrderByAggregateInput
  }

  export type ConsultationRequestScalarWhereWithAggregatesInput = {
    AND?: ConsultationRequestScalarWhereWithAggregatesInput | ConsultationRequestScalarWhereWithAggregatesInput[]
    OR?: ConsultationRequestScalarWhereWithAggregatesInput[]
    NOT?: ConsultationRequestScalarWhereWithAggregatesInput | ConsultationRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ConsultationRequest"> | number
    userId?: IntWithAggregatesFilter<"ConsultationRequest"> | number
    counselorId?: StringWithAggregatesFilter<"ConsultationRequest"> | string
    requestType?: EnumConsultationTypeWithAggregatesFilter<"ConsultationRequest"> | $Enums.ConsultationType
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"ConsultationRequest"> | Date | string | null
    status?: EnumConsultationStatusWithAggregatesFilter<"ConsultationRequest"> | $Enums.ConsultationStatus
    message?: StringNullableWithAggregatesFilter<"ConsultationRequest"> | string | null
    respondedAt?: DateTimeNullableWithAggregatesFilter<"ConsultationRequest"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConsultationRequest"> | Date | string
  }

  export type MeetingWhereInput = {
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    id?: StringFilter<"Meeting"> | string
    consultationRequestId?: IntFilter<"Meeting"> | number
    counselorId?: StringFilter<"Meeting"> | string
    userId?: IntFilter<"Meeting"> | number
    meetingProvider?: EnumMeetingProviderFilter<"Meeting"> | $Enums.MeetingProvider
    meetingRoomId?: StringFilter<"Meeting"> | string
    startTime?: DateTimeNullableFilter<"Meeting"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Meeting"> | Date | string | null
    duration?: IntNullableFilter<"Meeting"> | number | null
    status?: EnumMeetingStatusFilter<"Meeting"> | $Enums.MeetingStatus
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    consultationRequest?: XOR<ConsultationRequestRelationFilter, ConsultationRequestWhereInput>
    counselor?: XOR<CounselorRelationFilter, CounselorWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MeetingOrderByWithRelationInput = {
    id?: SortOrder
    consultationRequestId?: SortOrder
    counselorId?: SortOrder
    userId?: SortOrder
    meetingProvider?: SortOrder
    meetingRoomId?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    consultationRequest?: ConsultationRequestOrderByWithRelationInput
    counselor?: CounselorOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MeetingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    consultationRequestId?: number
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    counselorId?: StringFilter<"Meeting"> | string
    userId?: IntFilter<"Meeting"> | number
    meetingProvider?: EnumMeetingProviderFilter<"Meeting"> | $Enums.MeetingProvider
    meetingRoomId?: StringFilter<"Meeting"> | string
    startTime?: DateTimeNullableFilter<"Meeting"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Meeting"> | Date | string | null
    duration?: IntNullableFilter<"Meeting"> | number | null
    status?: EnumMeetingStatusFilter<"Meeting"> | $Enums.MeetingStatus
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    consultationRequest?: XOR<ConsultationRequestRelationFilter, ConsultationRequestWhereInput>
    counselor?: XOR<CounselorRelationFilter, CounselorWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "consultationRequestId">

  export type MeetingOrderByWithAggregationInput = {
    id?: SortOrder
    consultationRequestId?: SortOrder
    counselorId?: SortOrder
    userId?: SortOrder
    meetingProvider?: SortOrder
    meetingRoomId?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: MeetingCountOrderByAggregateInput
    _avg?: MeetingAvgOrderByAggregateInput
    _max?: MeetingMaxOrderByAggregateInput
    _min?: MeetingMinOrderByAggregateInput
    _sum?: MeetingSumOrderByAggregateInput
  }

  export type MeetingScalarWhereWithAggregatesInput = {
    AND?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    OR?: MeetingScalarWhereWithAggregatesInput[]
    NOT?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Meeting"> | string
    consultationRequestId?: IntWithAggregatesFilter<"Meeting"> | number
    counselorId?: StringWithAggregatesFilter<"Meeting"> | string
    userId?: IntWithAggregatesFilter<"Meeting"> | number
    meetingProvider?: EnumMeetingProviderWithAggregatesFilter<"Meeting"> | $Enums.MeetingProvider
    meetingRoomId?: StringWithAggregatesFilter<"Meeting"> | string
    startTime?: DateTimeNullableWithAggregatesFilter<"Meeting"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"Meeting"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"Meeting"> | number | null
    status?: EnumMeetingStatusWithAggregatesFilter<"Meeting"> | $Enums.MeetingStatus
    createdAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: IntFilter<"Resource"> | number
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    category?: EnumResourceCategoryFilter<"Resource"> | $Enums.ResourceCategory
    type?: StringFilter<"Resource"> | string
    url?: StringFilter<"Resource"> | string
    size?: StringNullableFilter<"Resource"> | string | null
    uploadedBy?: StringNullableFilter<"Resource"> | string | null
    downloads?: IntFilter<"Resource"> | number
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrderInput | SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    downloads?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    category?: EnumResourceCategoryFilter<"Resource"> | $Enums.ResourceCategory
    type?: StringFilter<"Resource"> | string
    url?: StringFilter<"Resource"> | string
    size?: StringNullableFilter<"Resource"> | string | null
    uploadedBy?: StringNullableFilter<"Resource"> | string | null
    downloads?: IntFilter<"Resource"> | number
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
  }, "id">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrderInput | SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    downloads?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _avg?: ResourceAvgOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
    _sum?: ResourceSumOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Resource"> | number
    title?: StringWithAggregatesFilter<"Resource"> | string
    description?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    category?: EnumResourceCategoryWithAggregatesFilter<"Resource"> | $Enums.ResourceCategory
    type?: StringWithAggregatesFilter<"Resource"> | string
    url?: StringWithAggregatesFilter<"Resource"> | string
    size?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    uploadedBy?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    downloads?: IntWithAggregatesFilter<"Resource"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
  }

  export type UserCreateInput = {
    firstName?: string | null
    lastName?: string | null
    phoneNo?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    state?: string | null
    country?: string | null
    profileImage?: string | null
    currenrStudyLevel?: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userRoleMappings?: UserRoleMappingCreateNestedManyWithoutUserInput
    ContestAttempt?: ContestAttemptCreateNestedManyWithoutUserInput
    ChallengeAttempt?: ChallengeAttemptCreateNestedManyWithoutUserInput
    consultationRequests?: ConsultationRequestCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    enrolledCourses?: CourseUserMapperCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phoneNo?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    state?: string | null
    country?: string | null
    profileImage?: string | null
    currenrStudyLevel?: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userRoleMappings?: UserRoleMappingUncheckedCreateNestedManyWithoutUserInput
    ContestAttempt?: ContestAttemptUncheckedCreateNestedManyWithoutUserInput
    ChallengeAttempt?: ChallengeAttemptUncheckedCreateNestedManyWithoutUserInput
    consultationRequests?: ConsultationRequestUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    enrolledCourses?: CourseUserMapperUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoleMappings?: UserRoleMappingUpdateManyWithoutUserNestedInput
    ContestAttempt?: ContestAttemptUpdateManyWithoutUserNestedInput
    ChallengeAttempt?: ChallengeAttemptUpdateManyWithoutUserNestedInput
    consultationRequests?: ConsultationRequestUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    enrolledCourses?: CourseUserMapperUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoleMappings?: UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput
    ContestAttempt?: ContestAttemptUncheckedUpdateManyWithoutUserNestedInput
    ChallengeAttempt?: ChallengeAttemptUncheckedUpdateManyWithoutUserNestedInput
    consultationRequests?: ConsultationRequestUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    enrolledCourses?: CourseUserMapperUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phoneNo?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    state?: string | null
    country?: string | null
    profileImage?: string | null
    currenrStudyLevel?: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolesCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userRoleMappings?: UserRoleMappingCreateNestedManyWithoutRoleInput
  }

  export type rolesUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userRoleMappings?: UserRoleMappingUncheckedCreateNestedManyWithoutRoleInput
  }

  export type rolesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoleMappings?: UserRoleMappingUpdateManyWithoutRoleNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoleMappings?: UserRoleMappingUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type rolesCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type rolesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRoleMappingCreateInput = {
    assignedAt?: Date | string
    assignedBy?: number | null
    user: UserCreateNestedOneWithoutUserRoleMappingsInput
    role: rolesCreateNestedOneWithoutUserRoleMappingsInput
  }

  export type UserRoleMappingUncheckedCreateInput = {
    id?: number
    userId: number
    roleId: number
    assignedAt?: Date | string
    assignedBy?: number | null
  }

  export type UserRoleMappingUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutUserRoleMappingsNestedInput
    role?: rolesUpdateOneRequiredWithoutUserRoleMappingsNestedInput
  }

  export type UserRoleMappingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRoleMappingCreateManyInput = {
    id?: number
    userId: number
    roleId: number
    assignedAt?: Date | string
    assignedBy?: number | null
  }

  export type UserRoleMappingUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRoleMappingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CoursesCreateInput = {
    title: string
    description?: string | null
    price: number
    thumbnailUrl?: string | null
    instructor?: string | null
    duration?: string | null
    level: $Enums.CourseLevel
    category?: string | null
    language?: string | null
    isPublished?: boolean
    createdBy?: number | null
    createdAt?: Date | string | null
    lessons?: LessonsCreateNestedManyWithoutCourseInput
    enrolledUsers?: CourseUserMapperCreateNestedManyWithoutCourseInput
  }

  export type CoursesUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    price: number
    thumbnailUrl?: string | null
    instructor?: string | null
    duration?: string | null
    level: $Enums.CourseLevel
    category?: string | null
    language?: string | null
    isPublished?: boolean
    createdBy?: number | null
    createdAt?: Date | string | null
    lessons?: LessonsUncheckedCreateNestedManyWithoutCourseInput
    enrolledUsers?: CourseUserMapperUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CoursesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    category?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessons?: LessonsUpdateManyWithoutCourseNestedInput
    enrolledUsers?: CourseUserMapperUpdateManyWithoutCourseNestedInput
  }

  export type CoursesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    category?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessons?: LessonsUncheckedUpdateManyWithoutCourseNestedInput
    enrolledUsers?: CourseUserMapperUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CoursesCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    price: number
    thumbnailUrl?: string | null
    instructor?: string | null
    duration?: string | null
    level: $Enums.CourseLevel
    category?: string | null
    language?: string | null
    isPublished?: boolean
    createdBy?: number | null
    createdAt?: Date | string | null
  }

  export type CoursesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    category?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CoursesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    category?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonsCreateInput = {
    title: string
    description?: string | null
    videoType: string
    videoId: string
    duration?: number | null
    order: number
    isFreePreview: boolean
    course: CoursesCreateNestedOneWithoutLessonsInput
  }

  export type LessonsUncheckedCreateInput = {
    id?: number
    courseId: number
    title: string
    description?: string | null
    videoType: string
    videoId: string
    duration?: number | null
    order: number
    isFreePreview: boolean
  }

  export type LessonsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoType?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isFreePreview?: BoolFieldUpdateOperationsInput | boolean
    course?: CoursesUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoType?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isFreePreview?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LessonsCreateManyInput = {
    id?: number
    courseId: number
    title: string
    description?: string | null
    videoType: string
    videoId: string
    duration?: number | null
    order: number
    isFreePreview: boolean
  }

  export type LessonsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoType?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isFreePreview?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LessonsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoType?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isFreePreview?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseUserMapperCreateInput = {
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    isCompleted?: boolean
    user: UserCreateNestedOneWithoutEnrolledCoursesInput
    course: CoursesCreateNestedOneWithoutEnrolledUsersInput
  }

  export type CourseUserMapperUncheckedCreateInput = {
    id?: number
    userId: number
    courseId: number
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    isCompleted?: boolean
  }

  export type CourseUserMapperUpdateInput = {
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutEnrolledCoursesNestedInput
    course?: CoursesUpdateOneRequiredWithoutEnrolledUsersNestedInput
  }

  export type CourseUserMapperUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseUserMapperCreateManyInput = {
    id?: number
    userId: number
    courseId: number
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    isCompleted?: boolean
  }

  export type CourseUserMapperUpdateManyMutationInput = {
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseUserMapperUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContestCreateInput = {
    title: string
    description?: string | null
    category: string
    startTime: Date | string
    endTime: Date | string
    isPublished?: boolean
    durationMinutes?: number | null
    totalMarks?: number | null
    isActive?: boolean
    createdByAdminId?: number | null
    createdAt?: Date | string
    ContestQuestion?: ContestQuestionCreateNestedManyWithoutContestInput
    ContestAttempt?: ContestAttemptCreateNestedManyWithoutContestInput
  }

  export type ContestUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    category: string
    startTime: Date | string
    endTime: Date | string
    isPublished?: boolean
    durationMinutes?: number | null
    totalMarks?: number | null
    isActive?: boolean
    createdByAdminId?: number | null
    createdAt?: Date | string
    ContestQuestion?: ContestQuestionUncheckedCreateNestedManyWithoutContestInput
    ContestAttempt?: ContestAttemptUncheckedCreateNestedManyWithoutContestInput
  }

  export type ContestUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdByAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ContestQuestion?: ContestQuestionUpdateManyWithoutContestNestedInput
    ContestAttempt?: ContestAttemptUpdateManyWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdByAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ContestQuestion?: ContestQuestionUncheckedUpdateManyWithoutContestNestedInput
    ContestAttempt?: ContestAttemptUncheckedUpdateManyWithoutContestNestedInput
  }

  export type ContestCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    category: string
    startTime: Date | string
    endTime: Date | string
    isPublished?: boolean
    durationMinutes?: number | null
    totalMarks?: number | null
    isActive?: boolean
    createdByAdminId?: number | null
    createdAt?: Date | string
  }

  export type ContestUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdByAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdByAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestQuestionCreateInput = {
    questionText: string
    optionA: string
    optionB: string
    optionC?: string | null
    optionD?: string | null
    correctOption: string
    marks: number
    contestanswer?: ContestAnswerCreateNestedManyWithoutQuestionInput
    contest: ContestCreateNestedOneWithoutContestQuestionInput
  }

  export type ContestQuestionUncheckedCreateInput = {
    id?: number
    contestId: number
    questionText: string
    optionA: string
    optionB: string
    optionC?: string | null
    optionD?: string | null
    correctOption: string
    marks: number
    contestanswer?: ContestAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type ContestQuestionUpdateInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: NullableStringFieldUpdateOperationsInput | string | null
    optionD?: NullableStringFieldUpdateOperationsInput | string | null
    correctOption?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    contestanswer?: ContestAnswerUpdateManyWithoutQuestionNestedInput
    contest?: ContestUpdateOneRequiredWithoutContestQuestionNestedInput
  }

  export type ContestQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contestId?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: NullableStringFieldUpdateOperationsInput | string | null
    optionD?: NullableStringFieldUpdateOperationsInput | string | null
    correctOption?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    contestanswer?: ContestAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type ContestQuestionCreateManyInput = {
    id?: number
    contestId: number
    questionText: string
    optionA: string
    optionB: string
    optionC?: string | null
    optionD?: string | null
    correctOption: string
    marks: number
  }

  export type ContestQuestionUpdateManyMutationInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: NullableStringFieldUpdateOperationsInput | string | null
    optionD?: NullableStringFieldUpdateOperationsInput | string | null
    correctOption?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
  }

  export type ContestQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contestId?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: NullableStringFieldUpdateOperationsInput | string | null
    optionD?: NullableStringFieldUpdateOperationsInput | string | null
    correctOption?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
  }

  export type ContestAttemptCreateInput = {
    startedAt: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    timeTaken?: number | null
    ContestAnswer?: ContestAnswerCreateNestedManyWithoutAttemptInput
    contest: ContestCreateNestedOneWithoutContestAttemptInput
    user: UserCreateNestedOneWithoutContestAttemptInput
  }

  export type ContestAttemptUncheckedCreateInput = {
    id?: number
    contestId: number
    userId: number
    startedAt: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    timeTaken?: number | null
    ContestAnswer?: ContestAnswerUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type ContestAttemptUpdateInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    ContestAnswer?: ContestAnswerUpdateManyWithoutAttemptNestedInput
    contest?: ContestUpdateOneRequiredWithoutContestAttemptNestedInput
    user?: UserUpdateOneRequiredWithoutContestAttemptNestedInput
  }

  export type ContestAttemptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contestId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    ContestAnswer?: ContestAnswerUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type ContestAttemptCreateManyInput = {
    id?: number
    contestId: number
    userId: number
    startedAt: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    timeTaken?: number | null
  }

  export type ContestAttemptUpdateManyMutationInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContestAttemptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contestId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContestAnswerCreateInput = {
    selectedOption: string
    isCorrect: boolean
    attempt: ContestAttemptCreateNestedOneWithoutContestAnswerInput
    question: ContestQuestionCreateNestedOneWithoutContestanswerInput
  }

  export type ContestAnswerUncheckedCreateInput = {
    id?: number
    attemptId: number
    questionId: number
    selectedOption: string
    isCorrect: boolean
  }

  export type ContestAnswerUpdateInput = {
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    attempt?: ContestAttemptUpdateOneRequiredWithoutContestAnswerNestedInput
    question?: ContestQuestionUpdateOneRequiredWithoutContestanswerNestedInput
  }

  export type ContestAnswerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContestAnswerCreateManyInput = {
    id?: number
    attemptId: number
    questionId: number
    selectedOption: string
    isCorrect: boolean
  }

  export type ContestAnswerUpdateManyMutationInput = {
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContestAnswerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChallengeCreateInput = {
    title: string
    type: $Enums.ChallengeType
    category: string
    difficulty: string
    points: number
    startDate: Date | string
    endDate: Date | string
    isActive: boolean
    ChallengeAttempt?: ChallengeAttemptCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateInput = {
    id?: number
    title: string
    type: $Enums.ChallengeType
    category: string
    difficulty: string
    points: number
    startDate: Date | string
    endDate: Date | string
    isActive: boolean
    ChallengeAttempt?: ChallengeAttemptUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ChallengeAttempt?: ChallengeAttemptUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ChallengeAttempt?: ChallengeAttemptUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateManyInput = {
    id?: number
    title: string
    type: $Enums.ChallengeType
    category: string
    difficulty: string
    points: number
    startDate: Date | string
    endDate: Date | string
    isActive: boolean
  }

  export type ChallengeUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChallengeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChallengeAttemptCreateInput = {
    completedAt?: Date | string | null
    earnedPoints: number
    challenge: ChallengeCreateNestedOneWithoutChallengeAttemptInput
    user: UserCreateNestedOneWithoutChallengeAttemptInput
  }

  export type ChallengeAttemptUncheckedCreateInput = {
    id?: number
    challengeId: number
    userId: number
    completedAt?: Date | string | null
    earnedPoints: number
  }

  export type ChallengeAttemptUpdateInput = {
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earnedPoints?: IntFieldUpdateOperationsInput | number
    challenge?: ChallengeUpdateOneRequiredWithoutChallengeAttemptNestedInput
    user?: UserUpdateOneRequiredWithoutChallengeAttemptNestedInput
  }

  export type ChallengeAttemptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    challengeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earnedPoints?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeAttemptCreateManyInput = {
    id?: number
    challengeId: number
    userId: number
    completedAt?: Date | string | null
    earnedPoints: number
  }

  export type ChallengeAttemptUpdateManyMutationInput = {
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earnedPoints?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeAttemptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    challengeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earnedPoints?: IntFieldUpdateOperationsInput | number
  }

  export type CounselorCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    bio?: string | null
    profileImage?: string | null
    specialization?: string | null
    experience?: number | null
    employmentType: $Enums.EmploymentType
    isActive?: boolean
    rating?: number
    totalMeetings?: number
    totalRevenue?: number
    createdByAdminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationRequests?: ConsultationRequestCreateNestedManyWithoutCounselorInput
    meetings?: MeetingCreateNestedManyWithoutCounselorInput
  }

  export type CounselorUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    bio?: string | null
    profileImage?: string | null
    specialization?: string | null
    experience?: number | null
    employmentType: $Enums.EmploymentType
    isActive?: boolean
    rating?: number
    totalMeetings?: number
    totalRevenue?: number
    createdByAdminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationRequests?: ConsultationRequestUncheckedCreateNestedManyWithoutCounselorInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutCounselorInput
  }

  export type CounselorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalMeetings?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationRequests?: ConsultationRequestUpdateManyWithoutCounselorNestedInput
    meetings?: MeetingUpdateManyWithoutCounselorNestedInput
  }

  export type CounselorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalMeetings?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationRequests?: ConsultationRequestUncheckedUpdateManyWithoutCounselorNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutCounselorNestedInput
  }

  export type CounselorCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    bio?: string | null
    profileImage?: string | null
    specialization?: string | null
    experience?: number | null
    employmentType: $Enums.EmploymentType
    isActive?: boolean
    rating?: number
    totalMeetings?: number
    totalRevenue?: number
    createdByAdminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CounselorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalMeetings?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CounselorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalMeetings?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationRequestCreateInput = {
    requestType: $Enums.ConsultationType
    scheduledAt?: Date | string | null
    status?: $Enums.ConsultationStatus
    message?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutConsultationRequestsInput
    counselor: CounselorCreateNestedOneWithoutConsultationRequestsInput
    meeting?: MeetingCreateNestedOneWithoutConsultationRequestInput
  }

  export type ConsultationRequestUncheckedCreateInput = {
    id?: number
    userId: number
    counselorId: string
    requestType: $Enums.ConsultationType
    scheduledAt?: Date | string | null
    status?: $Enums.ConsultationStatus
    message?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    meeting?: MeetingUncheckedCreateNestedOneWithoutConsultationRequestInput
  }

  export type ConsultationRequestUpdateInput = {
    requestType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumConsultationStatusFieldUpdateOperationsInput | $Enums.ConsultationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConsultationRequestsNestedInput
    counselor?: CounselorUpdateOneRequiredWithoutConsultationRequestsNestedInput
    meeting?: MeetingUpdateOneWithoutConsultationRequestNestedInput
  }

  export type ConsultationRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    counselorId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumConsultationStatusFieldUpdateOperationsInput | $Enums.ConsultationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: MeetingUncheckedUpdateOneWithoutConsultationRequestNestedInput
  }

  export type ConsultationRequestCreateManyInput = {
    id?: number
    userId: number
    counselorId: string
    requestType: $Enums.ConsultationType
    scheduledAt?: Date | string | null
    status?: $Enums.ConsultationStatus
    message?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ConsultationRequestUpdateManyMutationInput = {
    requestType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumConsultationStatusFieldUpdateOperationsInput | $Enums.ConsultationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    counselorId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumConsultationStatusFieldUpdateOperationsInput | $Enums.ConsultationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingCreateInput = {
    id?: string
    meetingProvider: $Enums.MeetingProvider
    meetingRoomId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    status?: $Enums.MeetingStatus
    createdAt?: Date | string
    consultationRequest: ConsultationRequestCreateNestedOneWithoutMeetingInput
    counselor: CounselorCreateNestedOneWithoutMeetingsInput
    user: UserCreateNestedOneWithoutMeetingsInput
  }

  export type MeetingUncheckedCreateInput = {
    id?: string
    consultationRequestId: number
    counselorId: string
    userId: number
    meetingProvider: $Enums.MeetingProvider
    meetingRoomId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    status?: $Enums.MeetingStatus
    createdAt?: Date | string
  }

  export type MeetingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingProvider?: EnumMeetingProviderFieldUpdateOperationsInput | $Enums.MeetingProvider
    meetingRoomId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationRequest?: ConsultationRequestUpdateOneRequiredWithoutMeetingNestedInput
    counselor?: CounselorUpdateOneRequiredWithoutMeetingsNestedInput
    user?: UserUpdateOneRequiredWithoutMeetingsNestedInput
  }

  export type MeetingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationRequestId?: IntFieldUpdateOperationsInput | number
    counselorId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    meetingProvider?: EnumMeetingProviderFieldUpdateOperationsInput | $Enums.MeetingProvider
    meetingRoomId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingCreateManyInput = {
    id?: string
    consultationRequestId: number
    counselorId: string
    userId: number
    meetingProvider: $Enums.MeetingProvider
    meetingRoomId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    status?: $Enums.MeetingStatus
    createdAt?: Date | string
  }

  export type MeetingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingProvider?: EnumMeetingProviderFieldUpdateOperationsInput | $Enums.MeetingProvider
    meetingRoomId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationRequestId?: IntFieldUpdateOperationsInput | number
    counselorId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    meetingProvider?: EnumMeetingProviderFieldUpdateOperationsInput | $Enums.MeetingProvider
    meetingRoomId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateInput = {
    title: string
    description?: string | null
    category: $Enums.ResourceCategory
    type: string
    url: string
    size?: string | null
    uploadedBy?: string | null
    downloads?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    category: $Enums.ResourceCategory
    type: string
    url: string
    size?: string | null
    uploadedBy?: string | null
    downloads?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumResourceCategoryFieldUpdateOperationsInput | $Enums.ResourceCategory
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    downloads?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumResourceCategoryFieldUpdateOperationsInput | $Enums.ResourceCategory
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    downloads?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    category: $Enums.ResourceCategory
    type: string
    url: string
    size?: string | null
    uploadedBy?: string | null
    downloads?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumResourceCategoryFieldUpdateOperationsInput | $Enums.ResourceCategory
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    downloads?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumResourceCategoryFieldUpdateOperationsInput | $Enums.ResourceCategory
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    downloads?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumcurrenrStudylevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.currenrStudylevel | EnumcurrenrStudylevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.currenrStudylevel[] | ListEnumcurrenrStudylevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.currenrStudylevel[] | ListEnumcurrenrStudylevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcurrenrStudylevelNullableFilter<$PrismaModel> | $Enums.currenrStudylevel | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRoleMappingListRelationFilter = {
    every?: UserRoleMappingWhereInput
    some?: UserRoleMappingWhereInput
    none?: UserRoleMappingWhereInput
  }

  export type ContestAttemptListRelationFilter = {
    every?: ContestAttemptWhereInput
    some?: ContestAttemptWhereInput
    none?: ContestAttemptWhereInput
  }

  export type ChallengeAttemptListRelationFilter = {
    every?: ChallengeAttemptWhereInput
    some?: ChallengeAttemptWhereInput
    none?: ChallengeAttemptWhereInput
  }

  export type ConsultationRequestListRelationFilter = {
    every?: ConsultationRequestWhereInput
    some?: ConsultationRequestWhereInput
    none?: ConsultationRequestWhereInput
  }

  export type MeetingListRelationFilter = {
    every?: MeetingWhereInput
    some?: MeetingWhereInput
    none?: MeetingWhereInput
  }

  export type CourseUserMapperListRelationFilter = {
    every?: CourseUserMapperWhereInput
    some?: CourseUserMapperWhereInput
    none?: CourseUserMapperWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserRoleMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConsultationRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeetingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseUserMapperOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNo?: SortOrder
    address?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    state?: SortOrder
    country?: SortOrder
    profileImage?: SortOrder
    currenrStudyLevel?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNo?: SortOrder
    address?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    state?: SortOrder
    country?: SortOrder
    profileImage?: SortOrder
    currenrStudyLevel?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNo?: SortOrder
    address?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    state?: SortOrder
    country?: SortOrder
    profileImage?: SortOrder
    currenrStudyLevel?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumcurrenrStudylevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.currenrStudylevel | EnumcurrenrStudylevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.currenrStudylevel[] | ListEnumcurrenrStudylevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.currenrStudylevel[] | ListEnumcurrenrStudylevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcurrenrStudylevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.currenrStudylevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumcurrenrStudylevelNullableFilter<$PrismaModel>
    _max?: NestedEnumcurrenrStudylevelNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RolesRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type UserRoleMappingUserIdRoleIdCompoundUniqueInput = {
    userId: number
    roleId: number
  }

  export type UserRoleMappingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleMappingAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleMappingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleMappingSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedBy?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumCourseLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelFilter<$PrismaModel> | $Enums.CourseLevel
  }

  export type LessonsListRelationFilter = {
    every?: LessonsWhereInput
    some?: LessonsWhereInput
    none?: LessonsWhereInput
  }

  export type LessonsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoursesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    thumbnailUrl?: SortOrder
    instructor?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    category?: SortOrder
    language?: SortOrder
    isPublished?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CoursesAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    createdBy?: SortOrder
  }

  export type CoursesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    thumbnailUrl?: SortOrder
    instructor?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    category?: SortOrder
    language?: SortOrder
    isPublished?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CoursesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    thumbnailUrl?: SortOrder
    instructor?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    category?: SortOrder
    language?: SortOrder
    isPublished?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CoursesSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    createdBy?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumCourseLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelWithAggregatesFilter<$PrismaModel> | $Enums.CourseLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseLevelFilter<$PrismaModel>
    _max?: NestedEnumCourseLevelFilter<$PrismaModel>
  }

  export type CoursesRelationFilter = {
    is?: CoursesWhereInput
    isNot?: CoursesWhereInput
  }

  export type LessonsCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoType?: SortOrder
    videoId?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    isFreePreview?: SortOrder
  }

  export type LessonsAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    duration?: SortOrder
    order?: SortOrder
  }

  export type LessonsMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoType?: SortOrder
    videoId?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    isFreePreview?: SortOrder
  }

  export type LessonsMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoType?: SortOrder
    videoId?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    isFreePreview?: SortOrder
  }

  export type LessonsSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    duration?: SortOrder
    order?: SortOrder
  }

  export type CourseUserMapperUserIdCourseIdCompoundUniqueInput = {
    userId: number
    courseId: number
  }

  export type CourseUserMapperCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
    isCompleted?: SortOrder
  }

  export type CourseUserMapperAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
  }

  export type CourseUserMapperMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
    isCompleted?: SortOrder
  }

  export type CourseUserMapperMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
    isCompleted?: SortOrder
  }

  export type CourseUserMapperSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
  }

  export type ContestQuestionListRelationFilter = {
    every?: ContestQuestionWhereInput
    some?: ContestQuestionWhereInput
    none?: ContestQuestionWhereInput
  }

  export type ContestQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isPublished?: SortOrder
    durationMinutes?: SortOrder
    totalMarks?: SortOrder
    isActive?: SortOrder
    createdByAdminId?: SortOrder
    createdAt?: SortOrder
  }

  export type ContestAvgOrderByAggregateInput = {
    id?: SortOrder
    durationMinutes?: SortOrder
    totalMarks?: SortOrder
    createdByAdminId?: SortOrder
  }

  export type ContestMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isPublished?: SortOrder
    durationMinutes?: SortOrder
    totalMarks?: SortOrder
    isActive?: SortOrder
    createdByAdminId?: SortOrder
    createdAt?: SortOrder
  }

  export type ContestMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isPublished?: SortOrder
    durationMinutes?: SortOrder
    totalMarks?: SortOrder
    isActive?: SortOrder
    createdByAdminId?: SortOrder
    createdAt?: SortOrder
  }

  export type ContestSumOrderByAggregateInput = {
    id?: SortOrder
    durationMinutes?: SortOrder
    totalMarks?: SortOrder
    createdByAdminId?: SortOrder
  }

  export type ContestAnswerListRelationFilter = {
    every?: ContestAnswerWhereInput
    some?: ContestAnswerWhereInput
    none?: ContestAnswerWhereInput
  }

  export type ContestRelationFilter = {
    is?: ContestWhereInput
    isNot?: ContestWhereInput
  }

  export type ContestAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    questionText?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    marks?: SortOrder
  }

  export type ContestQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    marks?: SortOrder
  }

  export type ContestQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    questionText?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    marks?: SortOrder
  }

  export type ContestQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    questionText?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    marks?: SortOrder
  }

  export type ContestQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    marks?: SortOrder
  }

  export type ContestAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrder
    timeTaken?: SortOrder
  }

  export type ContestAttemptAvgOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    timeTaken?: SortOrder
  }

  export type ContestAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrder
    timeTaken?: SortOrder
  }

  export type ContestAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrder
    timeTaken?: SortOrder
  }

  export type ContestAttemptSumOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    timeTaken?: SortOrder
  }

  export type ContestAttemptRelationFilter = {
    is?: ContestAttemptWhereInput
    isNot?: ContestAttemptWhereInput
  }

  export type ContestQuestionRelationFilter = {
    is?: ContestQuestionWhereInput
    isNot?: ContestQuestionWhereInput
  }

  export type ContestAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    selectedOption?: SortOrder
    isCorrect?: SortOrder
  }

  export type ContestAnswerAvgOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
  }

  export type ContestAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    selectedOption?: SortOrder
    isCorrect?: SortOrder
  }

  export type ContestAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    selectedOption?: SortOrder
    isCorrect?: SortOrder
  }

  export type ContestAnswerSumOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
  }

  export type EnumChallengeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeTypeFilter<$PrismaModel> | $Enums.ChallengeType
  }

  export type ChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    points?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
  }

  export type ChallengeAvgOrderByAggregateInput = {
    id?: SortOrder
    points?: SortOrder
  }

  export type ChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    points?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
  }

  export type ChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    points?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
  }

  export type ChallengeSumOrderByAggregateInput = {
    id?: SortOrder
    points?: SortOrder
  }

  export type EnumChallengeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeTypeFilter<$PrismaModel>
    _max?: NestedEnumChallengeTypeFilter<$PrismaModel>
  }

  export type ChallengeRelationFilter = {
    is?: ChallengeWhereInput
    isNot?: ChallengeWhereInput
  }

  export type ChallengeAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    userId?: SortOrder
    completedAt?: SortOrder
    earnedPoints?: SortOrder
  }

  export type ChallengeAttemptAvgOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    userId?: SortOrder
    earnedPoints?: SortOrder
  }

  export type ChallengeAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    userId?: SortOrder
    completedAt?: SortOrder
    earnedPoints?: SortOrder
  }

  export type ChallengeAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    userId?: SortOrder
    completedAt?: SortOrder
    earnedPoints?: SortOrder
  }

  export type ChallengeAttemptSumOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    userId?: SortOrder
    earnedPoints?: SortOrder
  }

  export type EnumEmploymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeFilter<$PrismaModel> | $Enums.EmploymentType
  }

  export type CounselorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    bio?: SortOrder
    profileImage?: SortOrder
    specialization?: SortOrder
    experience?: SortOrder
    employmentType?: SortOrder
    isActive?: SortOrder
    rating?: SortOrder
    totalMeetings?: SortOrder
    totalRevenue?: SortOrder
    createdByAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CounselorAvgOrderByAggregateInput = {
    experience?: SortOrder
    rating?: SortOrder
    totalMeetings?: SortOrder
    totalRevenue?: SortOrder
  }

  export type CounselorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    bio?: SortOrder
    profileImage?: SortOrder
    specialization?: SortOrder
    experience?: SortOrder
    employmentType?: SortOrder
    isActive?: SortOrder
    rating?: SortOrder
    totalMeetings?: SortOrder
    totalRevenue?: SortOrder
    createdByAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CounselorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    bio?: SortOrder
    profileImage?: SortOrder
    specialization?: SortOrder
    experience?: SortOrder
    employmentType?: SortOrder
    isActive?: SortOrder
    rating?: SortOrder
    totalMeetings?: SortOrder
    totalRevenue?: SortOrder
    createdByAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CounselorSumOrderByAggregateInput = {
    experience?: SortOrder
    rating?: SortOrder
    totalMeetings?: SortOrder
    totalRevenue?: SortOrder
  }

  export type EnumEmploymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmploymentTypeFilter<$PrismaModel>
    _max?: NestedEnumEmploymentTypeFilter<$PrismaModel>
  }

  export type EnumConsultationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsultationType | EnumConsultationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsultationTypeFilter<$PrismaModel> | $Enums.ConsultationType
  }

  export type EnumConsultationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsultationStatus | EnumConsultationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsultationStatus[] | ListEnumConsultationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsultationStatus[] | ListEnumConsultationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsultationStatusFilter<$PrismaModel> | $Enums.ConsultationStatus
  }

  export type CounselorRelationFilter = {
    is?: CounselorWhereInput
    isNot?: CounselorWhereInput
  }

  export type MeetingNullableRelationFilter = {
    is?: MeetingWhereInput | null
    isNot?: MeetingWhereInput | null
  }

  export type ConsultationRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    counselorId?: SortOrder
    requestType?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    message?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsultationRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ConsultationRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    counselorId?: SortOrder
    requestType?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    message?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsultationRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    counselorId?: SortOrder
    requestType?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    message?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsultationRequestSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumConsultationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsultationType | EnumConsultationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsultationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConsultationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsultationTypeFilter<$PrismaModel>
    _max?: NestedEnumConsultationTypeFilter<$PrismaModel>
  }

  export type EnumConsultationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsultationStatus | EnumConsultationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsultationStatus[] | ListEnumConsultationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsultationStatus[] | ListEnumConsultationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsultationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConsultationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsultationStatusFilter<$PrismaModel>
    _max?: NestedEnumConsultationStatusFilter<$PrismaModel>
  }

  export type EnumMeetingProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingProvider | EnumMeetingProviderFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingProvider[] | ListEnumMeetingProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingProvider[] | ListEnumMeetingProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingProviderFilter<$PrismaModel> | $Enums.MeetingProvider
  }

  export type EnumMeetingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingStatus | EnumMeetingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingStatusFilter<$PrismaModel> | $Enums.MeetingStatus
  }

  export type ConsultationRequestRelationFilter = {
    is?: ConsultationRequestWhereInput
    isNot?: ConsultationRequestWhereInput
  }

  export type MeetingCountOrderByAggregateInput = {
    id?: SortOrder
    consultationRequestId?: SortOrder
    counselorId?: SortOrder
    userId?: SortOrder
    meetingProvider?: SortOrder
    meetingRoomId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type MeetingAvgOrderByAggregateInput = {
    consultationRequestId?: SortOrder
    userId?: SortOrder
    duration?: SortOrder
  }

  export type MeetingMaxOrderByAggregateInput = {
    id?: SortOrder
    consultationRequestId?: SortOrder
    counselorId?: SortOrder
    userId?: SortOrder
    meetingProvider?: SortOrder
    meetingRoomId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type MeetingMinOrderByAggregateInput = {
    id?: SortOrder
    consultationRequestId?: SortOrder
    counselorId?: SortOrder
    userId?: SortOrder
    meetingProvider?: SortOrder
    meetingRoomId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type MeetingSumOrderByAggregateInput = {
    consultationRequestId?: SortOrder
    userId?: SortOrder
    duration?: SortOrder
  }

  export type EnumMeetingProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingProvider | EnumMeetingProviderFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingProvider[] | ListEnumMeetingProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingProvider[] | ListEnumMeetingProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingProviderWithAggregatesFilter<$PrismaModel> | $Enums.MeetingProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeetingProviderFilter<$PrismaModel>
    _max?: NestedEnumMeetingProviderFilter<$PrismaModel>
  }

  export type EnumMeetingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingStatus | EnumMeetingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingStatusWithAggregatesFilter<$PrismaModel> | $Enums.MeetingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeetingStatusFilter<$PrismaModel>
    _max?: NestedEnumMeetingStatusFilter<$PrismaModel>
  }

  export type EnumResourceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceCategory | EnumResourceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceCategory[] | ListEnumResourceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceCategory[] | ListEnumResourceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceCategoryFilter<$PrismaModel> | $Enums.ResourceCategory
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    uploadedBy?: SortOrder
    downloads?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceAvgOrderByAggregateInput = {
    id?: SortOrder
    downloads?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    uploadedBy?: SortOrder
    downloads?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    uploadedBy?: SortOrder
    downloads?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceSumOrderByAggregateInput = {
    id?: SortOrder
    downloads?: SortOrder
  }

  export type EnumResourceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceCategory | EnumResourceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceCategory[] | ListEnumResourceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceCategory[] | ListEnumResourceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ResourceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceCategoryFilter<$PrismaModel>
    _max?: NestedEnumResourceCategoryFilter<$PrismaModel>
  }

  export type UserRoleMappingCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleMappingCreateWithoutUserInput, UserRoleMappingUncheckedCreateWithoutUserInput> | UserRoleMappingCreateWithoutUserInput[] | UserRoleMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutUserInput | UserRoleMappingCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleMappingCreateManyUserInputEnvelope
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
  }

  export type ContestAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<ContestAttemptCreateWithoutUserInput, ContestAttemptUncheckedCreateWithoutUserInput> | ContestAttemptCreateWithoutUserInput[] | ContestAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContestAttemptCreateOrConnectWithoutUserInput | ContestAttemptCreateOrConnectWithoutUserInput[]
    createMany?: ContestAttemptCreateManyUserInputEnvelope
    connect?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
  }

  export type ChallengeAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<ChallengeAttemptCreateWithoutUserInput, ChallengeAttemptUncheckedCreateWithoutUserInput> | ChallengeAttemptCreateWithoutUserInput[] | ChallengeAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeAttemptCreateOrConnectWithoutUserInput | ChallengeAttemptCreateOrConnectWithoutUserInput[]
    createMany?: ChallengeAttemptCreateManyUserInputEnvelope
    connect?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
  }

  export type ConsultationRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<ConsultationRequestCreateWithoutUserInput, ConsultationRequestUncheckedCreateWithoutUserInput> | ConsultationRequestCreateWithoutUserInput[] | ConsultationRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConsultationRequestCreateOrConnectWithoutUserInput | ConsultationRequestCreateOrConnectWithoutUserInput[]
    createMany?: ConsultationRequestCreateManyUserInputEnvelope
    connect?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
  }

  export type MeetingCreateNestedManyWithoutUserInput = {
    create?: XOR<MeetingCreateWithoutUserInput, MeetingUncheckedCreateWithoutUserInput> | MeetingCreateWithoutUserInput[] | MeetingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutUserInput | MeetingCreateOrConnectWithoutUserInput[]
    createMany?: MeetingCreateManyUserInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type CourseUserMapperCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseUserMapperCreateWithoutUserInput, CourseUserMapperUncheckedCreateWithoutUserInput> | CourseUserMapperCreateWithoutUserInput[] | CourseUserMapperUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseUserMapperCreateOrConnectWithoutUserInput | CourseUserMapperCreateOrConnectWithoutUserInput[]
    createMany?: CourseUserMapperCreateManyUserInputEnvelope
    connect?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
  }

  export type UserRoleMappingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleMappingCreateWithoutUserInput, UserRoleMappingUncheckedCreateWithoutUserInput> | UserRoleMappingCreateWithoutUserInput[] | UserRoleMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutUserInput | UserRoleMappingCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleMappingCreateManyUserInputEnvelope
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
  }

  export type ContestAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContestAttemptCreateWithoutUserInput, ContestAttemptUncheckedCreateWithoutUserInput> | ContestAttemptCreateWithoutUserInput[] | ContestAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContestAttemptCreateOrConnectWithoutUserInput | ContestAttemptCreateOrConnectWithoutUserInput[]
    createMany?: ContestAttemptCreateManyUserInputEnvelope
    connect?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
  }

  export type ChallengeAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChallengeAttemptCreateWithoutUserInput, ChallengeAttemptUncheckedCreateWithoutUserInput> | ChallengeAttemptCreateWithoutUserInput[] | ChallengeAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeAttemptCreateOrConnectWithoutUserInput | ChallengeAttemptCreateOrConnectWithoutUserInput[]
    createMany?: ChallengeAttemptCreateManyUserInputEnvelope
    connect?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
  }

  export type ConsultationRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConsultationRequestCreateWithoutUserInput, ConsultationRequestUncheckedCreateWithoutUserInput> | ConsultationRequestCreateWithoutUserInput[] | ConsultationRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConsultationRequestCreateOrConnectWithoutUserInput | ConsultationRequestCreateOrConnectWithoutUserInput[]
    createMany?: ConsultationRequestCreateManyUserInputEnvelope
    connect?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
  }

  export type MeetingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MeetingCreateWithoutUserInput, MeetingUncheckedCreateWithoutUserInput> | MeetingCreateWithoutUserInput[] | MeetingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutUserInput | MeetingCreateOrConnectWithoutUserInput[]
    createMany?: MeetingCreateManyUserInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type CourseUserMapperUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseUserMapperCreateWithoutUserInput, CourseUserMapperUncheckedCreateWithoutUserInput> | CourseUserMapperCreateWithoutUserInput[] | CourseUserMapperUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseUserMapperCreateOrConnectWithoutUserInput | CourseUserMapperCreateOrConnectWithoutUserInput[]
    createMany?: CourseUserMapperCreateManyUserInputEnvelope
    connect?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumcurrenrStudylevelFieldUpdateOperationsInput = {
    set?: $Enums.currenrStudylevel | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserRoleMappingUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleMappingCreateWithoutUserInput, UserRoleMappingUncheckedCreateWithoutUserInput> | UserRoleMappingCreateWithoutUserInput[] | UserRoleMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutUserInput | UserRoleMappingCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleMappingUpsertWithWhereUniqueWithoutUserInput | UserRoleMappingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleMappingCreateManyUserInputEnvelope
    set?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    disconnect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    delete?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    update?: UserRoleMappingUpdateWithWhereUniqueWithoutUserInput | UserRoleMappingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleMappingUpdateManyWithWhereWithoutUserInput | UserRoleMappingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleMappingScalarWhereInput | UserRoleMappingScalarWhereInput[]
  }

  export type ContestAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContestAttemptCreateWithoutUserInput, ContestAttemptUncheckedCreateWithoutUserInput> | ContestAttemptCreateWithoutUserInput[] | ContestAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContestAttemptCreateOrConnectWithoutUserInput | ContestAttemptCreateOrConnectWithoutUserInput[]
    upsert?: ContestAttemptUpsertWithWhereUniqueWithoutUserInput | ContestAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContestAttemptCreateManyUserInputEnvelope
    set?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    disconnect?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    delete?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    connect?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    update?: ContestAttemptUpdateWithWhereUniqueWithoutUserInput | ContestAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContestAttemptUpdateManyWithWhereWithoutUserInput | ContestAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContestAttemptScalarWhereInput | ContestAttemptScalarWhereInput[]
  }

  export type ChallengeAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChallengeAttemptCreateWithoutUserInput, ChallengeAttemptUncheckedCreateWithoutUserInput> | ChallengeAttemptCreateWithoutUserInput[] | ChallengeAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeAttemptCreateOrConnectWithoutUserInput | ChallengeAttemptCreateOrConnectWithoutUserInput[]
    upsert?: ChallengeAttemptUpsertWithWhereUniqueWithoutUserInput | ChallengeAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChallengeAttemptCreateManyUserInputEnvelope
    set?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    disconnect?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    delete?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    connect?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    update?: ChallengeAttemptUpdateWithWhereUniqueWithoutUserInput | ChallengeAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChallengeAttemptUpdateManyWithWhereWithoutUserInput | ChallengeAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChallengeAttemptScalarWhereInput | ChallengeAttemptScalarWhereInput[]
  }

  export type ConsultationRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConsultationRequestCreateWithoutUserInput, ConsultationRequestUncheckedCreateWithoutUserInput> | ConsultationRequestCreateWithoutUserInput[] | ConsultationRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConsultationRequestCreateOrConnectWithoutUserInput | ConsultationRequestCreateOrConnectWithoutUserInput[]
    upsert?: ConsultationRequestUpsertWithWhereUniqueWithoutUserInput | ConsultationRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConsultationRequestCreateManyUserInputEnvelope
    set?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    disconnect?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    delete?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    connect?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    update?: ConsultationRequestUpdateWithWhereUniqueWithoutUserInput | ConsultationRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConsultationRequestUpdateManyWithWhereWithoutUserInput | ConsultationRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConsultationRequestScalarWhereInput | ConsultationRequestScalarWhereInput[]
  }

  export type MeetingUpdateManyWithoutUserNestedInput = {
    create?: XOR<MeetingCreateWithoutUserInput, MeetingUncheckedCreateWithoutUserInput> | MeetingCreateWithoutUserInput[] | MeetingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutUserInput | MeetingCreateOrConnectWithoutUserInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutUserInput | MeetingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MeetingCreateManyUserInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutUserInput | MeetingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutUserInput | MeetingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type CourseUserMapperUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseUserMapperCreateWithoutUserInput, CourseUserMapperUncheckedCreateWithoutUserInput> | CourseUserMapperCreateWithoutUserInput[] | CourseUserMapperUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseUserMapperCreateOrConnectWithoutUserInput | CourseUserMapperCreateOrConnectWithoutUserInput[]
    upsert?: CourseUserMapperUpsertWithWhereUniqueWithoutUserInput | CourseUserMapperUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseUserMapperCreateManyUserInputEnvelope
    set?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    disconnect?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    delete?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    connect?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    update?: CourseUserMapperUpdateWithWhereUniqueWithoutUserInput | CourseUserMapperUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseUserMapperUpdateManyWithWhereWithoutUserInput | CourseUserMapperUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseUserMapperScalarWhereInput | CourseUserMapperScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleMappingCreateWithoutUserInput, UserRoleMappingUncheckedCreateWithoutUserInput> | UserRoleMappingCreateWithoutUserInput[] | UserRoleMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutUserInput | UserRoleMappingCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleMappingUpsertWithWhereUniqueWithoutUserInput | UserRoleMappingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleMappingCreateManyUserInputEnvelope
    set?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    disconnect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    delete?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    update?: UserRoleMappingUpdateWithWhereUniqueWithoutUserInput | UserRoleMappingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleMappingUpdateManyWithWhereWithoutUserInput | UserRoleMappingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleMappingScalarWhereInput | UserRoleMappingScalarWhereInput[]
  }

  export type ContestAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContestAttemptCreateWithoutUserInput, ContestAttemptUncheckedCreateWithoutUserInput> | ContestAttemptCreateWithoutUserInput[] | ContestAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContestAttemptCreateOrConnectWithoutUserInput | ContestAttemptCreateOrConnectWithoutUserInput[]
    upsert?: ContestAttemptUpsertWithWhereUniqueWithoutUserInput | ContestAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContestAttemptCreateManyUserInputEnvelope
    set?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    disconnect?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    delete?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    connect?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    update?: ContestAttemptUpdateWithWhereUniqueWithoutUserInput | ContestAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContestAttemptUpdateManyWithWhereWithoutUserInput | ContestAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContestAttemptScalarWhereInput | ContestAttemptScalarWhereInput[]
  }

  export type ChallengeAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChallengeAttemptCreateWithoutUserInput, ChallengeAttemptUncheckedCreateWithoutUserInput> | ChallengeAttemptCreateWithoutUserInput[] | ChallengeAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeAttemptCreateOrConnectWithoutUserInput | ChallengeAttemptCreateOrConnectWithoutUserInput[]
    upsert?: ChallengeAttemptUpsertWithWhereUniqueWithoutUserInput | ChallengeAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChallengeAttemptCreateManyUserInputEnvelope
    set?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    disconnect?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    delete?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    connect?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    update?: ChallengeAttemptUpdateWithWhereUniqueWithoutUserInput | ChallengeAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChallengeAttemptUpdateManyWithWhereWithoutUserInput | ChallengeAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChallengeAttemptScalarWhereInput | ChallengeAttemptScalarWhereInput[]
  }

  export type ConsultationRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConsultationRequestCreateWithoutUserInput, ConsultationRequestUncheckedCreateWithoutUserInput> | ConsultationRequestCreateWithoutUserInput[] | ConsultationRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConsultationRequestCreateOrConnectWithoutUserInput | ConsultationRequestCreateOrConnectWithoutUserInput[]
    upsert?: ConsultationRequestUpsertWithWhereUniqueWithoutUserInput | ConsultationRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConsultationRequestCreateManyUserInputEnvelope
    set?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    disconnect?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    delete?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    connect?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    update?: ConsultationRequestUpdateWithWhereUniqueWithoutUserInput | ConsultationRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConsultationRequestUpdateManyWithWhereWithoutUserInput | ConsultationRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConsultationRequestScalarWhereInput | ConsultationRequestScalarWhereInput[]
  }

  export type MeetingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MeetingCreateWithoutUserInput, MeetingUncheckedCreateWithoutUserInput> | MeetingCreateWithoutUserInput[] | MeetingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutUserInput | MeetingCreateOrConnectWithoutUserInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutUserInput | MeetingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MeetingCreateManyUserInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutUserInput | MeetingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutUserInput | MeetingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type CourseUserMapperUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseUserMapperCreateWithoutUserInput, CourseUserMapperUncheckedCreateWithoutUserInput> | CourseUserMapperCreateWithoutUserInput[] | CourseUserMapperUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseUserMapperCreateOrConnectWithoutUserInput | CourseUserMapperCreateOrConnectWithoutUserInput[]
    upsert?: CourseUserMapperUpsertWithWhereUniqueWithoutUserInput | CourseUserMapperUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseUserMapperCreateManyUserInputEnvelope
    set?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    disconnect?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    delete?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    connect?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    update?: CourseUserMapperUpdateWithWhereUniqueWithoutUserInput | CourseUserMapperUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseUserMapperUpdateManyWithWhereWithoutUserInput | CourseUserMapperUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseUserMapperScalarWhereInput | CourseUserMapperScalarWhereInput[]
  }

  export type UserRoleMappingCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleMappingCreateWithoutRoleInput, UserRoleMappingUncheckedCreateWithoutRoleInput> | UserRoleMappingCreateWithoutRoleInput[] | UserRoleMappingUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutRoleInput | UserRoleMappingCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleMappingCreateManyRoleInputEnvelope
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
  }

  export type UserRoleMappingUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleMappingCreateWithoutRoleInput, UserRoleMappingUncheckedCreateWithoutRoleInput> | UserRoleMappingCreateWithoutRoleInput[] | UserRoleMappingUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutRoleInput | UserRoleMappingCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleMappingCreateManyRoleInputEnvelope
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
  }

  export type UserRoleMappingUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleMappingCreateWithoutRoleInput, UserRoleMappingUncheckedCreateWithoutRoleInput> | UserRoleMappingCreateWithoutRoleInput[] | UserRoleMappingUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutRoleInput | UserRoleMappingCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleMappingUpsertWithWhereUniqueWithoutRoleInput | UserRoleMappingUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleMappingCreateManyRoleInputEnvelope
    set?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    disconnect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    delete?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    update?: UserRoleMappingUpdateWithWhereUniqueWithoutRoleInput | UserRoleMappingUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleMappingUpdateManyWithWhereWithoutRoleInput | UserRoleMappingUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleMappingScalarWhereInput | UserRoleMappingScalarWhereInput[]
  }

  export type UserRoleMappingUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleMappingCreateWithoutRoleInput, UserRoleMappingUncheckedCreateWithoutRoleInput> | UserRoleMappingCreateWithoutRoleInput[] | UserRoleMappingUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleMappingCreateOrConnectWithoutRoleInput | UserRoleMappingCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleMappingUpsertWithWhereUniqueWithoutRoleInput | UserRoleMappingUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleMappingCreateManyRoleInputEnvelope
    set?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    disconnect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    delete?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    connect?: UserRoleMappingWhereUniqueInput | UserRoleMappingWhereUniqueInput[]
    update?: UserRoleMappingUpdateWithWhereUniqueWithoutRoleInput | UserRoleMappingUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleMappingUpdateManyWithWhereWithoutRoleInput | UserRoleMappingUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleMappingScalarWhereInput | UserRoleMappingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserRoleMappingsInput = {
    create?: XOR<UserCreateWithoutUserRoleMappingsInput, UserUncheckedCreateWithoutUserRoleMappingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRoleMappingsInput
    connect?: UserWhereUniqueInput
  }

  export type rolesCreateNestedOneWithoutUserRoleMappingsInput = {
    create?: XOR<rolesCreateWithoutUserRoleMappingsInput, rolesUncheckedCreateWithoutUserRoleMappingsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUserRoleMappingsInput
    connect?: rolesWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutUserRoleMappingsNestedInput = {
    create?: XOR<UserCreateWithoutUserRoleMappingsInput, UserUncheckedCreateWithoutUserRoleMappingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRoleMappingsInput
    upsert?: UserUpsertWithoutUserRoleMappingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRoleMappingsInput, UserUpdateWithoutUserRoleMappingsInput>, UserUncheckedUpdateWithoutUserRoleMappingsInput>
  }

  export type rolesUpdateOneRequiredWithoutUserRoleMappingsNestedInput = {
    create?: XOR<rolesCreateWithoutUserRoleMappingsInput, rolesUncheckedCreateWithoutUserRoleMappingsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUserRoleMappingsInput
    upsert?: rolesUpsertWithoutUserRoleMappingsInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutUserRoleMappingsInput, rolesUpdateWithoutUserRoleMappingsInput>, rolesUncheckedUpdateWithoutUserRoleMappingsInput>
  }

  export type LessonsCreateNestedManyWithoutCourseInput = {
    create?: XOR<LessonsCreateWithoutCourseInput, LessonsUncheckedCreateWithoutCourseInput> | LessonsCreateWithoutCourseInput[] | LessonsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutCourseInput | LessonsCreateOrConnectWithoutCourseInput[]
    createMany?: LessonsCreateManyCourseInputEnvelope
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
  }

  export type CourseUserMapperCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseUserMapperCreateWithoutCourseInput, CourseUserMapperUncheckedCreateWithoutCourseInput> | CourseUserMapperCreateWithoutCourseInput[] | CourseUserMapperUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseUserMapperCreateOrConnectWithoutCourseInput | CourseUserMapperCreateOrConnectWithoutCourseInput[]
    createMany?: CourseUserMapperCreateManyCourseInputEnvelope
    connect?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
  }

  export type LessonsUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<LessonsCreateWithoutCourseInput, LessonsUncheckedCreateWithoutCourseInput> | LessonsCreateWithoutCourseInput[] | LessonsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutCourseInput | LessonsCreateOrConnectWithoutCourseInput[]
    createMany?: LessonsCreateManyCourseInputEnvelope
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
  }

  export type CourseUserMapperUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseUserMapperCreateWithoutCourseInput, CourseUserMapperUncheckedCreateWithoutCourseInput> | CourseUserMapperCreateWithoutCourseInput[] | CourseUserMapperUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseUserMapperCreateOrConnectWithoutCourseInput | CourseUserMapperCreateOrConnectWithoutCourseInput[]
    createMany?: CourseUserMapperCreateManyCourseInputEnvelope
    connect?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCourseLevelFieldUpdateOperationsInput = {
    set?: $Enums.CourseLevel
  }

  export type LessonsUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LessonsCreateWithoutCourseInput, LessonsUncheckedCreateWithoutCourseInput> | LessonsCreateWithoutCourseInput[] | LessonsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutCourseInput | LessonsCreateOrConnectWithoutCourseInput[]
    upsert?: LessonsUpsertWithWhereUniqueWithoutCourseInput | LessonsUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LessonsCreateManyCourseInputEnvelope
    set?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    disconnect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    delete?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    update?: LessonsUpdateWithWhereUniqueWithoutCourseInput | LessonsUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LessonsUpdateManyWithWhereWithoutCourseInput | LessonsUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
  }

  export type CourseUserMapperUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseUserMapperCreateWithoutCourseInput, CourseUserMapperUncheckedCreateWithoutCourseInput> | CourseUserMapperCreateWithoutCourseInput[] | CourseUserMapperUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseUserMapperCreateOrConnectWithoutCourseInput | CourseUserMapperCreateOrConnectWithoutCourseInput[]
    upsert?: CourseUserMapperUpsertWithWhereUniqueWithoutCourseInput | CourseUserMapperUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseUserMapperCreateManyCourseInputEnvelope
    set?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    disconnect?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    delete?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    connect?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    update?: CourseUserMapperUpdateWithWhereUniqueWithoutCourseInput | CourseUserMapperUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseUserMapperUpdateManyWithWhereWithoutCourseInput | CourseUserMapperUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseUserMapperScalarWhereInput | CourseUserMapperScalarWhereInput[]
  }

  export type LessonsUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LessonsCreateWithoutCourseInput, LessonsUncheckedCreateWithoutCourseInput> | LessonsCreateWithoutCourseInput[] | LessonsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutCourseInput | LessonsCreateOrConnectWithoutCourseInput[]
    upsert?: LessonsUpsertWithWhereUniqueWithoutCourseInput | LessonsUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LessonsCreateManyCourseInputEnvelope
    set?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    disconnect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    delete?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    update?: LessonsUpdateWithWhereUniqueWithoutCourseInput | LessonsUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LessonsUpdateManyWithWhereWithoutCourseInput | LessonsUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
  }

  export type CourseUserMapperUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseUserMapperCreateWithoutCourseInput, CourseUserMapperUncheckedCreateWithoutCourseInput> | CourseUserMapperCreateWithoutCourseInput[] | CourseUserMapperUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseUserMapperCreateOrConnectWithoutCourseInput | CourseUserMapperCreateOrConnectWithoutCourseInput[]
    upsert?: CourseUserMapperUpsertWithWhereUniqueWithoutCourseInput | CourseUserMapperUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseUserMapperCreateManyCourseInputEnvelope
    set?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    disconnect?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    delete?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    connect?: CourseUserMapperWhereUniqueInput | CourseUserMapperWhereUniqueInput[]
    update?: CourseUserMapperUpdateWithWhereUniqueWithoutCourseInput | CourseUserMapperUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseUserMapperUpdateManyWithWhereWithoutCourseInput | CourseUserMapperUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseUserMapperScalarWhereInput | CourseUserMapperScalarWhereInput[]
  }

  export type CoursesCreateNestedOneWithoutLessonsInput = {
    create?: XOR<CoursesCreateWithoutLessonsInput, CoursesUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutLessonsInput
    connect?: CoursesWhereUniqueInput
  }

  export type CoursesUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<CoursesCreateWithoutLessonsInput, CoursesUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutLessonsInput
    upsert?: CoursesUpsertWithoutLessonsInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<XOR<CoursesUpdateToOneWithWhereWithoutLessonsInput, CoursesUpdateWithoutLessonsInput>, CoursesUncheckedUpdateWithoutLessonsInput>
  }

  export type UserCreateNestedOneWithoutEnrolledCoursesInput = {
    create?: XOR<UserCreateWithoutEnrolledCoursesInput, UserUncheckedCreateWithoutEnrolledCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrolledCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type CoursesCreateNestedOneWithoutEnrolledUsersInput = {
    create?: XOR<CoursesCreateWithoutEnrolledUsersInput, CoursesUncheckedCreateWithoutEnrolledUsersInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutEnrolledUsersInput
    connect?: CoursesWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEnrolledCoursesNestedInput = {
    create?: XOR<UserCreateWithoutEnrolledCoursesInput, UserUncheckedCreateWithoutEnrolledCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrolledCoursesInput
    upsert?: UserUpsertWithoutEnrolledCoursesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnrolledCoursesInput, UserUpdateWithoutEnrolledCoursesInput>, UserUncheckedUpdateWithoutEnrolledCoursesInput>
  }

  export type CoursesUpdateOneRequiredWithoutEnrolledUsersNestedInput = {
    create?: XOR<CoursesCreateWithoutEnrolledUsersInput, CoursesUncheckedCreateWithoutEnrolledUsersInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutEnrolledUsersInput
    upsert?: CoursesUpsertWithoutEnrolledUsersInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<XOR<CoursesUpdateToOneWithWhereWithoutEnrolledUsersInput, CoursesUpdateWithoutEnrolledUsersInput>, CoursesUncheckedUpdateWithoutEnrolledUsersInput>
  }

  export type ContestQuestionCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestQuestionCreateWithoutContestInput, ContestQuestionUncheckedCreateWithoutContestInput> | ContestQuestionCreateWithoutContestInput[] | ContestQuestionUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestQuestionCreateOrConnectWithoutContestInput | ContestQuestionCreateOrConnectWithoutContestInput[]
    createMany?: ContestQuestionCreateManyContestInputEnvelope
    connect?: ContestQuestionWhereUniqueInput | ContestQuestionWhereUniqueInput[]
  }

  export type ContestAttemptCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestAttemptCreateWithoutContestInput, ContestAttemptUncheckedCreateWithoutContestInput> | ContestAttemptCreateWithoutContestInput[] | ContestAttemptUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestAttemptCreateOrConnectWithoutContestInput | ContestAttemptCreateOrConnectWithoutContestInput[]
    createMany?: ContestAttemptCreateManyContestInputEnvelope
    connect?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
  }

  export type ContestQuestionUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestQuestionCreateWithoutContestInput, ContestQuestionUncheckedCreateWithoutContestInput> | ContestQuestionCreateWithoutContestInput[] | ContestQuestionUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestQuestionCreateOrConnectWithoutContestInput | ContestQuestionCreateOrConnectWithoutContestInput[]
    createMany?: ContestQuestionCreateManyContestInputEnvelope
    connect?: ContestQuestionWhereUniqueInput | ContestQuestionWhereUniqueInput[]
  }

  export type ContestAttemptUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestAttemptCreateWithoutContestInput, ContestAttemptUncheckedCreateWithoutContestInput> | ContestAttemptCreateWithoutContestInput[] | ContestAttemptUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestAttemptCreateOrConnectWithoutContestInput | ContestAttemptCreateOrConnectWithoutContestInput[]
    createMany?: ContestAttemptCreateManyContestInputEnvelope
    connect?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
  }

  export type ContestQuestionUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestQuestionCreateWithoutContestInput, ContestQuestionUncheckedCreateWithoutContestInput> | ContestQuestionCreateWithoutContestInput[] | ContestQuestionUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestQuestionCreateOrConnectWithoutContestInput | ContestQuestionCreateOrConnectWithoutContestInput[]
    upsert?: ContestQuestionUpsertWithWhereUniqueWithoutContestInput | ContestQuestionUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestQuestionCreateManyContestInputEnvelope
    set?: ContestQuestionWhereUniqueInput | ContestQuestionWhereUniqueInput[]
    disconnect?: ContestQuestionWhereUniqueInput | ContestQuestionWhereUniqueInput[]
    delete?: ContestQuestionWhereUniqueInput | ContestQuestionWhereUniqueInput[]
    connect?: ContestQuestionWhereUniqueInput | ContestQuestionWhereUniqueInput[]
    update?: ContestQuestionUpdateWithWhereUniqueWithoutContestInput | ContestQuestionUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestQuestionUpdateManyWithWhereWithoutContestInput | ContestQuestionUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestQuestionScalarWhereInput | ContestQuestionScalarWhereInput[]
  }

  export type ContestAttemptUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestAttemptCreateWithoutContestInput, ContestAttemptUncheckedCreateWithoutContestInput> | ContestAttemptCreateWithoutContestInput[] | ContestAttemptUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestAttemptCreateOrConnectWithoutContestInput | ContestAttemptCreateOrConnectWithoutContestInput[]
    upsert?: ContestAttemptUpsertWithWhereUniqueWithoutContestInput | ContestAttemptUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestAttemptCreateManyContestInputEnvelope
    set?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    disconnect?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    delete?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    connect?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    update?: ContestAttemptUpdateWithWhereUniqueWithoutContestInput | ContestAttemptUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestAttemptUpdateManyWithWhereWithoutContestInput | ContestAttemptUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestAttemptScalarWhereInput | ContestAttemptScalarWhereInput[]
  }

  export type ContestQuestionUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestQuestionCreateWithoutContestInput, ContestQuestionUncheckedCreateWithoutContestInput> | ContestQuestionCreateWithoutContestInput[] | ContestQuestionUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestQuestionCreateOrConnectWithoutContestInput | ContestQuestionCreateOrConnectWithoutContestInput[]
    upsert?: ContestQuestionUpsertWithWhereUniqueWithoutContestInput | ContestQuestionUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestQuestionCreateManyContestInputEnvelope
    set?: ContestQuestionWhereUniqueInput | ContestQuestionWhereUniqueInput[]
    disconnect?: ContestQuestionWhereUniqueInput | ContestQuestionWhereUniqueInput[]
    delete?: ContestQuestionWhereUniqueInput | ContestQuestionWhereUniqueInput[]
    connect?: ContestQuestionWhereUniqueInput | ContestQuestionWhereUniqueInput[]
    update?: ContestQuestionUpdateWithWhereUniqueWithoutContestInput | ContestQuestionUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestQuestionUpdateManyWithWhereWithoutContestInput | ContestQuestionUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestQuestionScalarWhereInput | ContestQuestionScalarWhereInput[]
  }

  export type ContestAttemptUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestAttemptCreateWithoutContestInput, ContestAttemptUncheckedCreateWithoutContestInput> | ContestAttemptCreateWithoutContestInput[] | ContestAttemptUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestAttemptCreateOrConnectWithoutContestInput | ContestAttemptCreateOrConnectWithoutContestInput[]
    upsert?: ContestAttemptUpsertWithWhereUniqueWithoutContestInput | ContestAttemptUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestAttemptCreateManyContestInputEnvelope
    set?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    disconnect?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    delete?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    connect?: ContestAttemptWhereUniqueInput | ContestAttemptWhereUniqueInput[]
    update?: ContestAttemptUpdateWithWhereUniqueWithoutContestInput | ContestAttemptUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestAttemptUpdateManyWithWhereWithoutContestInput | ContestAttemptUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestAttemptScalarWhereInput | ContestAttemptScalarWhereInput[]
  }

  export type ContestAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<ContestAnswerCreateWithoutQuestionInput, ContestAnswerUncheckedCreateWithoutQuestionInput> | ContestAnswerCreateWithoutQuestionInput[] | ContestAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ContestAnswerCreateOrConnectWithoutQuestionInput | ContestAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: ContestAnswerCreateManyQuestionInputEnvelope
    connect?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
  }

  export type ContestCreateNestedOneWithoutContestQuestionInput = {
    create?: XOR<ContestCreateWithoutContestQuestionInput, ContestUncheckedCreateWithoutContestQuestionInput>
    connectOrCreate?: ContestCreateOrConnectWithoutContestQuestionInput
    connect?: ContestWhereUniqueInput
  }

  export type ContestAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<ContestAnswerCreateWithoutQuestionInput, ContestAnswerUncheckedCreateWithoutQuestionInput> | ContestAnswerCreateWithoutQuestionInput[] | ContestAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ContestAnswerCreateOrConnectWithoutQuestionInput | ContestAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: ContestAnswerCreateManyQuestionInputEnvelope
    connect?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
  }

  export type ContestAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<ContestAnswerCreateWithoutQuestionInput, ContestAnswerUncheckedCreateWithoutQuestionInput> | ContestAnswerCreateWithoutQuestionInput[] | ContestAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ContestAnswerCreateOrConnectWithoutQuestionInput | ContestAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: ContestAnswerUpsertWithWhereUniqueWithoutQuestionInput | ContestAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: ContestAnswerCreateManyQuestionInputEnvelope
    set?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    disconnect?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    delete?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    connect?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    update?: ContestAnswerUpdateWithWhereUniqueWithoutQuestionInput | ContestAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: ContestAnswerUpdateManyWithWhereWithoutQuestionInput | ContestAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: ContestAnswerScalarWhereInput | ContestAnswerScalarWhereInput[]
  }

  export type ContestUpdateOneRequiredWithoutContestQuestionNestedInput = {
    create?: XOR<ContestCreateWithoutContestQuestionInput, ContestUncheckedCreateWithoutContestQuestionInput>
    connectOrCreate?: ContestCreateOrConnectWithoutContestQuestionInput
    upsert?: ContestUpsertWithoutContestQuestionInput
    connect?: ContestWhereUniqueInput
    update?: XOR<XOR<ContestUpdateToOneWithWhereWithoutContestQuestionInput, ContestUpdateWithoutContestQuestionInput>, ContestUncheckedUpdateWithoutContestQuestionInput>
  }

  export type ContestAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<ContestAnswerCreateWithoutQuestionInput, ContestAnswerUncheckedCreateWithoutQuestionInput> | ContestAnswerCreateWithoutQuestionInput[] | ContestAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ContestAnswerCreateOrConnectWithoutQuestionInput | ContestAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: ContestAnswerUpsertWithWhereUniqueWithoutQuestionInput | ContestAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: ContestAnswerCreateManyQuestionInputEnvelope
    set?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    disconnect?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    delete?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    connect?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    update?: ContestAnswerUpdateWithWhereUniqueWithoutQuestionInput | ContestAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: ContestAnswerUpdateManyWithWhereWithoutQuestionInput | ContestAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: ContestAnswerScalarWhereInput | ContestAnswerScalarWhereInput[]
  }

  export type ContestAnswerCreateNestedManyWithoutAttemptInput = {
    create?: XOR<ContestAnswerCreateWithoutAttemptInput, ContestAnswerUncheckedCreateWithoutAttemptInput> | ContestAnswerCreateWithoutAttemptInput[] | ContestAnswerUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: ContestAnswerCreateOrConnectWithoutAttemptInput | ContestAnswerCreateOrConnectWithoutAttemptInput[]
    createMany?: ContestAnswerCreateManyAttemptInputEnvelope
    connect?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
  }

  export type ContestCreateNestedOneWithoutContestAttemptInput = {
    create?: XOR<ContestCreateWithoutContestAttemptInput, ContestUncheckedCreateWithoutContestAttemptInput>
    connectOrCreate?: ContestCreateOrConnectWithoutContestAttemptInput
    connect?: ContestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutContestAttemptInput = {
    create?: XOR<UserCreateWithoutContestAttemptInput, UserUncheckedCreateWithoutContestAttemptInput>
    connectOrCreate?: UserCreateOrConnectWithoutContestAttemptInput
    connect?: UserWhereUniqueInput
  }

  export type ContestAnswerUncheckedCreateNestedManyWithoutAttemptInput = {
    create?: XOR<ContestAnswerCreateWithoutAttemptInput, ContestAnswerUncheckedCreateWithoutAttemptInput> | ContestAnswerCreateWithoutAttemptInput[] | ContestAnswerUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: ContestAnswerCreateOrConnectWithoutAttemptInput | ContestAnswerCreateOrConnectWithoutAttemptInput[]
    createMany?: ContestAnswerCreateManyAttemptInputEnvelope
    connect?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
  }

  export type ContestAnswerUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<ContestAnswerCreateWithoutAttemptInput, ContestAnswerUncheckedCreateWithoutAttemptInput> | ContestAnswerCreateWithoutAttemptInput[] | ContestAnswerUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: ContestAnswerCreateOrConnectWithoutAttemptInput | ContestAnswerCreateOrConnectWithoutAttemptInput[]
    upsert?: ContestAnswerUpsertWithWhereUniqueWithoutAttemptInput | ContestAnswerUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: ContestAnswerCreateManyAttemptInputEnvelope
    set?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    disconnect?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    delete?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    connect?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    update?: ContestAnswerUpdateWithWhereUniqueWithoutAttemptInput | ContestAnswerUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: ContestAnswerUpdateManyWithWhereWithoutAttemptInput | ContestAnswerUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: ContestAnswerScalarWhereInput | ContestAnswerScalarWhereInput[]
  }

  export type ContestUpdateOneRequiredWithoutContestAttemptNestedInput = {
    create?: XOR<ContestCreateWithoutContestAttemptInput, ContestUncheckedCreateWithoutContestAttemptInput>
    connectOrCreate?: ContestCreateOrConnectWithoutContestAttemptInput
    upsert?: ContestUpsertWithoutContestAttemptInput
    connect?: ContestWhereUniqueInput
    update?: XOR<XOR<ContestUpdateToOneWithWhereWithoutContestAttemptInput, ContestUpdateWithoutContestAttemptInput>, ContestUncheckedUpdateWithoutContestAttemptInput>
  }

  export type UserUpdateOneRequiredWithoutContestAttemptNestedInput = {
    create?: XOR<UserCreateWithoutContestAttemptInput, UserUncheckedCreateWithoutContestAttemptInput>
    connectOrCreate?: UserCreateOrConnectWithoutContestAttemptInput
    upsert?: UserUpsertWithoutContestAttemptInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContestAttemptInput, UserUpdateWithoutContestAttemptInput>, UserUncheckedUpdateWithoutContestAttemptInput>
  }

  export type ContestAnswerUncheckedUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<ContestAnswerCreateWithoutAttemptInput, ContestAnswerUncheckedCreateWithoutAttemptInput> | ContestAnswerCreateWithoutAttemptInput[] | ContestAnswerUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: ContestAnswerCreateOrConnectWithoutAttemptInput | ContestAnswerCreateOrConnectWithoutAttemptInput[]
    upsert?: ContestAnswerUpsertWithWhereUniqueWithoutAttemptInput | ContestAnswerUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: ContestAnswerCreateManyAttemptInputEnvelope
    set?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    disconnect?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    delete?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    connect?: ContestAnswerWhereUniqueInput | ContestAnswerWhereUniqueInput[]
    update?: ContestAnswerUpdateWithWhereUniqueWithoutAttemptInput | ContestAnswerUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: ContestAnswerUpdateManyWithWhereWithoutAttemptInput | ContestAnswerUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: ContestAnswerScalarWhereInput | ContestAnswerScalarWhereInput[]
  }

  export type ContestAttemptCreateNestedOneWithoutContestAnswerInput = {
    create?: XOR<ContestAttemptCreateWithoutContestAnswerInput, ContestAttemptUncheckedCreateWithoutContestAnswerInput>
    connectOrCreate?: ContestAttemptCreateOrConnectWithoutContestAnswerInput
    connect?: ContestAttemptWhereUniqueInput
  }

  export type ContestQuestionCreateNestedOneWithoutContestanswerInput = {
    create?: XOR<ContestQuestionCreateWithoutContestanswerInput, ContestQuestionUncheckedCreateWithoutContestanswerInput>
    connectOrCreate?: ContestQuestionCreateOrConnectWithoutContestanswerInput
    connect?: ContestQuestionWhereUniqueInput
  }

  export type ContestAttemptUpdateOneRequiredWithoutContestAnswerNestedInput = {
    create?: XOR<ContestAttemptCreateWithoutContestAnswerInput, ContestAttemptUncheckedCreateWithoutContestAnswerInput>
    connectOrCreate?: ContestAttemptCreateOrConnectWithoutContestAnswerInput
    upsert?: ContestAttemptUpsertWithoutContestAnswerInput
    connect?: ContestAttemptWhereUniqueInput
    update?: XOR<XOR<ContestAttemptUpdateToOneWithWhereWithoutContestAnswerInput, ContestAttemptUpdateWithoutContestAnswerInput>, ContestAttemptUncheckedUpdateWithoutContestAnswerInput>
  }

  export type ContestQuestionUpdateOneRequiredWithoutContestanswerNestedInput = {
    create?: XOR<ContestQuestionCreateWithoutContestanswerInput, ContestQuestionUncheckedCreateWithoutContestanswerInput>
    connectOrCreate?: ContestQuestionCreateOrConnectWithoutContestanswerInput
    upsert?: ContestQuestionUpsertWithoutContestanswerInput
    connect?: ContestQuestionWhereUniqueInput
    update?: XOR<XOR<ContestQuestionUpdateToOneWithWhereWithoutContestanswerInput, ContestQuestionUpdateWithoutContestanswerInput>, ContestQuestionUncheckedUpdateWithoutContestanswerInput>
  }

  export type ChallengeAttemptCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeAttemptCreateWithoutChallengeInput, ChallengeAttemptUncheckedCreateWithoutChallengeInput> | ChallengeAttemptCreateWithoutChallengeInput[] | ChallengeAttemptUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeAttemptCreateOrConnectWithoutChallengeInput | ChallengeAttemptCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeAttemptCreateManyChallengeInputEnvelope
    connect?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
  }

  export type ChallengeAttemptUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeAttemptCreateWithoutChallengeInput, ChallengeAttemptUncheckedCreateWithoutChallengeInput> | ChallengeAttemptCreateWithoutChallengeInput[] | ChallengeAttemptUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeAttemptCreateOrConnectWithoutChallengeInput | ChallengeAttemptCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeAttemptCreateManyChallengeInputEnvelope
    connect?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
  }

  export type EnumChallengeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeType
  }

  export type ChallengeAttemptUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeAttemptCreateWithoutChallengeInput, ChallengeAttemptUncheckedCreateWithoutChallengeInput> | ChallengeAttemptCreateWithoutChallengeInput[] | ChallengeAttemptUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeAttemptCreateOrConnectWithoutChallengeInput | ChallengeAttemptCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeAttemptUpsertWithWhereUniqueWithoutChallengeInput | ChallengeAttemptUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeAttemptCreateManyChallengeInputEnvelope
    set?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    disconnect?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    delete?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    connect?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    update?: ChallengeAttemptUpdateWithWhereUniqueWithoutChallengeInput | ChallengeAttemptUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeAttemptUpdateManyWithWhereWithoutChallengeInput | ChallengeAttemptUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeAttemptScalarWhereInput | ChallengeAttemptScalarWhereInput[]
  }

  export type ChallengeAttemptUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeAttemptCreateWithoutChallengeInput, ChallengeAttemptUncheckedCreateWithoutChallengeInput> | ChallengeAttemptCreateWithoutChallengeInput[] | ChallengeAttemptUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeAttemptCreateOrConnectWithoutChallengeInput | ChallengeAttemptCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeAttemptUpsertWithWhereUniqueWithoutChallengeInput | ChallengeAttemptUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeAttemptCreateManyChallengeInputEnvelope
    set?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    disconnect?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    delete?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    connect?: ChallengeAttemptWhereUniqueInput | ChallengeAttemptWhereUniqueInput[]
    update?: ChallengeAttemptUpdateWithWhereUniqueWithoutChallengeInput | ChallengeAttemptUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeAttemptUpdateManyWithWhereWithoutChallengeInput | ChallengeAttemptUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeAttemptScalarWhereInput | ChallengeAttemptScalarWhereInput[]
  }

  export type ChallengeCreateNestedOneWithoutChallengeAttemptInput = {
    create?: XOR<ChallengeCreateWithoutChallengeAttemptInput, ChallengeUncheckedCreateWithoutChallengeAttemptInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutChallengeAttemptInput
    connect?: ChallengeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChallengeAttemptInput = {
    create?: XOR<UserCreateWithoutChallengeAttemptInput, UserUncheckedCreateWithoutChallengeAttemptInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengeAttemptInput
    connect?: UserWhereUniqueInput
  }

  export type ChallengeUpdateOneRequiredWithoutChallengeAttemptNestedInput = {
    create?: XOR<ChallengeCreateWithoutChallengeAttemptInput, ChallengeUncheckedCreateWithoutChallengeAttemptInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutChallengeAttemptInput
    upsert?: ChallengeUpsertWithoutChallengeAttemptInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutChallengeAttemptInput, ChallengeUpdateWithoutChallengeAttemptInput>, ChallengeUncheckedUpdateWithoutChallengeAttemptInput>
  }

  export type UserUpdateOneRequiredWithoutChallengeAttemptNestedInput = {
    create?: XOR<UserCreateWithoutChallengeAttemptInput, UserUncheckedCreateWithoutChallengeAttemptInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengeAttemptInput
    upsert?: UserUpsertWithoutChallengeAttemptInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChallengeAttemptInput, UserUpdateWithoutChallengeAttemptInput>, UserUncheckedUpdateWithoutChallengeAttemptInput>
  }

  export type ConsultationRequestCreateNestedManyWithoutCounselorInput = {
    create?: XOR<ConsultationRequestCreateWithoutCounselorInput, ConsultationRequestUncheckedCreateWithoutCounselorInput> | ConsultationRequestCreateWithoutCounselorInput[] | ConsultationRequestUncheckedCreateWithoutCounselorInput[]
    connectOrCreate?: ConsultationRequestCreateOrConnectWithoutCounselorInput | ConsultationRequestCreateOrConnectWithoutCounselorInput[]
    createMany?: ConsultationRequestCreateManyCounselorInputEnvelope
    connect?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
  }

  export type MeetingCreateNestedManyWithoutCounselorInput = {
    create?: XOR<MeetingCreateWithoutCounselorInput, MeetingUncheckedCreateWithoutCounselorInput> | MeetingCreateWithoutCounselorInput[] | MeetingUncheckedCreateWithoutCounselorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCounselorInput | MeetingCreateOrConnectWithoutCounselorInput[]
    createMany?: MeetingCreateManyCounselorInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type ConsultationRequestUncheckedCreateNestedManyWithoutCounselorInput = {
    create?: XOR<ConsultationRequestCreateWithoutCounselorInput, ConsultationRequestUncheckedCreateWithoutCounselorInput> | ConsultationRequestCreateWithoutCounselorInput[] | ConsultationRequestUncheckedCreateWithoutCounselorInput[]
    connectOrCreate?: ConsultationRequestCreateOrConnectWithoutCounselorInput | ConsultationRequestCreateOrConnectWithoutCounselorInput[]
    createMany?: ConsultationRequestCreateManyCounselorInputEnvelope
    connect?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
  }

  export type MeetingUncheckedCreateNestedManyWithoutCounselorInput = {
    create?: XOR<MeetingCreateWithoutCounselorInput, MeetingUncheckedCreateWithoutCounselorInput> | MeetingCreateWithoutCounselorInput[] | MeetingUncheckedCreateWithoutCounselorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCounselorInput | MeetingCreateOrConnectWithoutCounselorInput[]
    createMany?: MeetingCreateManyCounselorInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type EnumEmploymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.EmploymentType
  }

  export type ConsultationRequestUpdateManyWithoutCounselorNestedInput = {
    create?: XOR<ConsultationRequestCreateWithoutCounselorInput, ConsultationRequestUncheckedCreateWithoutCounselorInput> | ConsultationRequestCreateWithoutCounselorInput[] | ConsultationRequestUncheckedCreateWithoutCounselorInput[]
    connectOrCreate?: ConsultationRequestCreateOrConnectWithoutCounselorInput | ConsultationRequestCreateOrConnectWithoutCounselorInput[]
    upsert?: ConsultationRequestUpsertWithWhereUniqueWithoutCounselorInput | ConsultationRequestUpsertWithWhereUniqueWithoutCounselorInput[]
    createMany?: ConsultationRequestCreateManyCounselorInputEnvelope
    set?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    disconnect?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    delete?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    connect?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    update?: ConsultationRequestUpdateWithWhereUniqueWithoutCounselorInput | ConsultationRequestUpdateWithWhereUniqueWithoutCounselorInput[]
    updateMany?: ConsultationRequestUpdateManyWithWhereWithoutCounselorInput | ConsultationRequestUpdateManyWithWhereWithoutCounselorInput[]
    deleteMany?: ConsultationRequestScalarWhereInput | ConsultationRequestScalarWhereInput[]
  }

  export type MeetingUpdateManyWithoutCounselorNestedInput = {
    create?: XOR<MeetingCreateWithoutCounselorInput, MeetingUncheckedCreateWithoutCounselorInput> | MeetingCreateWithoutCounselorInput[] | MeetingUncheckedCreateWithoutCounselorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCounselorInput | MeetingCreateOrConnectWithoutCounselorInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutCounselorInput | MeetingUpsertWithWhereUniqueWithoutCounselorInput[]
    createMany?: MeetingCreateManyCounselorInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutCounselorInput | MeetingUpdateWithWhereUniqueWithoutCounselorInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutCounselorInput | MeetingUpdateManyWithWhereWithoutCounselorInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type ConsultationRequestUncheckedUpdateManyWithoutCounselorNestedInput = {
    create?: XOR<ConsultationRequestCreateWithoutCounselorInput, ConsultationRequestUncheckedCreateWithoutCounselorInput> | ConsultationRequestCreateWithoutCounselorInput[] | ConsultationRequestUncheckedCreateWithoutCounselorInput[]
    connectOrCreate?: ConsultationRequestCreateOrConnectWithoutCounselorInput | ConsultationRequestCreateOrConnectWithoutCounselorInput[]
    upsert?: ConsultationRequestUpsertWithWhereUniqueWithoutCounselorInput | ConsultationRequestUpsertWithWhereUniqueWithoutCounselorInput[]
    createMany?: ConsultationRequestCreateManyCounselorInputEnvelope
    set?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    disconnect?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    delete?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    connect?: ConsultationRequestWhereUniqueInput | ConsultationRequestWhereUniqueInput[]
    update?: ConsultationRequestUpdateWithWhereUniqueWithoutCounselorInput | ConsultationRequestUpdateWithWhereUniqueWithoutCounselorInput[]
    updateMany?: ConsultationRequestUpdateManyWithWhereWithoutCounselorInput | ConsultationRequestUpdateManyWithWhereWithoutCounselorInput[]
    deleteMany?: ConsultationRequestScalarWhereInput | ConsultationRequestScalarWhereInput[]
  }

  export type MeetingUncheckedUpdateManyWithoutCounselorNestedInput = {
    create?: XOR<MeetingCreateWithoutCounselorInput, MeetingUncheckedCreateWithoutCounselorInput> | MeetingCreateWithoutCounselorInput[] | MeetingUncheckedCreateWithoutCounselorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCounselorInput | MeetingCreateOrConnectWithoutCounselorInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutCounselorInput | MeetingUpsertWithWhereUniqueWithoutCounselorInput[]
    createMany?: MeetingCreateManyCounselorInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutCounselorInput | MeetingUpdateWithWhereUniqueWithoutCounselorInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutCounselorInput | MeetingUpdateManyWithWhereWithoutCounselorInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutConsultationRequestsInput = {
    create?: XOR<UserCreateWithoutConsultationRequestsInput, UserUncheckedCreateWithoutConsultationRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsultationRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type CounselorCreateNestedOneWithoutConsultationRequestsInput = {
    create?: XOR<CounselorCreateWithoutConsultationRequestsInput, CounselorUncheckedCreateWithoutConsultationRequestsInput>
    connectOrCreate?: CounselorCreateOrConnectWithoutConsultationRequestsInput
    connect?: CounselorWhereUniqueInput
  }

  export type MeetingCreateNestedOneWithoutConsultationRequestInput = {
    create?: XOR<MeetingCreateWithoutConsultationRequestInput, MeetingUncheckedCreateWithoutConsultationRequestInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutConsultationRequestInput
    connect?: MeetingWhereUniqueInput
  }

  export type MeetingUncheckedCreateNestedOneWithoutConsultationRequestInput = {
    create?: XOR<MeetingCreateWithoutConsultationRequestInput, MeetingUncheckedCreateWithoutConsultationRequestInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutConsultationRequestInput
    connect?: MeetingWhereUniqueInput
  }

  export type EnumConsultationTypeFieldUpdateOperationsInput = {
    set?: $Enums.ConsultationType
  }

  export type EnumConsultationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConsultationStatus
  }

  export type UserUpdateOneRequiredWithoutConsultationRequestsNestedInput = {
    create?: XOR<UserCreateWithoutConsultationRequestsInput, UserUncheckedCreateWithoutConsultationRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsultationRequestsInput
    upsert?: UserUpsertWithoutConsultationRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConsultationRequestsInput, UserUpdateWithoutConsultationRequestsInput>, UserUncheckedUpdateWithoutConsultationRequestsInput>
  }

  export type CounselorUpdateOneRequiredWithoutConsultationRequestsNestedInput = {
    create?: XOR<CounselorCreateWithoutConsultationRequestsInput, CounselorUncheckedCreateWithoutConsultationRequestsInput>
    connectOrCreate?: CounselorCreateOrConnectWithoutConsultationRequestsInput
    upsert?: CounselorUpsertWithoutConsultationRequestsInput
    connect?: CounselorWhereUniqueInput
    update?: XOR<XOR<CounselorUpdateToOneWithWhereWithoutConsultationRequestsInput, CounselorUpdateWithoutConsultationRequestsInput>, CounselorUncheckedUpdateWithoutConsultationRequestsInput>
  }

  export type MeetingUpdateOneWithoutConsultationRequestNestedInput = {
    create?: XOR<MeetingCreateWithoutConsultationRequestInput, MeetingUncheckedCreateWithoutConsultationRequestInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutConsultationRequestInput
    upsert?: MeetingUpsertWithoutConsultationRequestInput
    disconnect?: MeetingWhereInput | boolean
    delete?: MeetingWhereInput | boolean
    connect?: MeetingWhereUniqueInput
    update?: XOR<XOR<MeetingUpdateToOneWithWhereWithoutConsultationRequestInput, MeetingUpdateWithoutConsultationRequestInput>, MeetingUncheckedUpdateWithoutConsultationRequestInput>
  }

  export type MeetingUncheckedUpdateOneWithoutConsultationRequestNestedInput = {
    create?: XOR<MeetingCreateWithoutConsultationRequestInput, MeetingUncheckedCreateWithoutConsultationRequestInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutConsultationRequestInput
    upsert?: MeetingUpsertWithoutConsultationRequestInput
    disconnect?: MeetingWhereInput | boolean
    delete?: MeetingWhereInput | boolean
    connect?: MeetingWhereUniqueInput
    update?: XOR<XOR<MeetingUpdateToOneWithWhereWithoutConsultationRequestInput, MeetingUpdateWithoutConsultationRequestInput>, MeetingUncheckedUpdateWithoutConsultationRequestInput>
  }

  export type ConsultationRequestCreateNestedOneWithoutMeetingInput = {
    create?: XOR<ConsultationRequestCreateWithoutMeetingInput, ConsultationRequestUncheckedCreateWithoutMeetingInput>
    connectOrCreate?: ConsultationRequestCreateOrConnectWithoutMeetingInput
    connect?: ConsultationRequestWhereUniqueInput
  }

  export type CounselorCreateNestedOneWithoutMeetingsInput = {
    create?: XOR<CounselorCreateWithoutMeetingsInput, CounselorUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: CounselorCreateOrConnectWithoutMeetingsInput
    connect?: CounselorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMeetingsInput = {
    create?: XOR<UserCreateWithoutMeetingsInput, UserUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeetingsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMeetingProviderFieldUpdateOperationsInput = {
    set?: $Enums.MeetingProvider
  }

  export type EnumMeetingStatusFieldUpdateOperationsInput = {
    set?: $Enums.MeetingStatus
  }

  export type ConsultationRequestUpdateOneRequiredWithoutMeetingNestedInput = {
    create?: XOR<ConsultationRequestCreateWithoutMeetingInput, ConsultationRequestUncheckedCreateWithoutMeetingInput>
    connectOrCreate?: ConsultationRequestCreateOrConnectWithoutMeetingInput
    upsert?: ConsultationRequestUpsertWithoutMeetingInput
    connect?: ConsultationRequestWhereUniqueInput
    update?: XOR<XOR<ConsultationRequestUpdateToOneWithWhereWithoutMeetingInput, ConsultationRequestUpdateWithoutMeetingInput>, ConsultationRequestUncheckedUpdateWithoutMeetingInput>
  }

  export type CounselorUpdateOneRequiredWithoutMeetingsNestedInput = {
    create?: XOR<CounselorCreateWithoutMeetingsInput, CounselorUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: CounselorCreateOrConnectWithoutMeetingsInput
    upsert?: CounselorUpsertWithoutMeetingsInput
    connect?: CounselorWhereUniqueInput
    update?: XOR<XOR<CounselorUpdateToOneWithWhereWithoutMeetingsInput, CounselorUpdateWithoutMeetingsInput>, CounselorUncheckedUpdateWithoutMeetingsInput>
  }

  export type UserUpdateOneRequiredWithoutMeetingsNestedInput = {
    create?: XOR<UserCreateWithoutMeetingsInput, UserUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeetingsInput
    upsert?: UserUpsertWithoutMeetingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMeetingsInput, UserUpdateWithoutMeetingsInput>, UserUncheckedUpdateWithoutMeetingsInput>
  }

  export type EnumResourceCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ResourceCategory
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumcurrenrStudylevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.currenrStudylevel | EnumcurrenrStudylevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.currenrStudylevel[] | ListEnumcurrenrStudylevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.currenrStudylevel[] | ListEnumcurrenrStudylevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcurrenrStudylevelNullableFilter<$PrismaModel> | $Enums.currenrStudylevel | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumcurrenrStudylevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.currenrStudylevel | EnumcurrenrStudylevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.currenrStudylevel[] | ListEnumcurrenrStudylevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.currenrStudylevel[] | ListEnumcurrenrStudylevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcurrenrStudylevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.currenrStudylevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumcurrenrStudylevelNullableFilter<$PrismaModel>
    _max?: NestedEnumcurrenrStudylevelNullableFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCourseLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelFilter<$PrismaModel> | $Enums.CourseLevel
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumCourseLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelWithAggregatesFilter<$PrismaModel> | $Enums.CourseLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseLevelFilter<$PrismaModel>
    _max?: NestedEnumCourseLevelFilter<$PrismaModel>
  }

  export type NestedEnumChallengeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeTypeFilter<$PrismaModel> | $Enums.ChallengeType
  }

  export type NestedEnumChallengeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeTypeFilter<$PrismaModel>
    _max?: NestedEnumChallengeTypeFilter<$PrismaModel>
  }

  export type NestedEnumEmploymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeFilter<$PrismaModel> | $Enums.EmploymentType
  }

  export type NestedEnumEmploymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmploymentTypeFilter<$PrismaModel>
    _max?: NestedEnumEmploymentTypeFilter<$PrismaModel>
  }

  export type NestedEnumConsultationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsultationType | EnumConsultationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsultationTypeFilter<$PrismaModel> | $Enums.ConsultationType
  }

  export type NestedEnumConsultationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsultationStatus | EnumConsultationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsultationStatus[] | ListEnumConsultationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsultationStatus[] | ListEnumConsultationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsultationStatusFilter<$PrismaModel> | $Enums.ConsultationStatus
  }

  export type NestedEnumConsultationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsultationType | EnumConsultationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsultationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConsultationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsultationTypeFilter<$PrismaModel>
    _max?: NestedEnumConsultationTypeFilter<$PrismaModel>
  }

  export type NestedEnumConsultationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsultationStatus | EnumConsultationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsultationStatus[] | ListEnumConsultationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsultationStatus[] | ListEnumConsultationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsultationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConsultationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsultationStatusFilter<$PrismaModel>
    _max?: NestedEnumConsultationStatusFilter<$PrismaModel>
  }

  export type NestedEnumMeetingProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingProvider | EnumMeetingProviderFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingProvider[] | ListEnumMeetingProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingProvider[] | ListEnumMeetingProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingProviderFilter<$PrismaModel> | $Enums.MeetingProvider
  }

  export type NestedEnumMeetingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingStatus | EnumMeetingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingStatusFilter<$PrismaModel> | $Enums.MeetingStatus
  }

  export type NestedEnumMeetingProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingProvider | EnumMeetingProviderFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingProvider[] | ListEnumMeetingProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingProvider[] | ListEnumMeetingProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingProviderWithAggregatesFilter<$PrismaModel> | $Enums.MeetingProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeetingProviderFilter<$PrismaModel>
    _max?: NestedEnumMeetingProviderFilter<$PrismaModel>
  }

  export type NestedEnumMeetingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingStatus | EnumMeetingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingStatusWithAggregatesFilter<$PrismaModel> | $Enums.MeetingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeetingStatusFilter<$PrismaModel>
    _max?: NestedEnumMeetingStatusFilter<$PrismaModel>
  }

  export type NestedEnumResourceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceCategory | EnumResourceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceCategory[] | ListEnumResourceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceCategory[] | ListEnumResourceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceCategoryFilter<$PrismaModel> | $Enums.ResourceCategory
  }

  export type NestedEnumResourceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceCategory | EnumResourceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceCategory[] | ListEnumResourceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceCategory[] | ListEnumResourceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ResourceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceCategoryFilter<$PrismaModel>
    _max?: NestedEnumResourceCategoryFilter<$PrismaModel>
  }

  export type UserRoleMappingCreateWithoutUserInput = {
    assignedAt?: Date | string
    assignedBy?: number | null
    role: rolesCreateNestedOneWithoutUserRoleMappingsInput
  }

  export type UserRoleMappingUncheckedCreateWithoutUserInput = {
    id?: number
    roleId: number
    assignedAt?: Date | string
    assignedBy?: number | null
  }

  export type UserRoleMappingCreateOrConnectWithoutUserInput = {
    where: UserRoleMappingWhereUniqueInput
    create: XOR<UserRoleMappingCreateWithoutUserInput, UserRoleMappingUncheckedCreateWithoutUserInput>
  }

  export type UserRoleMappingCreateManyUserInputEnvelope = {
    data: UserRoleMappingCreateManyUserInput | UserRoleMappingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContestAttemptCreateWithoutUserInput = {
    startedAt: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    timeTaken?: number | null
    ContestAnswer?: ContestAnswerCreateNestedManyWithoutAttemptInput
    contest: ContestCreateNestedOneWithoutContestAttemptInput
  }

  export type ContestAttemptUncheckedCreateWithoutUserInput = {
    id?: number
    contestId: number
    startedAt: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    timeTaken?: number | null
    ContestAnswer?: ContestAnswerUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type ContestAttemptCreateOrConnectWithoutUserInput = {
    where: ContestAttemptWhereUniqueInput
    create: XOR<ContestAttemptCreateWithoutUserInput, ContestAttemptUncheckedCreateWithoutUserInput>
  }

  export type ContestAttemptCreateManyUserInputEnvelope = {
    data: ContestAttemptCreateManyUserInput | ContestAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeAttemptCreateWithoutUserInput = {
    completedAt?: Date | string | null
    earnedPoints: number
    challenge: ChallengeCreateNestedOneWithoutChallengeAttemptInput
  }

  export type ChallengeAttemptUncheckedCreateWithoutUserInput = {
    id?: number
    challengeId: number
    completedAt?: Date | string | null
    earnedPoints: number
  }

  export type ChallengeAttemptCreateOrConnectWithoutUserInput = {
    where: ChallengeAttemptWhereUniqueInput
    create: XOR<ChallengeAttemptCreateWithoutUserInput, ChallengeAttemptUncheckedCreateWithoutUserInput>
  }

  export type ChallengeAttemptCreateManyUserInputEnvelope = {
    data: ChallengeAttemptCreateManyUserInput | ChallengeAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConsultationRequestCreateWithoutUserInput = {
    requestType: $Enums.ConsultationType
    scheduledAt?: Date | string | null
    status?: $Enums.ConsultationStatus
    message?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    counselor: CounselorCreateNestedOneWithoutConsultationRequestsInput
    meeting?: MeetingCreateNestedOneWithoutConsultationRequestInput
  }

  export type ConsultationRequestUncheckedCreateWithoutUserInput = {
    id?: number
    counselorId: string
    requestType: $Enums.ConsultationType
    scheduledAt?: Date | string | null
    status?: $Enums.ConsultationStatus
    message?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    meeting?: MeetingUncheckedCreateNestedOneWithoutConsultationRequestInput
  }

  export type ConsultationRequestCreateOrConnectWithoutUserInput = {
    where: ConsultationRequestWhereUniqueInput
    create: XOR<ConsultationRequestCreateWithoutUserInput, ConsultationRequestUncheckedCreateWithoutUserInput>
  }

  export type ConsultationRequestCreateManyUserInputEnvelope = {
    data: ConsultationRequestCreateManyUserInput | ConsultationRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MeetingCreateWithoutUserInput = {
    id?: string
    meetingProvider: $Enums.MeetingProvider
    meetingRoomId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    status?: $Enums.MeetingStatus
    createdAt?: Date | string
    consultationRequest: ConsultationRequestCreateNestedOneWithoutMeetingInput
    counselor: CounselorCreateNestedOneWithoutMeetingsInput
  }

  export type MeetingUncheckedCreateWithoutUserInput = {
    id?: string
    consultationRequestId: number
    counselorId: string
    meetingProvider: $Enums.MeetingProvider
    meetingRoomId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    status?: $Enums.MeetingStatus
    createdAt?: Date | string
  }

  export type MeetingCreateOrConnectWithoutUserInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutUserInput, MeetingUncheckedCreateWithoutUserInput>
  }

  export type MeetingCreateManyUserInputEnvelope = {
    data: MeetingCreateManyUserInput | MeetingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseUserMapperCreateWithoutUserInput = {
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    isCompleted?: boolean
    course: CoursesCreateNestedOneWithoutEnrolledUsersInput
  }

  export type CourseUserMapperUncheckedCreateWithoutUserInput = {
    id?: number
    courseId: number
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    isCompleted?: boolean
  }

  export type CourseUserMapperCreateOrConnectWithoutUserInput = {
    where: CourseUserMapperWhereUniqueInput
    create: XOR<CourseUserMapperCreateWithoutUserInput, CourseUserMapperUncheckedCreateWithoutUserInput>
  }

  export type CourseUserMapperCreateManyUserInputEnvelope = {
    data: CourseUserMapperCreateManyUserInput | CourseUserMapperCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleMappingUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleMappingWhereUniqueInput
    update: XOR<UserRoleMappingUpdateWithoutUserInput, UserRoleMappingUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleMappingCreateWithoutUserInput, UserRoleMappingUncheckedCreateWithoutUserInput>
  }

  export type UserRoleMappingUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleMappingWhereUniqueInput
    data: XOR<UserRoleMappingUpdateWithoutUserInput, UserRoleMappingUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleMappingUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleMappingScalarWhereInput
    data: XOR<UserRoleMappingUpdateManyMutationInput, UserRoleMappingUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleMappingScalarWhereInput = {
    AND?: UserRoleMappingScalarWhereInput | UserRoleMappingScalarWhereInput[]
    OR?: UserRoleMappingScalarWhereInput[]
    NOT?: UserRoleMappingScalarWhereInput | UserRoleMappingScalarWhereInput[]
    id?: IntFilter<"UserRoleMapping"> | number
    userId?: IntFilter<"UserRoleMapping"> | number
    roleId?: IntFilter<"UserRoleMapping"> | number
    assignedAt?: DateTimeFilter<"UserRoleMapping"> | Date | string
    assignedBy?: IntNullableFilter<"UserRoleMapping"> | number | null
  }

  export type ContestAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: ContestAttemptWhereUniqueInput
    update: XOR<ContestAttemptUpdateWithoutUserInput, ContestAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<ContestAttemptCreateWithoutUserInput, ContestAttemptUncheckedCreateWithoutUserInput>
  }

  export type ContestAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: ContestAttemptWhereUniqueInput
    data: XOR<ContestAttemptUpdateWithoutUserInput, ContestAttemptUncheckedUpdateWithoutUserInput>
  }

  export type ContestAttemptUpdateManyWithWhereWithoutUserInput = {
    where: ContestAttemptScalarWhereInput
    data: XOR<ContestAttemptUpdateManyMutationInput, ContestAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type ContestAttemptScalarWhereInput = {
    AND?: ContestAttemptScalarWhereInput | ContestAttemptScalarWhereInput[]
    OR?: ContestAttemptScalarWhereInput[]
    NOT?: ContestAttemptScalarWhereInput | ContestAttemptScalarWhereInput[]
    id?: IntFilter<"ContestAttempt"> | number
    contestId?: IntFilter<"ContestAttempt"> | number
    userId?: IntFilter<"ContestAttempt"> | number
    startedAt?: DateTimeFilter<"ContestAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"ContestAttempt"> | Date | string | null
    score?: IntNullableFilter<"ContestAttempt"> | number | null
    timeTaken?: IntNullableFilter<"ContestAttempt"> | number | null
  }

  export type ChallengeAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: ChallengeAttemptWhereUniqueInput
    update: XOR<ChallengeAttemptUpdateWithoutUserInput, ChallengeAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<ChallengeAttemptCreateWithoutUserInput, ChallengeAttemptUncheckedCreateWithoutUserInput>
  }

  export type ChallengeAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: ChallengeAttemptWhereUniqueInput
    data: XOR<ChallengeAttemptUpdateWithoutUserInput, ChallengeAttemptUncheckedUpdateWithoutUserInput>
  }

  export type ChallengeAttemptUpdateManyWithWhereWithoutUserInput = {
    where: ChallengeAttemptScalarWhereInput
    data: XOR<ChallengeAttemptUpdateManyMutationInput, ChallengeAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type ChallengeAttemptScalarWhereInput = {
    AND?: ChallengeAttemptScalarWhereInput | ChallengeAttemptScalarWhereInput[]
    OR?: ChallengeAttemptScalarWhereInput[]
    NOT?: ChallengeAttemptScalarWhereInput | ChallengeAttemptScalarWhereInput[]
    id?: IntFilter<"ChallengeAttempt"> | number
    challengeId?: IntFilter<"ChallengeAttempt"> | number
    userId?: IntFilter<"ChallengeAttempt"> | number
    completedAt?: DateTimeNullableFilter<"ChallengeAttempt"> | Date | string | null
    earnedPoints?: IntFilter<"ChallengeAttempt"> | number
  }

  export type ConsultationRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: ConsultationRequestWhereUniqueInput
    update: XOR<ConsultationRequestUpdateWithoutUserInput, ConsultationRequestUncheckedUpdateWithoutUserInput>
    create: XOR<ConsultationRequestCreateWithoutUserInput, ConsultationRequestUncheckedCreateWithoutUserInput>
  }

  export type ConsultationRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: ConsultationRequestWhereUniqueInput
    data: XOR<ConsultationRequestUpdateWithoutUserInput, ConsultationRequestUncheckedUpdateWithoutUserInput>
  }

  export type ConsultationRequestUpdateManyWithWhereWithoutUserInput = {
    where: ConsultationRequestScalarWhereInput
    data: XOR<ConsultationRequestUpdateManyMutationInput, ConsultationRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type ConsultationRequestScalarWhereInput = {
    AND?: ConsultationRequestScalarWhereInput | ConsultationRequestScalarWhereInput[]
    OR?: ConsultationRequestScalarWhereInput[]
    NOT?: ConsultationRequestScalarWhereInput | ConsultationRequestScalarWhereInput[]
    id?: IntFilter<"ConsultationRequest"> | number
    userId?: IntFilter<"ConsultationRequest"> | number
    counselorId?: StringFilter<"ConsultationRequest"> | string
    requestType?: EnumConsultationTypeFilter<"ConsultationRequest"> | $Enums.ConsultationType
    scheduledAt?: DateTimeNullableFilter<"ConsultationRequest"> | Date | string | null
    status?: EnumConsultationStatusFilter<"ConsultationRequest"> | $Enums.ConsultationStatus
    message?: StringNullableFilter<"ConsultationRequest"> | string | null
    respondedAt?: DateTimeNullableFilter<"ConsultationRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"ConsultationRequest"> | Date | string
  }

  export type MeetingUpsertWithWhereUniqueWithoutUserInput = {
    where: MeetingWhereUniqueInput
    update: XOR<MeetingUpdateWithoutUserInput, MeetingUncheckedUpdateWithoutUserInput>
    create: XOR<MeetingCreateWithoutUserInput, MeetingUncheckedCreateWithoutUserInput>
  }

  export type MeetingUpdateWithWhereUniqueWithoutUserInput = {
    where: MeetingWhereUniqueInput
    data: XOR<MeetingUpdateWithoutUserInput, MeetingUncheckedUpdateWithoutUserInput>
  }

  export type MeetingUpdateManyWithWhereWithoutUserInput = {
    where: MeetingScalarWhereInput
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyWithoutUserInput>
  }

  export type MeetingScalarWhereInput = {
    AND?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    OR?: MeetingScalarWhereInput[]
    NOT?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    id?: StringFilter<"Meeting"> | string
    consultationRequestId?: IntFilter<"Meeting"> | number
    counselorId?: StringFilter<"Meeting"> | string
    userId?: IntFilter<"Meeting"> | number
    meetingProvider?: EnumMeetingProviderFilter<"Meeting"> | $Enums.MeetingProvider
    meetingRoomId?: StringFilter<"Meeting"> | string
    startTime?: DateTimeNullableFilter<"Meeting"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Meeting"> | Date | string | null
    duration?: IntNullableFilter<"Meeting"> | number | null
    status?: EnumMeetingStatusFilter<"Meeting"> | $Enums.MeetingStatus
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
  }

  export type CourseUserMapperUpsertWithWhereUniqueWithoutUserInput = {
    where: CourseUserMapperWhereUniqueInput
    update: XOR<CourseUserMapperUpdateWithoutUserInput, CourseUserMapperUncheckedUpdateWithoutUserInput>
    create: XOR<CourseUserMapperCreateWithoutUserInput, CourseUserMapperUncheckedCreateWithoutUserInput>
  }

  export type CourseUserMapperUpdateWithWhereUniqueWithoutUserInput = {
    where: CourseUserMapperWhereUniqueInput
    data: XOR<CourseUserMapperUpdateWithoutUserInput, CourseUserMapperUncheckedUpdateWithoutUserInput>
  }

  export type CourseUserMapperUpdateManyWithWhereWithoutUserInput = {
    where: CourseUserMapperScalarWhereInput
    data: XOR<CourseUserMapperUpdateManyMutationInput, CourseUserMapperUncheckedUpdateManyWithoutUserInput>
  }

  export type CourseUserMapperScalarWhereInput = {
    AND?: CourseUserMapperScalarWhereInput | CourseUserMapperScalarWhereInput[]
    OR?: CourseUserMapperScalarWhereInput[]
    NOT?: CourseUserMapperScalarWhereInput | CourseUserMapperScalarWhereInput[]
    id?: IntFilter<"CourseUserMapper"> | number
    userId?: IntFilter<"CourseUserMapper"> | number
    courseId?: IntFilter<"CourseUserMapper"> | number
    enrolledAt?: DateTimeFilter<"CourseUserMapper"> | Date | string
    completedAt?: DateTimeNullableFilter<"CourseUserMapper"> | Date | string | null
    progress?: IntFilter<"CourseUserMapper"> | number
    isCompleted?: BoolFilter<"CourseUserMapper"> | boolean
  }

  export type UserRoleMappingCreateWithoutRoleInput = {
    assignedAt?: Date | string
    assignedBy?: number | null
    user: UserCreateNestedOneWithoutUserRoleMappingsInput
  }

  export type UserRoleMappingUncheckedCreateWithoutRoleInput = {
    id?: number
    userId: number
    assignedAt?: Date | string
    assignedBy?: number | null
  }

  export type UserRoleMappingCreateOrConnectWithoutRoleInput = {
    where: UserRoleMappingWhereUniqueInput
    create: XOR<UserRoleMappingCreateWithoutRoleInput, UserRoleMappingUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleMappingCreateManyRoleInputEnvelope = {
    data: UserRoleMappingCreateManyRoleInput | UserRoleMappingCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleMappingUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleMappingWhereUniqueInput
    update: XOR<UserRoleMappingUpdateWithoutRoleInput, UserRoleMappingUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleMappingCreateWithoutRoleInput, UserRoleMappingUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleMappingUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleMappingWhereUniqueInput
    data: XOR<UserRoleMappingUpdateWithoutRoleInput, UserRoleMappingUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleMappingUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleMappingScalarWhereInput
    data: XOR<UserRoleMappingUpdateManyMutationInput, UserRoleMappingUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserCreateWithoutUserRoleMappingsInput = {
    firstName?: string | null
    lastName?: string | null
    phoneNo?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    state?: string | null
    country?: string | null
    profileImage?: string | null
    currenrStudyLevel?: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    ContestAttempt?: ContestAttemptCreateNestedManyWithoutUserInput
    ChallengeAttempt?: ChallengeAttemptCreateNestedManyWithoutUserInput
    consultationRequests?: ConsultationRequestCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    enrolledCourses?: CourseUserMapperCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserRoleMappingsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phoneNo?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    state?: string | null
    country?: string | null
    profileImage?: string | null
    currenrStudyLevel?: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    ContestAttempt?: ContestAttemptUncheckedCreateNestedManyWithoutUserInput
    ChallengeAttempt?: ChallengeAttemptUncheckedCreateNestedManyWithoutUserInput
    consultationRequests?: ConsultationRequestUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    enrolledCourses?: CourseUserMapperUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserRoleMappingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRoleMappingsInput, UserUncheckedCreateWithoutUserRoleMappingsInput>
  }

  export type rolesCreateWithoutUserRoleMappingsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type rolesUncheckedCreateWithoutUserRoleMappingsInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type rolesCreateOrConnectWithoutUserRoleMappingsInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutUserRoleMappingsInput, rolesUncheckedCreateWithoutUserRoleMappingsInput>
  }

  export type UserUpsertWithoutUserRoleMappingsInput = {
    update: XOR<UserUpdateWithoutUserRoleMappingsInput, UserUncheckedUpdateWithoutUserRoleMappingsInput>
    create: XOR<UserCreateWithoutUserRoleMappingsInput, UserUncheckedCreateWithoutUserRoleMappingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRoleMappingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRoleMappingsInput, UserUncheckedUpdateWithoutUserRoleMappingsInput>
  }

  export type UserUpdateWithoutUserRoleMappingsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ContestAttempt?: ContestAttemptUpdateManyWithoutUserNestedInput
    ChallengeAttempt?: ChallengeAttemptUpdateManyWithoutUserNestedInput
    consultationRequests?: ConsultationRequestUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    enrolledCourses?: CourseUserMapperUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRoleMappingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ContestAttempt?: ContestAttemptUncheckedUpdateManyWithoutUserNestedInput
    ChallengeAttempt?: ChallengeAttemptUncheckedUpdateManyWithoutUserNestedInput
    consultationRequests?: ConsultationRequestUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    enrolledCourses?: CourseUserMapperUncheckedUpdateManyWithoutUserNestedInput
  }

  export type rolesUpsertWithoutUserRoleMappingsInput = {
    update: XOR<rolesUpdateWithoutUserRoleMappingsInput, rolesUncheckedUpdateWithoutUserRoleMappingsInput>
    create: XOR<rolesCreateWithoutUserRoleMappingsInput, rolesUncheckedCreateWithoutUserRoleMappingsInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutUserRoleMappingsInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutUserRoleMappingsInput, rolesUncheckedUpdateWithoutUserRoleMappingsInput>
  }

  export type rolesUpdateWithoutUserRoleMappingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolesUncheckedUpdateWithoutUserRoleMappingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonsCreateWithoutCourseInput = {
    title: string
    description?: string | null
    videoType: string
    videoId: string
    duration?: number | null
    order: number
    isFreePreview: boolean
  }

  export type LessonsUncheckedCreateWithoutCourseInput = {
    id?: number
    title: string
    description?: string | null
    videoType: string
    videoId: string
    duration?: number | null
    order: number
    isFreePreview: boolean
  }

  export type LessonsCreateOrConnectWithoutCourseInput = {
    where: LessonsWhereUniqueInput
    create: XOR<LessonsCreateWithoutCourseInput, LessonsUncheckedCreateWithoutCourseInput>
  }

  export type LessonsCreateManyCourseInputEnvelope = {
    data: LessonsCreateManyCourseInput | LessonsCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseUserMapperCreateWithoutCourseInput = {
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    isCompleted?: boolean
    user: UserCreateNestedOneWithoutEnrolledCoursesInput
  }

  export type CourseUserMapperUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    isCompleted?: boolean
  }

  export type CourseUserMapperCreateOrConnectWithoutCourseInput = {
    where: CourseUserMapperWhereUniqueInput
    create: XOR<CourseUserMapperCreateWithoutCourseInput, CourseUserMapperUncheckedCreateWithoutCourseInput>
  }

  export type CourseUserMapperCreateManyCourseInputEnvelope = {
    data: CourseUserMapperCreateManyCourseInput | CourseUserMapperCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type LessonsUpsertWithWhereUniqueWithoutCourseInput = {
    where: LessonsWhereUniqueInput
    update: XOR<LessonsUpdateWithoutCourseInput, LessonsUncheckedUpdateWithoutCourseInput>
    create: XOR<LessonsCreateWithoutCourseInput, LessonsUncheckedCreateWithoutCourseInput>
  }

  export type LessonsUpdateWithWhereUniqueWithoutCourseInput = {
    where: LessonsWhereUniqueInput
    data: XOR<LessonsUpdateWithoutCourseInput, LessonsUncheckedUpdateWithoutCourseInput>
  }

  export type LessonsUpdateManyWithWhereWithoutCourseInput = {
    where: LessonsScalarWhereInput
    data: XOR<LessonsUpdateManyMutationInput, LessonsUncheckedUpdateManyWithoutCourseInput>
  }

  export type LessonsScalarWhereInput = {
    AND?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
    OR?: LessonsScalarWhereInput[]
    NOT?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
    id?: IntFilter<"Lessons"> | number
    courseId?: IntFilter<"Lessons"> | number
    title?: StringFilter<"Lessons"> | string
    description?: StringNullableFilter<"Lessons"> | string | null
    videoType?: StringFilter<"Lessons"> | string
    videoId?: StringFilter<"Lessons"> | string
    duration?: IntNullableFilter<"Lessons"> | number | null
    order?: IntFilter<"Lessons"> | number
    isFreePreview?: BoolFilter<"Lessons"> | boolean
  }

  export type CourseUserMapperUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseUserMapperWhereUniqueInput
    update: XOR<CourseUserMapperUpdateWithoutCourseInput, CourseUserMapperUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseUserMapperCreateWithoutCourseInput, CourseUserMapperUncheckedCreateWithoutCourseInput>
  }

  export type CourseUserMapperUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseUserMapperWhereUniqueInput
    data: XOR<CourseUserMapperUpdateWithoutCourseInput, CourseUserMapperUncheckedUpdateWithoutCourseInput>
  }

  export type CourseUserMapperUpdateManyWithWhereWithoutCourseInput = {
    where: CourseUserMapperScalarWhereInput
    data: XOR<CourseUserMapperUpdateManyMutationInput, CourseUserMapperUncheckedUpdateManyWithoutCourseInput>
  }

  export type CoursesCreateWithoutLessonsInput = {
    title: string
    description?: string | null
    price: number
    thumbnailUrl?: string | null
    instructor?: string | null
    duration?: string | null
    level: $Enums.CourseLevel
    category?: string | null
    language?: string | null
    isPublished?: boolean
    createdBy?: number | null
    createdAt?: Date | string | null
    enrolledUsers?: CourseUserMapperCreateNestedManyWithoutCourseInput
  }

  export type CoursesUncheckedCreateWithoutLessonsInput = {
    id?: number
    title: string
    description?: string | null
    price: number
    thumbnailUrl?: string | null
    instructor?: string | null
    duration?: string | null
    level: $Enums.CourseLevel
    category?: string | null
    language?: string | null
    isPublished?: boolean
    createdBy?: number | null
    createdAt?: Date | string | null
    enrolledUsers?: CourseUserMapperUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CoursesCreateOrConnectWithoutLessonsInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutLessonsInput, CoursesUncheckedCreateWithoutLessonsInput>
  }

  export type CoursesUpsertWithoutLessonsInput = {
    update: XOR<CoursesUpdateWithoutLessonsInput, CoursesUncheckedUpdateWithoutLessonsInput>
    create: XOR<CoursesCreateWithoutLessonsInput, CoursesUncheckedCreateWithoutLessonsInput>
    where?: CoursesWhereInput
  }

  export type CoursesUpdateToOneWithWhereWithoutLessonsInput = {
    where?: CoursesWhereInput
    data: XOR<CoursesUpdateWithoutLessonsInput, CoursesUncheckedUpdateWithoutLessonsInput>
  }

  export type CoursesUpdateWithoutLessonsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    category?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrolledUsers?: CourseUserMapperUpdateManyWithoutCourseNestedInput
  }

  export type CoursesUncheckedUpdateWithoutLessonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    category?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrolledUsers?: CourseUserMapperUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutEnrolledCoursesInput = {
    firstName?: string | null
    lastName?: string | null
    phoneNo?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    state?: string | null
    country?: string | null
    profileImage?: string | null
    currenrStudyLevel?: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userRoleMappings?: UserRoleMappingCreateNestedManyWithoutUserInput
    ContestAttempt?: ContestAttemptCreateNestedManyWithoutUserInput
    ChallengeAttempt?: ChallengeAttemptCreateNestedManyWithoutUserInput
    consultationRequests?: ConsultationRequestCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEnrolledCoursesInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phoneNo?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    state?: string | null
    country?: string | null
    profileImage?: string | null
    currenrStudyLevel?: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userRoleMappings?: UserRoleMappingUncheckedCreateNestedManyWithoutUserInput
    ContestAttempt?: ContestAttemptUncheckedCreateNestedManyWithoutUserInput
    ChallengeAttempt?: ChallengeAttemptUncheckedCreateNestedManyWithoutUserInput
    consultationRequests?: ConsultationRequestUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEnrolledCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnrolledCoursesInput, UserUncheckedCreateWithoutEnrolledCoursesInput>
  }

  export type CoursesCreateWithoutEnrolledUsersInput = {
    title: string
    description?: string | null
    price: number
    thumbnailUrl?: string | null
    instructor?: string | null
    duration?: string | null
    level: $Enums.CourseLevel
    category?: string | null
    language?: string | null
    isPublished?: boolean
    createdBy?: number | null
    createdAt?: Date | string | null
    lessons?: LessonsCreateNestedManyWithoutCourseInput
  }

  export type CoursesUncheckedCreateWithoutEnrolledUsersInput = {
    id?: number
    title: string
    description?: string | null
    price: number
    thumbnailUrl?: string | null
    instructor?: string | null
    duration?: string | null
    level: $Enums.CourseLevel
    category?: string | null
    language?: string | null
    isPublished?: boolean
    createdBy?: number | null
    createdAt?: Date | string | null
    lessons?: LessonsUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CoursesCreateOrConnectWithoutEnrolledUsersInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutEnrolledUsersInput, CoursesUncheckedCreateWithoutEnrolledUsersInput>
  }

  export type UserUpsertWithoutEnrolledCoursesInput = {
    update: XOR<UserUpdateWithoutEnrolledCoursesInput, UserUncheckedUpdateWithoutEnrolledCoursesInput>
    create: XOR<UserCreateWithoutEnrolledCoursesInput, UserUncheckedCreateWithoutEnrolledCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnrolledCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnrolledCoursesInput, UserUncheckedUpdateWithoutEnrolledCoursesInput>
  }

  export type UserUpdateWithoutEnrolledCoursesInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoleMappings?: UserRoleMappingUpdateManyWithoutUserNestedInput
    ContestAttempt?: ContestAttemptUpdateManyWithoutUserNestedInput
    ChallengeAttempt?: ChallengeAttemptUpdateManyWithoutUserNestedInput
    consultationRequests?: ConsultationRequestUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEnrolledCoursesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoleMappings?: UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput
    ContestAttempt?: ContestAttemptUncheckedUpdateManyWithoutUserNestedInput
    ChallengeAttempt?: ChallengeAttemptUncheckedUpdateManyWithoutUserNestedInput
    consultationRequests?: ConsultationRequestUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CoursesUpsertWithoutEnrolledUsersInput = {
    update: XOR<CoursesUpdateWithoutEnrolledUsersInput, CoursesUncheckedUpdateWithoutEnrolledUsersInput>
    create: XOR<CoursesCreateWithoutEnrolledUsersInput, CoursesUncheckedCreateWithoutEnrolledUsersInput>
    where?: CoursesWhereInput
  }

  export type CoursesUpdateToOneWithWhereWithoutEnrolledUsersInput = {
    where?: CoursesWhereInput
    data: XOR<CoursesUpdateWithoutEnrolledUsersInput, CoursesUncheckedUpdateWithoutEnrolledUsersInput>
  }

  export type CoursesUpdateWithoutEnrolledUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    category?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessons?: LessonsUpdateManyWithoutCourseNestedInput
  }

  export type CoursesUncheckedUpdateWithoutEnrolledUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    category?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessons?: LessonsUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ContestQuestionCreateWithoutContestInput = {
    questionText: string
    optionA: string
    optionB: string
    optionC?: string | null
    optionD?: string | null
    correctOption: string
    marks: number
    contestanswer?: ContestAnswerCreateNestedManyWithoutQuestionInput
  }

  export type ContestQuestionUncheckedCreateWithoutContestInput = {
    id?: number
    questionText: string
    optionA: string
    optionB: string
    optionC?: string | null
    optionD?: string | null
    correctOption: string
    marks: number
    contestanswer?: ContestAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type ContestQuestionCreateOrConnectWithoutContestInput = {
    where: ContestQuestionWhereUniqueInput
    create: XOR<ContestQuestionCreateWithoutContestInput, ContestQuestionUncheckedCreateWithoutContestInput>
  }

  export type ContestQuestionCreateManyContestInputEnvelope = {
    data: ContestQuestionCreateManyContestInput | ContestQuestionCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type ContestAttemptCreateWithoutContestInput = {
    startedAt: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    timeTaken?: number | null
    ContestAnswer?: ContestAnswerCreateNestedManyWithoutAttemptInput
    user: UserCreateNestedOneWithoutContestAttemptInput
  }

  export type ContestAttemptUncheckedCreateWithoutContestInput = {
    id?: number
    userId: number
    startedAt: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    timeTaken?: number | null
    ContestAnswer?: ContestAnswerUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type ContestAttemptCreateOrConnectWithoutContestInput = {
    where: ContestAttemptWhereUniqueInput
    create: XOR<ContestAttemptCreateWithoutContestInput, ContestAttemptUncheckedCreateWithoutContestInput>
  }

  export type ContestAttemptCreateManyContestInputEnvelope = {
    data: ContestAttemptCreateManyContestInput | ContestAttemptCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type ContestQuestionUpsertWithWhereUniqueWithoutContestInput = {
    where: ContestQuestionWhereUniqueInput
    update: XOR<ContestQuestionUpdateWithoutContestInput, ContestQuestionUncheckedUpdateWithoutContestInput>
    create: XOR<ContestQuestionCreateWithoutContestInput, ContestQuestionUncheckedCreateWithoutContestInput>
  }

  export type ContestQuestionUpdateWithWhereUniqueWithoutContestInput = {
    where: ContestQuestionWhereUniqueInput
    data: XOR<ContestQuestionUpdateWithoutContestInput, ContestQuestionUncheckedUpdateWithoutContestInput>
  }

  export type ContestQuestionUpdateManyWithWhereWithoutContestInput = {
    where: ContestQuestionScalarWhereInput
    data: XOR<ContestQuestionUpdateManyMutationInput, ContestQuestionUncheckedUpdateManyWithoutContestInput>
  }

  export type ContestQuestionScalarWhereInput = {
    AND?: ContestQuestionScalarWhereInput | ContestQuestionScalarWhereInput[]
    OR?: ContestQuestionScalarWhereInput[]
    NOT?: ContestQuestionScalarWhereInput | ContestQuestionScalarWhereInput[]
    id?: IntFilter<"ContestQuestion"> | number
    contestId?: IntFilter<"ContestQuestion"> | number
    questionText?: StringFilter<"ContestQuestion"> | string
    optionA?: StringFilter<"ContestQuestion"> | string
    optionB?: StringFilter<"ContestQuestion"> | string
    optionC?: StringNullableFilter<"ContestQuestion"> | string | null
    optionD?: StringNullableFilter<"ContestQuestion"> | string | null
    correctOption?: StringFilter<"ContestQuestion"> | string
    marks?: IntFilter<"ContestQuestion"> | number
  }

  export type ContestAttemptUpsertWithWhereUniqueWithoutContestInput = {
    where: ContestAttemptWhereUniqueInput
    update: XOR<ContestAttemptUpdateWithoutContestInput, ContestAttemptUncheckedUpdateWithoutContestInput>
    create: XOR<ContestAttemptCreateWithoutContestInput, ContestAttemptUncheckedCreateWithoutContestInput>
  }

  export type ContestAttemptUpdateWithWhereUniqueWithoutContestInput = {
    where: ContestAttemptWhereUniqueInput
    data: XOR<ContestAttemptUpdateWithoutContestInput, ContestAttemptUncheckedUpdateWithoutContestInput>
  }

  export type ContestAttemptUpdateManyWithWhereWithoutContestInput = {
    where: ContestAttemptScalarWhereInput
    data: XOR<ContestAttemptUpdateManyMutationInput, ContestAttemptUncheckedUpdateManyWithoutContestInput>
  }

  export type ContestAnswerCreateWithoutQuestionInput = {
    selectedOption: string
    isCorrect: boolean
    attempt: ContestAttemptCreateNestedOneWithoutContestAnswerInput
  }

  export type ContestAnswerUncheckedCreateWithoutQuestionInput = {
    id?: number
    attemptId: number
    selectedOption: string
    isCorrect: boolean
  }

  export type ContestAnswerCreateOrConnectWithoutQuestionInput = {
    where: ContestAnswerWhereUniqueInput
    create: XOR<ContestAnswerCreateWithoutQuestionInput, ContestAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type ContestAnswerCreateManyQuestionInputEnvelope = {
    data: ContestAnswerCreateManyQuestionInput | ContestAnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type ContestCreateWithoutContestQuestionInput = {
    title: string
    description?: string | null
    category: string
    startTime: Date | string
    endTime: Date | string
    isPublished?: boolean
    durationMinutes?: number | null
    totalMarks?: number | null
    isActive?: boolean
    createdByAdminId?: number | null
    createdAt?: Date | string
    ContestAttempt?: ContestAttemptCreateNestedManyWithoutContestInput
  }

  export type ContestUncheckedCreateWithoutContestQuestionInput = {
    id?: number
    title: string
    description?: string | null
    category: string
    startTime: Date | string
    endTime: Date | string
    isPublished?: boolean
    durationMinutes?: number | null
    totalMarks?: number | null
    isActive?: boolean
    createdByAdminId?: number | null
    createdAt?: Date | string
    ContestAttempt?: ContestAttemptUncheckedCreateNestedManyWithoutContestInput
  }

  export type ContestCreateOrConnectWithoutContestQuestionInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutContestQuestionInput, ContestUncheckedCreateWithoutContestQuestionInput>
  }

  export type ContestAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: ContestAnswerWhereUniqueInput
    update: XOR<ContestAnswerUpdateWithoutQuestionInput, ContestAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<ContestAnswerCreateWithoutQuestionInput, ContestAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type ContestAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: ContestAnswerWhereUniqueInput
    data: XOR<ContestAnswerUpdateWithoutQuestionInput, ContestAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type ContestAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: ContestAnswerScalarWhereInput
    data: XOR<ContestAnswerUpdateManyMutationInput, ContestAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type ContestAnswerScalarWhereInput = {
    AND?: ContestAnswerScalarWhereInput | ContestAnswerScalarWhereInput[]
    OR?: ContestAnswerScalarWhereInput[]
    NOT?: ContestAnswerScalarWhereInput | ContestAnswerScalarWhereInput[]
    id?: IntFilter<"ContestAnswer"> | number
    attemptId?: IntFilter<"ContestAnswer"> | number
    questionId?: IntFilter<"ContestAnswer"> | number
    selectedOption?: StringFilter<"ContestAnswer"> | string
    isCorrect?: BoolFilter<"ContestAnswer"> | boolean
  }

  export type ContestUpsertWithoutContestQuestionInput = {
    update: XOR<ContestUpdateWithoutContestQuestionInput, ContestUncheckedUpdateWithoutContestQuestionInput>
    create: XOR<ContestCreateWithoutContestQuestionInput, ContestUncheckedCreateWithoutContestQuestionInput>
    where?: ContestWhereInput
  }

  export type ContestUpdateToOneWithWhereWithoutContestQuestionInput = {
    where?: ContestWhereInput
    data: XOR<ContestUpdateWithoutContestQuestionInput, ContestUncheckedUpdateWithoutContestQuestionInput>
  }

  export type ContestUpdateWithoutContestQuestionInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdByAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ContestAttempt?: ContestAttemptUpdateManyWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateWithoutContestQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdByAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ContestAttempt?: ContestAttemptUncheckedUpdateManyWithoutContestNestedInput
  }

  export type ContestAnswerCreateWithoutAttemptInput = {
    selectedOption: string
    isCorrect: boolean
    question: ContestQuestionCreateNestedOneWithoutContestanswerInput
  }

  export type ContestAnswerUncheckedCreateWithoutAttemptInput = {
    id?: number
    questionId: number
    selectedOption: string
    isCorrect: boolean
  }

  export type ContestAnswerCreateOrConnectWithoutAttemptInput = {
    where: ContestAnswerWhereUniqueInput
    create: XOR<ContestAnswerCreateWithoutAttemptInput, ContestAnswerUncheckedCreateWithoutAttemptInput>
  }

  export type ContestAnswerCreateManyAttemptInputEnvelope = {
    data: ContestAnswerCreateManyAttemptInput | ContestAnswerCreateManyAttemptInput[]
    skipDuplicates?: boolean
  }

  export type ContestCreateWithoutContestAttemptInput = {
    title: string
    description?: string | null
    category: string
    startTime: Date | string
    endTime: Date | string
    isPublished?: boolean
    durationMinutes?: number | null
    totalMarks?: number | null
    isActive?: boolean
    createdByAdminId?: number | null
    createdAt?: Date | string
    ContestQuestion?: ContestQuestionCreateNestedManyWithoutContestInput
  }

  export type ContestUncheckedCreateWithoutContestAttemptInput = {
    id?: number
    title: string
    description?: string | null
    category: string
    startTime: Date | string
    endTime: Date | string
    isPublished?: boolean
    durationMinutes?: number | null
    totalMarks?: number | null
    isActive?: boolean
    createdByAdminId?: number | null
    createdAt?: Date | string
    ContestQuestion?: ContestQuestionUncheckedCreateNestedManyWithoutContestInput
  }

  export type ContestCreateOrConnectWithoutContestAttemptInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutContestAttemptInput, ContestUncheckedCreateWithoutContestAttemptInput>
  }

  export type UserCreateWithoutContestAttemptInput = {
    firstName?: string | null
    lastName?: string | null
    phoneNo?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    state?: string | null
    country?: string | null
    profileImage?: string | null
    currenrStudyLevel?: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userRoleMappings?: UserRoleMappingCreateNestedManyWithoutUserInput
    ChallengeAttempt?: ChallengeAttemptCreateNestedManyWithoutUserInput
    consultationRequests?: ConsultationRequestCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    enrolledCourses?: CourseUserMapperCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContestAttemptInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phoneNo?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    state?: string | null
    country?: string | null
    profileImage?: string | null
    currenrStudyLevel?: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userRoleMappings?: UserRoleMappingUncheckedCreateNestedManyWithoutUserInput
    ChallengeAttempt?: ChallengeAttemptUncheckedCreateNestedManyWithoutUserInput
    consultationRequests?: ConsultationRequestUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    enrolledCourses?: CourseUserMapperUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContestAttemptInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContestAttemptInput, UserUncheckedCreateWithoutContestAttemptInput>
  }

  export type ContestAnswerUpsertWithWhereUniqueWithoutAttemptInput = {
    where: ContestAnswerWhereUniqueInput
    update: XOR<ContestAnswerUpdateWithoutAttemptInput, ContestAnswerUncheckedUpdateWithoutAttemptInput>
    create: XOR<ContestAnswerCreateWithoutAttemptInput, ContestAnswerUncheckedCreateWithoutAttemptInput>
  }

  export type ContestAnswerUpdateWithWhereUniqueWithoutAttemptInput = {
    where: ContestAnswerWhereUniqueInput
    data: XOR<ContestAnswerUpdateWithoutAttemptInput, ContestAnswerUncheckedUpdateWithoutAttemptInput>
  }

  export type ContestAnswerUpdateManyWithWhereWithoutAttemptInput = {
    where: ContestAnswerScalarWhereInput
    data: XOR<ContestAnswerUpdateManyMutationInput, ContestAnswerUncheckedUpdateManyWithoutAttemptInput>
  }

  export type ContestUpsertWithoutContestAttemptInput = {
    update: XOR<ContestUpdateWithoutContestAttemptInput, ContestUncheckedUpdateWithoutContestAttemptInput>
    create: XOR<ContestCreateWithoutContestAttemptInput, ContestUncheckedCreateWithoutContestAttemptInput>
    where?: ContestWhereInput
  }

  export type ContestUpdateToOneWithWhereWithoutContestAttemptInput = {
    where?: ContestWhereInput
    data: XOR<ContestUpdateWithoutContestAttemptInput, ContestUncheckedUpdateWithoutContestAttemptInput>
  }

  export type ContestUpdateWithoutContestAttemptInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdByAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ContestQuestion?: ContestQuestionUpdateManyWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateWithoutContestAttemptInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdByAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ContestQuestion?: ContestQuestionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type UserUpsertWithoutContestAttemptInput = {
    update: XOR<UserUpdateWithoutContestAttemptInput, UserUncheckedUpdateWithoutContestAttemptInput>
    create: XOR<UserCreateWithoutContestAttemptInput, UserUncheckedCreateWithoutContestAttemptInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContestAttemptInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContestAttemptInput, UserUncheckedUpdateWithoutContestAttemptInput>
  }

  export type UserUpdateWithoutContestAttemptInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoleMappings?: UserRoleMappingUpdateManyWithoutUserNestedInput
    ChallengeAttempt?: ChallengeAttemptUpdateManyWithoutUserNestedInput
    consultationRequests?: ConsultationRequestUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    enrolledCourses?: CourseUserMapperUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContestAttemptInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoleMappings?: UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput
    ChallengeAttempt?: ChallengeAttemptUncheckedUpdateManyWithoutUserNestedInput
    consultationRequests?: ConsultationRequestUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    enrolledCourses?: CourseUserMapperUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContestAttemptCreateWithoutContestAnswerInput = {
    startedAt: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    timeTaken?: number | null
    contest: ContestCreateNestedOneWithoutContestAttemptInput
    user: UserCreateNestedOneWithoutContestAttemptInput
  }

  export type ContestAttemptUncheckedCreateWithoutContestAnswerInput = {
    id?: number
    contestId: number
    userId: number
    startedAt: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    timeTaken?: number | null
  }

  export type ContestAttemptCreateOrConnectWithoutContestAnswerInput = {
    where: ContestAttemptWhereUniqueInput
    create: XOR<ContestAttemptCreateWithoutContestAnswerInput, ContestAttemptUncheckedCreateWithoutContestAnswerInput>
  }

  export type ContestQuestionCreateWithoutContestanswerInput = {
    questionText: string
    optionA: string
    optionB: string
    optionC?: string | null
    optionD?: string | null
    correctOption: string
    marks: number
    contest: ContestCreateNestedOneWithoutContestQuestionInput
  }

  export type ContestQuestionUncheckedCreateWithoutContestanswerInput = {
    id?: number
    contestId: number
    questionText: string
    optionA: string
    optionB: string
    optionC?: string | null
    optionD?: string | null
    correctOption: string
    marks: number
  }

  export type ContestQuestionCreateOrConnectWithoutContestanswerInput = {
    where: ContestQuestionWhereUniqueInput
    create: XOR<ContestQuestionCreateWithoutContestanswerInput, ContestQuestionUncheckedCreateWithoutContestanswerInput>
  }

  export type ContestAttemptUpsertWithoutContestAnswerInput = {
    update: XOR<ContestAttemptUpdateWithoutContestAnswerInput, ContestAttemptUncheckedUpdateWithoutContestAnswerInput>
    create: XOR<ContestAttemptCreateWithoutContestAnswerInput, ContestAttemptUncheckedCreateWithoutContestAnswerInput>
    where?: ContestAttemptWhereInput
  }

  export type ContestAttemptUpdateToOneWithWhereWithoutContestAnswerInput = {
    where?: ContestAttemptWhereInput
    data: XOR<ContestAttemptUpdateWithoutContestAnswerInput, ContestAttemptUncheckedUpdateWithoutContestAnswerInput>
  }

  export type ContestAttemptUpdateWithoutContestAnswerInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    contest?: ContestUpdateOneRequiredWithoutContestAttemptNestedInput
    user?: UserUpdateOneRequiredWithoutContestAttemptNestedInput
  }

  export type ContestAttemptUncheckedUpdateWithoutContestAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    contestId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContestQuestionUpsertWithoutContestanswerInput = {
    update: XOR<ContestQuestionUpdateWithoutContestanswerInput, ContestQuestionUncheckedUpdateWithoutContestanswerInput>
    create: XOR<ContestQuestionCreateWithoutContestanswerInput, ContestQuestionUncheckedCreateWithoutContestanswerInput>
    where?: ContestQuestionWhereInput
  }

  export type ContestQuestionUpdateToOneWithWhereWithoutContestanswerInput = {
    where?: ContestQuestionWhereInput
    data: XOR<ContestQuestionUpdateWithoutContestanswerInput, ContestQuestionUncheckedUpdateWithoutContestanswerInput>
  }

  export type ContestQuestionUpdateWithoutContestanswerInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: NullableStringFieldUpdateOperationsInput | string | null
    optionD?: NullableStringFieldUpdateOperationsInput | string | null
    correctOption?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    contest?: ContestUpdateOneRequiredWithoutContestQuestionNestedInput
  }

  export type ContestQuestionUncheckedUpdateWithoutContestanswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    contestId?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: NullableStringFieldUpdateOperationsInput | string | null
    optionD?: NullableStringFieldUpdateOperationsInput | string | null
    correctOption?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeAttemptCreateWithoutChallengeInput = {
    completedAt?: Date | string | null
    earnedPoints: number
    user: UserCreateNestedOneWithoutChallengeAttemptInput
  }

  export type ChallengeAttemptUncheckedCreateWithoutChallengeInput = {
    id?: number
    userId: number
    completedAt?: Date | string | null
    earnedPoints: number
  }

  export type ChallengeAttemptCreateOrConnectWithoutChallengeInput = {
    where: ChallengeAttemptWhereUniqueInput
    create: XOR<ChallengeAttemptCreateWithoutChallengeInput, ChallengeAttemptUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeAttemptCreateManyChallengeInputEnvelope = {
    data: ChallengeAttemptCreateManyChallengeInput | ChallengeAttemptCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeAttemptUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeAttemptWhereUniqueInput
    update: XOR<ChallengeAttemptUpdateWithoutChallengeInput, ChallengeAttemptUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeAttemptCreateWithoutChallengeInput, ChallengeAttemptUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeAttemptUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeAttemptWhereUniqueInput
    data: XOR<ChallengeAttemptUpdateWithoutChallengeInput, ChallengeAttemptUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeAttemptUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeAttemptScalarWhereInput
    data: XOR<ChallengeAttemptUpdateManyMutationInput, ChallengeAttemptUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeCreateWithoutChallengeAttemptInput = {
    title: string
    type: $Enums.ChallengeType
    category: string
    difficulty: string
    points: number
    startDate: Date | string
    endDate: Date | string
    isActive: boolean
  }

  export type ChallengeUncheckedCreateWithoutChallengeAttemptInput = {
    id?: number
    title: string
    type: $Enums.ChallengeType
    category: string
    difficulty: string
    points: number
    startDate: Date | string
    endDate: Date | string
    isActive: boolean
  }

  export type ChallengeCreateOrConnectWithoutChallengeAttemptInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutChallengeAttemptInput, ChallengeUncheckedCreateWithoutChallengeAttemptInput>
  }

  export type UserCreateWithoutChallengeAttemptInput = {
    firstName?: string | null
    lastName?: string | null
    phoneNo?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    state?: string | null
    country?: string | null
    profileImage?: string | null
    currenrStudyLevel?: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userRoleMappings?: UserRoleMappingCreateNestedManyWithoutUserInput
    ContestAttempt?: ContestAttemptCreateNestedManyWithoutUserInput
    consultationRequests?: ConsultationRequestCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    enrolledCourses?: CourseUserMapperCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChallengeAttemptInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phoneNo?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    state?: string | null
    country?: string | null
    profileImage?: string | null
    currenrStudyLevel?: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userRoleMappings?: UserRoleMappingUncheckedCreateNestedManyWithoutUserInput
    ContestAttempt?: ContestAttemptUncheckedCreateNestedManyWithoutUserInput
    consultationRequests?: ConsultationRequestUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    enrolledCourses?: CourseUserMapperUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChallengeAttemptInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChallengeAttemptInput, UserUncheckedCreateWithoutChallengeAttemptInput>
  }

  export type ChallengeUpsertWithoutChallengeAttemptInput = {
    update: XOR<ChallengeUpdateWithoutChallengeAttemptInput, ChallengeUncheckedUpdateWithoutChallengeAttemptInput>
    create: XOR<ChallengeCreateWithoutChallengeAttemptInput, ChallengeUncheckedCreateWithoutChallengeAttemptInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutChallengeAttemptInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutChallengeAttemptInput, ChallengeUncheckedUpdateWithoutChallengeAttemptInput>
  }

  export type ChallengeUpdateWithoutChallengeAttemptInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChallengeUncheckedUpdateWithoutChallengeAttemptInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutChallengeAttemptInput = {
    update: XOR<UserUpdateWithoutChallengeAttemptInput, UserUncheckedUpdateWithoutChallengeAttemptInput>
    create: XOR<UserCreateWithoutChallengeAttemptInput, UserUncheckedCreateWithoutChallengeAttemptInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChallengeAttemptInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChallengeAttemptInput, UserUncheckedUpdateWithoutChallengeAttemptInput>
  }

  export type UserUpdateWithoutChallengeAttemptInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoleMappings?: UserRoleMappingUpdateManyWithoutUserNestedInput
    ContestAttempt?: ContestAttemptUpdateManyWithoutUserNestedInput
    consultationRequests?: ConsultationRequestUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    enrolledCourses?: CourseUserMapperUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChallengeAttemptInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoleMappings?: UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput
    ContestAttempt?: ContestAttemptUncheckedUpdateManyWithoutUserNestedInput
    consultationRequests?: ConsultationRequestUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    enrolledCourses?: CourseUserMapperUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConsultationRequestCreateWithoutCounselorInput = {
    requestType: $Enums.ConsultationType
    scheduledAt?: Date | string | null
    status?: $Enums.ConsultationStatus
    message?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutConsultationRequestsInput
    meeting?: MeetingCreateNestedOneWithoutConsultationRequestInput
  }

  export type ConsultationRequestUncheckedCreateWithoutCounselorInput = {
    id?: number
    userId: number
    requestType: $Enums.ConsultationType
    scheduledAt?: Date | string | null
    status?: $Enums.ConsultationStatus
    message?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    meeting?: MeetingUncheckedCreateNestedOneWithoutConsultationRequestInput
  }

  export type ConsultationRequestCreateOrConnectWithoutCounselorInput = {
    where: ConsultationRequestWhereUniqueInput
    create: XOR<ConsultationRequestCreateWithoutCounselorInput, ConsultationRequestUncheckedCreateWithoutCounselorInput>
  }

  export type ConsultationRequestCreateManyCounselorInputEnvelope = {
    data: ConsultationRequestCreateManyCounselorInput | ConsultationRequestCreateManyCounselorInput[]
    skipDuplicates?: boolean
  }

  export type MeetingCreateWithoutCounselorInput = {
    id?: string
    meetingProvider: $Enums.MeetingProvider
    meetingRoomId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    status?: $Enums.MeetingStatus
    createdAt?: Date | string
    consultationRequest: ConsultationRequestCreateNestedOneWithoutMeetingInput
    user: UserCreateNestedOneWithoutMeetingsInput
  }

  export type MeetingUncheckedCreateWithoutCounselorInput = {
    id?: string
    consultationRequestId: number
    userId: number
    meetingProvider: $Enums.MeetingProvider
    meetingRoomId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    status?: $Enums.MeetingStatus
    createdAt?: Date | string
  }

  export type MeetingCreateOrConnectWithoutCounselorInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutCounselorInput, MeetingUncheckedCreateWithoutCounselorInput>
  }

  export type MeetingCreateManyCounselorInputEnvelope = {
    data: MeetingCreateManyCounselorInput | MeetingCreateManyCounselorInput[]
    skipDuplicates?: boolean
  }

  export type ConsultationRequestUpsertWithWhereUniqueWithoutCounselorInput = {
    where: ConsultationRequestWhereUniqueInput
    update: XOR<ConsultationRequestUpdateWithoutCounselorInput, ConsultationRequestUncheckedUpdateWithoutCounselorInput>
    create: XOR<ConsultationRequestCreateWithoutCounselorInput, ConsultationRequestUncheckedCreateWithoutCounselorInput>
  }

  export type ConsultationRequestUpdateWithWhereUniqueWithoutCounselorInput = {
    where: ConsultationRequestWhereUniqueInput
    data: XOR<ConsultationRequestUpdateWithoutCounselorInput, ConsultationRequestUncheckedUpdateWithoutCounselorInput>
  }

  export type ConsultationRequestUpdateManyWithWhereWithoutCounselorInput = {
    where: ConsultationRequestScalarWhereInput
    data: XOR<ConsultationRequestUpdateManyMutationInput, ConsultationRequestUncheckedUpdateManyWithoutCounselorInput>
  }

  export type MeetingUpsertWithWhereUniqueWithoutCounselorInput = {
    where: MeetingWhereUniqueInput
    update: XOR<MeetingUpdateWithoutCounselorInput, MeetingUncheckedUpdateWithoutCounselorInput>
    create: XOR<MeetingCreateWithoutCounselorInput, MeetingUncheckedCreateWithoutCounselorInput>
  }

  export type MeetingUpdateWithWhereUniqueWithoutCounselorInput = {
    where: MeetingWhereUniqueInput
    data: XOR<MeetingUpdateWithoutCounselorInput, MeetingUncheckedUpdateWithoutCounselorInput>
  }

  export type MeetingUpdateManyWithWhereWithoutCounselorInput = {
    where: MeetingScalarWhereInput
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyWithoutCounselorInput>
  }

  export type UserCreateWithoutConsultationRequestsInput = {
    firstName?: string | null
    lastName?: string | null
    phoneNo?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    state?: string | null
    country?: string | null
    profileImage?: string | null
    currenrStudyLevel?: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userRoleMappings?: UserRoleMappingCreateNestedManyWithoutUserInput
    ContestAttempt?: ContestAttemptCreateNestedManyWithoutUserInput
    ChallengeAttempt?: ChallengeAttemptCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    enrolledCourses?: CourseUserMapperCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConsultationRequestsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phoneNo?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    state?: string | null
    country?: string | null
    profileImage?: string | null
    currenrStudyLevel?: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userRoleMappings?: UserRoleMappingUncheckedCreateNestedManyWithoutUserInput
    ContestAttempt?: ContestAttemptUncheckedCreateNestedManyWithoutUserInput
    ChallengeAttempt?: ChallengeAttemptUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    enrolledCourses?: CourseUserMapperUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConsultationRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConsultationRequestsInput, UserUncheckedCreateWithoutConsultationRequestsInput>
  }

  export type CounselorCreateWithoutConsultationRequestsInput = {
    id?: string
    name: string
    email: string
    password: string
    bio?: string | null
    profileImage?: string | null
    specialization?: string | null
    experience?: number | null
    employmentType: $Enums.EmploymentType
    isActive?: boolean
    rating?: number
    totalMeetings?: number
    totalRevenue?: number
    createdByAdminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    meetings?: MeetingCreateNestedManyWithoutCounselorInput
  }

  export type CounselorUncheckedCreateWithoutConsultationRequestsInput = {
    id?: string
    name: string
    email: string
    password: string
    bio?: string | null
    profileImage?: string | null
    specialization?: string | null
    experience?: number | null
    employmentType: $Enums.EmploymentType
    isActive?: boolean
    rating?: number
    totalMeetings?: number
    totalRevenue?: number
    createdByAdminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    meetings?: MeetingUncheckedCreateNestedManyWithoutCounselorInput
  }

  export type CounselorCreateOrConnectWithoutConsultationRequestsInput = {
    where: CounselorWhereUniqueInput
    create: XOR<CounselorCreateWithoutConsultationRequestsInput, CounselorUncheckedCreateWithoutConsultationRequestsInput>
  }

  export type MeetingCreateWithoutConsultationRequestInput = {
    id?: string
    meetingProvider: $Enums.MeetingProvider
    meetingRoomId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    status?: $Enums.MeetingStatus
    createdAt?: Date | string
    counselor: CounselorCreateNestedOneWithoutMeetingsInput
    user: UserCreateNestedOneWithoutMeetingsInput
  }

  export type MeetingUncheckedCreateWithoutConsultationRequestInput = {
    id?: string
    counselorId: string
    userId: number
    meetingProvider: $Enums.MeetingProvider
    meetingRoomId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    status?: $Enums.MeetingStatus
    createdAt?: Date | string
  }

  export type MeetingCreateOrConnectWithoutConsultationRequestInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutConsultationRequestInput, MeetingUncheckedCreateWithoutConsultationRequestInput>
  }

  export type UserUpsertWithoutConsultationRequestsInput = {
    update: XOR<UserUpdateWithoutConsultationRequestsInput, UserUncheckedUpdateWithoutConsultationRequestsInput>
    create: XOR<UserCreateWithoutConsultationRequestsInput, UserUncheckedCreateWithoutConsultationRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConsultationRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConsultationRequestsInput, UserUncheckedUpdateWithoutConsultationRequestsInput>
  }

  export type UserUpdateWithoutConsultationRequestsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoleMappings?: UserRoleMappingUpdateManyWithoutUserNestedInput
    ContestAttempt?: ContestAttemptUpdateManyWithoutUserNestedInput
    ChallengeAttempt?: ChallengeAttemptUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    enrolledCourses?: CourseUserMapperUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConsultationRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoleMappings?: UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput
    ContestAttempt?: ContestAttemptUncheckedUpdateManyWithoutUserNestedInput
    ChallengeAttempt?: ChallengeAttemptUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    enrolledCourses?: CourseUserMapperUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CounselorUpsertWithoutConsultationRequestsInput = {
    update: XOR<CounselorUpdateWithoutConsultationRequestsInput, CounselorUncheckedUpdateWithoutConsultationRequestsInput>
    create: XOR<CounselorCreateWithoutConsultationRequestsInput, CounselorUncheckedCreateWithoutConsultationRequestsInput>
    where?: CounselorWhereInput
  }

  export type CounselorUpdateToOneWithWhereWithoutConsultationRequestsInput = {
    where?: CounselorWhereInput
    data: XOR<CounselorUpdateWithoutConsultationRequestsInput, CounselorUncheckedUpdateWithoutConsultationRequestsInput>
  }

  export type CounselorUpdateWithoutConsultationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalMeetings?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetings?: MeetingUpdateManyWithoutCounselorNestedInput
  }

  export type CounselorUncheckedUpdateWithoutConsultationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalMeetings?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetings?: MeetingUncheckedUpdateManyWithoutCounselorNestedInput
  }

  export type MeetingUpsertWithoutConsultationRequestInput = {
    update: XOR<MeetingUpdateWithoutConsultationRequestInput, MeetingUncheckedUpdateWithoutConsultationRequestInput>
    create: XOR<MeetingCreateWithoutConsultationRequestInput, MeetingUncheckedCreateWithoutConsultationRequestInput>
    where?: MeetingWhereInput
  }

  export type MeetingUpdateToOneWithWhereWithoutConsultationRequestInput = {
    where?: MeetingWhereInput
    data: XOR<MeetingUpdateWithoutConsultationRequestInput, MeetingUncheckedUpdateWithoutConsultationRequestInput>
  }

  export type MeetingUpdateWithoutConsultationRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingProvider?: EnumMeetingProviderFieldUpdateOperationsInput | $Enums.MeetingProvider
    meetingRoomId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    counselor?: CounselorUpdateOneRequiredWithoutMeetingsNestedInput
    user?: UserUpdateOneRequiredWithoutMeetingsNestedInput
  }

  export type MeetingUncheckedUpdateWithoutConsultationRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    counselorId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    meetingProvider?: EnumMeetingProviderFieldUpdateOperationsInput | $Enums.MeetingProvider
    meetingRoomId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationRequestCreateWithoutMeetingInput = {
    requestType: $Enums.ConsultationType
    scheduledAt?: Date | string | null
    status?: $Enums.ConsultationStatus
    message?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutConsultationRequestsInput
    counselor: CounselorCreateNestedOneWithoutConsultationRequestsInput
  }

  export type ConsultationRequestUncheckedCreateWithoutMeetingInput = {
    id?: number
    userId: number
    counselorId: string
    requestType: $Enums.ConsultationType
    scheduledAt?: Date | string | null
    status?: $Enums.ConsultationStatus
    message?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ConsultationRequestCreateOrConnectWithoutMeetingInput = {
    where: ConsultationRequestWhereUniqueInput
    create: XOR<ConsultationRequestCreateWithoutMeetingInput, ConsultationRequestUncheckedCreateWithoutMeetingInput>
  }

  export type CounselorCreateWithoutMeetingsInput = {
    id?: string
    name: string
    email: string
    password: string
    bio?: string | null
    profileImage?: string | null
    specialization?: string | null
    experience?: number | null
    employmentType: $Enums.EmploymentType
    isActive?: boolean
    rating?: number
    totalMeetings?: number
    totalRevenue?: number
    createdByAdminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationRequests?: ConsultationRequestCreateNestedManyWithoutCounselorInput
  }

  export type CounselorUncheckedCreateWithoutMeetingsInput = {
    id?: string
    name: string
    email: string
    password: string
    bio?: string | null
    profileImage?: string | null
    specialization?: string | null
    experience?: number | null
    employmentType: $Enums.EmploymentType
    isActive?: boolean
    rating?: number
    totalMeetings?: number
    totalRevenue?: number
    createdByAdminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationRequests?: ConsultationRequestUncheckedCreateNestedManyWithoutCounselorInput
  }

  export type CounselorCreateOrConnectWithoutMeetingsInput = {
    where: CounselorWhereUniqueInput
    create: XOR<CounselorCreateWithoutMeetingsInput, CounselorUncheckedCreateWithoutMeetingsInput>
  }

  export type UserCreateWithoutMeetingsInput = {
    firstName?: string | null
    lastName?: string | null
    phoneNo?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    state?: string | null
    country?: string | null
    profileImage?: string | null
    currenrStudyLevel?: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userRoleMappings?: UserRoleMappingCreateNestedManyWithoutUserInput
    ContestAttempt?: ContestAttemptCreateNestedManyWithoutUserInput
    ChallengeAttempt?: ChallengeAttemptCreateNestedManyWithoutUserInput
    consultationRequests?: ConsultationRequestCreateNestedManyWithoutUserInput
    enrolledCourses?: CourseUserMapperCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMeetingsInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    phoneNo?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    state?: string | null
    country?: string | null
    profileImage?: string | null
    currenrStudyLevel?: $Enums.currenrStudylevel | null
    email: string
    username: string
    password: string
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userRoleMappings?: UserRoleMappingUncheckedCreateNestedManyWithoutUserInput
    ContestAttempt?: ContestAttemptUncheckedCreateNestedManyWithoutUserInput
    ChallengeAttempt?: ChallengeAttemptUncheckedCreateNestedManyWithoutUserInput
    consultationRequests?: ConsultationRequestUncheckedCreateNestedManyWithoutUserInput
    enrolledCourses?: CourseUserMapperUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMeetingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMeetingsInput, UserUncheckedCreateWithoutMeetingsInput>
  }

  export type ConsultationRequestUpsertWithoutMeetingInput = {
    update: XOR<ConsultationRequestUpdateWithoutMeetingInput, ConsultationRequestUncheckedUpdateWithoutMeetingInput>
    create: XOR<ConsultationRequestCreateWithoutMeetingInput, ConsultationRequestUncheckedCreateWithoutMeetingInput>
    where?: ConsultationRequestWhereInput
  }

  export type ConsultationRequestUpdateToOneWithWhereWithoutMeetingInput = {
    where?: ConsultationRequestWhereInput
    data: XOR<ConsultationRequestUpdateWithoutMeetingInput, ConsultationRequestUncheckedUpdateWithoutMeetingInput>
  }

  export type ConsultationRequestUpdateWithoutMeetingInput = {
    requestType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumConsultationStatusFieldUpdateOperationsInput | $Enums.ConsultationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConsultationRequestsNestedInput
    counselor?: CounselorUpdateOneRequiredWithoutConsultationRequestsNestedInput
  }

  export type ConsultationRequestUncheckedUpdateWithoutMeetingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    counselorId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumConsultationStatusFieldUpdateOperationsInput | $Enums.ConsultationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CounselorUpsertWithoutMeetingsInput = {
    update: XOR<CounselorUpdateWithoutMeetingsInput, CounselorUncheckedUpdateWithoutMeetingsInput>
    create: XOR<CounselorCreateWithoutMeetingsInput, CounselorUncheckedCreateWithoutMeetingsInput>
    where?: CounselorWhereInput
  }

  export type CounselorUpdateToOneWithWhereWithoutMeetingsInput = {
    where?: CounselorWhereInput
    data: XOR<CounselorUpdateWithoutMeetingsInput, CounselorUncheckedUpdateWithoutMeetingsInput>
  }

  export type CounselorUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalMeetings?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationRequests?: ConsultationRequestUpdateManyWithoutCounselorNestedInput
  }

  export type CounselorUncheckedUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalMeetings?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationRequests?: ConsultationRequestUncheckedUpdateManyWithoutCounselorNestedInput
  }

  export type UserUpsertWithoutMeetingsInput = {
    update: XOR<UserUpdateWithoutMeetingsInput, UserUncheckedUpdateWithoutMeetingsInput>
    create: XOR<UserCreateWithoutMeetingsInput, UserUncheckedCreateWithoutMeetingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMeetingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMeetingsInput, UserUncheckedUpdateWithoutMeetingsInput>
  }

  export type UserUpdateWithoutMeetingsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoleMappings?: UserRoleMappingUpdateManyWithoutUserNestedInput
    ContestAttempt?: ContestAttemptUpdateManyWithoutUserNestedInput
    ChallengeAttempt?: ChallengeAttemptUpdateManyWithoutUserNestedInput
    consultationRequests?: ConsultationRequestUpdateManyWithoutUserNestedInput
    enrolledCourses?: CourseUserMapperUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMeetingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    currenrStudyLevel?: NullableEnumcurrenrStudylevelFieldUpdateOperationsInput | $Enums.currenrStudylevel | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoleMappings?: UserRoleMappingUncheckedUpdateManyWithoutUserNestedInput
    ContestAttempt?: ContestAttemptUncheckedUpdateManyWithoutUserNestedInput
    ChallengeAttempt?: ChallengeAttemptUncheckedUpdateManyWithoutUserNestedInput
    consultationRequests?: ConsultationRequestUncheckedUpdateManyWithoutUserNestedInput
    enrolledCourses?: CourseUserMapperUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserRoleMappingCreateManyUserInput = {
    id?: number
    roleId: number
    assignedAt?: Date | string
    assignedBy?: number | null
  }

  export type ContestAttemptCreateManyUserInput = {
    id?: number
    contestId: number
    startedAt: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    timeTaken?: number | null
  }

  export type ChallengeAttemptCreateManyUserInput = {
    id?: number
    challengeId: number
    completedAt?: Date | string | null
    earnedPoints: number
  }

  export type ConsultationRequestCreateManyUserInput = {
    id?: number
    counselorId: string
    requestType: $Enums.ConsultationType
    scheduledAt?: Date | string | null
    status?: $Enums.ConsultationStatus
    message?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MeetingCreateManyUserInput = {
    id?: string
    consultationRequestId: number
    counselorId: string
    meetingProvider: $Enums.MeetingProvider
    meetingRoomId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    status?: $Enums.MeetingStatus
    createdAt?: Date | string
  }

  export type CourseUserMapperCreateManyUserInput = {
    id?: number
    courseId: number
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    isCompleted?: boolean
  }

  export type UserRoleMappingUpdateWithoutUserInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
    role?: rolesUpdateOneRequiredWithoutUserRoleMappingsNestedInput
  }

  export type UserRoleMappingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRoleMappingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContestAttemptUpdateWithoutUserInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    ContestAnswer?: ContestAnswerUpdateManyWithoutAttemptNestedInput
    contest?: ContestUpdateOneRequiredWithoutContestAttemptNestedInput
  }

  export type ContestAttemptUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    contestId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    ContestAnswer?: ContestAnswerUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type ContestAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    contestId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChallengeAttemptUpdateWithoutUserInput = {
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earnedPoints?: IntFieldUpdateOperationsInput | number
    challenge?: ChallengeUpdateOneRequiredWithoutChallengeAttemptNestedInput
  }

  export type ChallengeAttemptUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    challengeId?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earnedPoints?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    challengeId?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earnedPoints?: IntFieldUpdateOperationsInput | number
  }

  export type ConsultationRequestUpdateWithoutUserInput = {
    requestType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumConsultationStatusFieldUpdateOperationsInput | $Enums.ConsultationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    counselor?: CounselorUpdateOneRequiredWithoutConsultationRequestsNestedInput
    meeting?: MeetingUpdateOneWithoutConsultationRequestNestedInput
  }

  export type ConsultationRequestUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    counselorId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumConsultationStatusFieldUpdateOperationsInput | $Enums.ConsultationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: MeetingUncheckedUpdateOneWithoutConsultationRequestNestedInput
  }

  export type ConsultationRequestUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    counselorId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumConsultationStatusFieldUpdateOperationsInput | $Enums.ConsultationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingProvider?: EnumMeetingProviderFieldUpdateOperationsInput | $Enums.MeetingProvider
    meetingRoomId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationRequest?: ConsultationRequestUpdateOneRequiredWithoutMeetingNestedInput
    counselor?: CounselorUpdateOneRequiredWithoutMeetingsNestedInput
  }

  export type MeetingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationRequestId?: IntFieldUpdateOperationsInput | number
    counselorId?: StringFieldUpdateOperationsInput | string
    meetingProvider?: EnumMeetingProviderFieldUpdateOperationsInput | $Enums.MeetingProvider
    meetingRoomId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationRequestId?: IntFieldUpdateOperationsInput | number
    counselorId?: StringFieldUpdateOperationsInput | string
    meetingProvider?: EnumMeetingProviderFieldUpdateOperationsInput | $Enums.MeetingProvider
    meetingRoomId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUserMapperUpdateWithoutUserInput = {
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    course?: CoursesUpdateOneRequiredWithoutEnrolledUsersNestedInput
  }

  export type CourseUserMapperUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseUserMapperUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleMappingCreateManyRoleInput = {
    id?: number
    userId: number
    assignedAt?: Date | string
    assignedBy?: number | null
  }

  export type UserRoleMappingUpdateWithoutRoleInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutUserRoleMappingsNestedInput
  }

  export type UserRoleMappingUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRoleMappingUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LessonsCreateManyCourseInput = {
    id?: number
    title: string
    description?: string | null
    videoType: string
    videoId: string
    duration?: number | null
    order: number
    isFreePreview: boolean
  }

  export type CourseUserMapperCreateManyCourseInput = {
    id?: number
    userId: number
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    isCompleted?: boolean
  }

  export type LessonsUpdateWithoutCourseInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoType?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isFreePreview?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LessonsUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoType?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isFreePreview?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LessonsUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoType?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isFreePreview?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseUserMapperUpdateWithoutCourseInput = {
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutEnrolledCoursesNestedInput
  }

  export type CourseUserMapperUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseUserMapperUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContestQuestionCreateManyContestInput = {
    id?: number
    questionText: string
    optionA: string
    optionB: string
    optionC?: string | null
    optionD?: string | null
    correctOption: string
    marks: number
  }

  export type ContestAttemptCreateManyContestInput = {
    id?: number
    userId: number
    startedAt: Date | string
    submittedAt?: Date | string | null
    score?: number | null
    timeTaken?: number | null
  }

  export type ContestQuestionUpdateWithoutContestInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: NullableStringFieldUpdateOperationsInput | string | null
    optionD?: NullableStringFieldUpdateOperationsInput | string | null
    correctOption?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    contestanswer?: ContestAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type ContestQuestionUncheckedUpdateWithoutContestInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: NullableStringFieldUpdateOperationsInput | string | null
    optionD?: NullableStringFieldUpdateOperationsInput | string | null
    correctOption?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    contestanswer?: ContestAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type ContestQuestionUncheckedUpdateManyWithoutContestInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: NullableStringFieldUpdateOperationsInput | string | null
    optionD?: NullableStringFieldUpdateOperationsInput | string | null
    correctOption?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
  }

  export type ContestAttemptUpdateWithoutContestInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    ContestAnswer?: ContestAnswerUpdateManyWithoutAttemptNestedInput
    user?: UserUpdateOneRequiredWithoutContestAttemptNestedInput
  }

  export type ContestAttemptUncheckedUpdateWithoutContestInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    ContestAnswer?: ContestAnswerUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type ContestAttemptUncheckedUpdateManyWithoutContestInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContestAnswerCreateManyQuestionInput = {
    id?: number
    attemptId: number
    selectedOption: string
    isCorrect: boolean
  }

  export type ContestAnswerUpdateWithoutQuestionInput = {
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    attempt?: ContestAttemptUpdateOneRequiredWithoutContestAnswerNestedInput
  }

  export type ContestAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContestAnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContestAnswerCreateManyAttemptInput = {
    id?: number
    questionId: number
    selectedOption: string
    isCorrect: boolean
  }

  export type ContestAnswerUpdateWithoutAttemptInput = {
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    question?: ContestQuestionUpdateOneRequiredWithoutContestanswerNestedInput
  }

  export type ContestAnswerUncheckedUpdateWithoutAttemptInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContestAnswerUncheckedUpdateManyWithoutAttemptInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChallengeAttemptCreateManyChallengeInput = {
    id?: number
    userId: number
    completedAt?: Date | string | null
    earnedPoints: number
  }

  export type ChallengeAttemptUpdateWithoutChallengeInput = {
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earnedPoints?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutChallengeAttemptNestedInput
  }

  export type ChallengeAttemptUncheckedUpdateWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earnedPoints?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeAttemptUncheckedUpdateManyWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earnedPoints?: IntFieldUpdateOperationsInput | number
  }

  export type ConsultationRequestCreateManyCounselorInput = {
    id?: number
    userId: number
    requestType: $Enums.ConsultationType
    scheduledAt?: Date | string | null
    status?: $Enums.ConsultationStatus
    message?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MeetingCreateManyCounselorInput = {
    id?: string
    consultationRequestId: number
    userId: number
    meetingProvider: $Enums.MeetingProvider
    meetingRoomId: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    status?: $Enums.MeetingStatus
    createdAt?: Date | string
  }

  export type ConsultationRequestUpdateWithoutCounselorInput = {
    requestType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumConsultationStatusFieldUpdateOperationsInput | $Enums.ConsultationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConsultationRequestsNestedInput
    meeting?: MeetingUpdateOneWithoutConsultationRequestNestedInput
  }

  export type ConsultationRequestUncheckedUpdateWithoutCounselorInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    requestType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumConsultationStatusFieldUpdateOperationsInput | $Enums.ConsultationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: MeetingUncheckedUpdateOneWithoutConsultationRequestNestedInput
  }

  export type ConsultationRequestUncheckedUpdateManyWithoutCounselorInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    requestType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumConsultationStatusFieldUpdateOperationsInput | $Enums.ConsultationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUpdateWithoutCounselorInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingProvider?: EnumMeetingProviderFieldUpdateOperationsInput | $Enums.MeetingProvider
    meetingRoomId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationRequest?: ConsultationRequestUpdateOneRequiredWithoutMeetingNestedInput
    user?: UserUpdateOneRequiredWithoutMeetingsNestedInput
  }

  export type MeetingUncheckedUpdateWithoutCounselorInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationRequestId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    meetingProvider?: EnumMeetingProviderFieldUpdateOperationsInput | $Enums.MeetingProvider
    meetingRoomId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUncheckedUpdateManyWithoutCounselorInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationRequestId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    meetingProvider?: EnumMeetingProviderFieldUpdateOperationsInput | $Enums.MeetingProvider
    meetingRoomId?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolesCountOutputTypeDefaultArgs instead
     */
    export type RolesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoursesCountOutputTypeDefaultArgs instead
     */
    export type CoursesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoursesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContestCountOutputTypeDefaultArgs instead
     */
    export type ContestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContestQuestionCountOutputTypeDefaultArgs instead
     */
    export type ContestQuestionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContestQuestionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContestAttemptCountOutputTypeDefaultArgs instead
     */
    export type ContestAttemptCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContestAttemptCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChallengeCountOutputTypeDefaultArgs instead
     */
    export type ChallengeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChallengeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CounselorCountOutputTypeDefaultArgs instead
     */
    export type CounselorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CounselorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rolesDefaultArgs instead
     */
    export type rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleMappingDefaultArgs instead
     */
    export type UserRoleMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleMappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoursesDefaultArgs instead
     */
    export type CoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoursesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LessonsDefaultArgs instead
     */
    export type LessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LessonsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseUserMapperDefaultArgs instead
     */
    export type CourseUserMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseUserMapperDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContestDefaultArgs instead
     */
    export type ContestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContestQuestionDefaultArgs instead
     */
    export type ContestQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContestQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContestAttemptDefaultArgs instead
     */
    export type ContestAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContestAttemptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContestAnswerDefaultArgs instead
     */
    export type ContestAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContestAnswerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChallengeDefaultArgs instead
     */
    export type ChallengeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChallengeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChallengeAttemptDefaultArgs instead
     */
    export type ChallengeAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChallengeAttemptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CounselorDefaultArgs instead
     */
    export type CounselorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CounselorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsultationRequestDefaultArgs instead
     */
    export type ConsultationRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsultationRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MeetingDefaultArgs instead
     */
    export type MeetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MeetingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResourceDefaultArgs instead
     */
    export type ResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResourceDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}